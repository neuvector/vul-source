Candidate: CVE-2023-34454
PublicDate: 2023-06-15 17:15:00 UTC
References:
 https://github.com/xerial/snappy-java/blob/05c39b2ca9b5b7b39611529cc302d3d796329611/src/main/java/org/xerial/snappy/Snappy.java#L169
 https://github.com/xerial/snappy-java/blob/05c39b2ca9b5b7b39611529cc302d3d796329611/src/main/java/org/xerial/snappy/Snappy.java#L422
 https://github.com/xerial/snappy-java/blob/master/src/main/java/org/xerial/snappy/Snappy.java
 https://github.com/xerial/snappy-java/security/advisories/GHSA-fjpj-2g6w-x25r
 https://github.com/xerial/snappy-java/commit/d0042551e4a3509a725038eb9b2ad1f683674d94
 https://www.cve.org/CVERecord?id=CVE-2023-34454
Description:
 snappy-java is a fast compressor/decompressor for Java. Due to unchecked
 multiplications, an integer overflow may occur in versions prior to
 1.1.10.1, causing an unrecoverable fatal error. The function
 `compress(char[] input)` in the file `Snappy.java` receives an array of
 characters and compresses it. It does so by multiplying the length by 2 and
 passing it to the rawCompress` function. Since the length is not tested,
 the multiplication by two can cause an integer overflow and become
 negative. The rawCompress function then uses the received length and passes
 it to the natively compiled maxCompressedLength function, using the
 returned value to allocate a byte array. Since the maxCompressedLength
 function treats the length as an unsigned integer, it doesn’t care that it
 is negative, and it returns a valid value, which is casted to a signed
 integer by the Java engine. If the result is negative, a
 `java.lang.NegativeArraySizeException` exception will be raised while
 trying to allocate the array `buf`. On the other side, if the result is
 positive, the `buf` array will successfully be allocated, but its size
 might be too small to use for the compression, causing a fatal Access
 Violation error. The same issue exists also when using the `compress`
 functions that receive double, float, int, long and short, each using a
 different multiplier that may cause the same issue. The issue most likely
 won’t occur when using a byte array, since creating a byte array of size
 0x80000000 (or any other negative value) is impossible in the first place.
 Version 1.1.10.1 contains a patch for this issue.
Ubuntu-Description:
Notes:
Mitigation:
Bugs:
Priority: medium
Discovered-by:
Assigned-to:
CVSS:
 nvd: CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H [7.5 HIGH]

Patches_snappy-java:
upstream_snappy-java: needs-triage
trusty_snappy-java: ignored (end of standard support)
trusty/esm_snappy-java: ignored (end of ESM support, was needs-triage)
esm-infra-legacy/trusty_snappy-java: needs-triage
xenial_snappy-java: ignored (end of standard support)
esm-apps/xenial_snappy-java: needs-triage
bionic_snappy-java: ignored (end of standard support)
esm-apps/bionic_snappy-java: needs-triage
focal_snappy-java: needs-triage
esm-apps/focal_snappy-java: needs-triage
jammy_snappy-java: needs-triage
esm-apps/jammy_snappy-java: needs-triage
kinetic_snappy-java: ignored (end of life, was needs-triage)
lunar_snappy-java: ignored (end of life, was needs-triage)
mantic_snappy-java: ignored (end of life, was needs-triage)
noble_snappy-java: needs-triage
esm-apps/noble_snappy-java: needs-triage
oracular_snappy-java: needs-triage
plucky_snappy-java: needs-triage
devel_snappy-java: needs-triage
