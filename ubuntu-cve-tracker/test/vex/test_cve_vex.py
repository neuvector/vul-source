import json
import pytest
import requests

from datalib import (
    ReleaseStorage,
    UCT,
    UCTCVEStorage,
    UCTPackageStorage,
)

from data_generation.vex_lib import generate_vex_document

expected_output = {
    "metadata": {
        "@context": str,
        "@id": str,
        "author": str,
        "timestamp": str,
        "version": int
    },
    "statements": [
        {
            "vulnerability": {
                "@id": str,
                "name": str,
                "description": str,
                "aliases": list
            },
            "timestamp": str,
            "products": [
                {
                    "@id": str,
                }
            ],
            "status": str,
        }
    ]
}

def generate_vex_documents():
    release_storage = ReleaseStorage()
    active_releases = release_storage.active_ubuntu_releases + release_storage.esm_apps_releases + release_storage.esm_infra_releases + release_storage.legacy_infra_releases

    cve_storage = UCTCVEStorage()
    cve_storage.link_release_storage(release_storage)

    package_storage = UCTPackageStorage()
    package_storage.link_release_storage(release_storage)

    package_storage.load(filter_releases=active_releases)
    cve_storage.link_pkg_storage(package_storage)

    cve_id = "CVE-2021-28429"
    cve_storage.load_cve(cve_id)
    cve_object = cve_storage.get_cve(cve_id)
    output_dict_2021_28429 = generate_vex_document(None, "cve", cve_object)

    cve_id = "CVE-2022-48063"
    cve_storage.load_cve(cve_id)
    cve_object = cve_storage.get_cve(cve_id)
    output_dict_2022_48063 = generate_vex_document(None, "cve", cve_object)

    sample_cves = []
    for cve_id in ['CVE-2021-29510', 'CVE-2024-37535', 'CVE-2024-47814']:
        cve_storage.load_cve(cve_id)
        cve_object = cve_storage.get_cve(cve_id)
        output_dict = generate_vex_document(None, "cve", cve_object)

        sample_cves.append((output_dict, cve_id))

    return output_dict_2021_28429, output_dict_2022_48063, sample_cves

def check_structure(expected, actual, path=""):
    """
    Check if all required fields in a CVE VEX document are present and have the correct types
    """
    if isinstance(expected, dict):
        assert isinstance(actual, dict), f"Expected {path} to be a dict, but got {type(actual).__name__}"
        for key, value in expected.items():
            assert key in actual, f"Missing key: {path + key}"
            check_structure(value, actual[key], path + key + ".")
    elif isinstance(expected, list):
        assert isinstance(actual, list), f"Expected {path} to be a list, but got {type(actual).__name__}"
        if len(expected) > 0:
            for item in actual:
                check_structure(expected[0], item, path + "[]")
    else:
        assert isinstance(actual, expected), f"Expected {path} to be a {expected.__name__}, but got {type(actual).__name__}"

def check_esm_apps_merging(output_dict):
    """
    The VEX CVE files are meant to produce a merged versions for ubuntu releases, meaning that if a package is fixed in
    an ESM PPA, we only want the ESM product to be reported. However, if it is fixed in the archive, despite the release
    being ESM (either Apps or Infra), the archive product should be reported.

    A valid example of that behaviour is CVE-2021-28429, which was fixed in the ESM Apps PPA for Xenial, and in the Archive
    for Bionic and Focal, since the patch was made available by debian. Thus, given that CVE as an input, we check if the
    products in the VEX output correspond to those PPAs
    """
    expected_products = [
        "esm-apps/xenial",
        "bionic",
        "focal"
    ]
    products = output_dict['statements'][0]['products']
    product_identifiers = [product['@id'].split("distro=")[-1] for product in products if "source" in product['@id']]

    for expected_product in expected_products:
        assert expected_product in product_identifiers, f"Missing product: {expected_product}"

def check_esm_infra_merging(output_dict):
    """
    The VEX CVE files are meant to produce a merged versions for ubuntu releases, meaning that if a package is fixed in
    an ESM PPA, we only want the ESM product to be reported.

    A valid example of that behaviour is CVE-2022-48063, which was fixed in the ESM Apps PPA for Xenial and Bionic,
    and in the Archive for Jammy. Thus, given that CVE as an input, we check if the products in the VEX output
    correspond to those PPAs and that the archive entries for Xenial and Bionic are not present
    """
    expected_products = [
        "esm-infra/xenial",
        "esm-infra/bionic",
        "focal"
    ]
    not_expected_products = [
        "xenial",
        "bionic",
    ]

    products = output_dict['statements'][0]['products']
    product_identifiers = [product['@id'].split("distro=")[-1] for product in products if "source" in product['@id']]

    for expected_product in expected_products:
        assert expected_product in product_identifiers, f"Missing product: {expected_product}"

    for not_expected_product in not_expected_products:
        assert not_expected_product not in product_identifiers, f"Unexpected product: {not_expected_product}"

def check_exact_output(sample_cves):
    """
    Check that a specific CVE produces the exact same output as the one stored locally, which is concidered the
    source of truth.
    """
    for output_dict, cve_id in sample_cves:
        with open(UCT + "/test/vex/test_files/" + cve_id + ".json", 'r') as file:
            expected_output_dict = json.load(file)
        # timestamps of VEX file creation will always be different
        output_dict['metadata']['timestamp'] = ""
        expected_output_dict['metadata']['timestamp'] = ""
        assert json.dumps(output_dict, sort_keys=True) == json.dumps(expected_output_dict, sort_keys=True), f"The generated VEX file for CVE {cve_id} does not match the expected output."

def check_cve_id_exists(sample_cves):
    """
    Check that a specific CVE VEX file corresponds to a valid CVE id in the CVE website.
    """
    for output_dict, _ in sample_cves:
        cve_id = output_dict['statements'][0]['vulnerability']['@id']
        response = requests.get(cve_id)
        assert response.status_code == 200, f"The CVE link {cve_id} did not return a 200 status code."

@pytest.fixture(scope="module")
def vex_documents():
    return generate_vex_documents()

def test_structure(vex_documents):
    output_dict_2021_28429, _, _ = vex_documents
    check_structure(expected_output, output_dict_2021_28429)

def test_esm_apps_merging(vex_documents):
    output_dict_2021_28429, _, _ = vex_documents
    check_esm_apps_merging(output_dict_2021_28429)

def test_esm_infra_merging(vex_documents):
    _, output_dict_2022_48063, _ = vex_documents
    check_esm_infra_merging(output_dict_2022_48063)

def test_exact_output(vex_documents):
    _, _, sample_cves = vex_documents
    check_exact_output(sample_cves)

def test_cve_id_exists(vex_documents):
    _, _, sample_cves = vex_documents
    check_cve_id_exists(sample_cves)


if __name__ == "__main__":
    pytest.main()
