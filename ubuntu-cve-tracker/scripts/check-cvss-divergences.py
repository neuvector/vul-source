#!/usr/bin/python3
#
# SPDX-License-Identifier: GPL-3.0-only 
#
# This file is part of the Ubuntu CVE Tracker (UCT) scripts, its purpose is to
# detect mismatches between Ubuntu priority and CVSS severity in CVEs.
#
# Author: Maria Emilia Torino <emilia.torino@canonical.com>
# Copyright 2024 Canonical Ltd.
#
# This program is free software: you can redistribute it and/or modify it under
# the terms of the GNU General Public License version 3, as published by the
# Free Software Foundation.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranties of MERCHANTABILITY,
# SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License along with
# this program. If not, see <http://www.gnu.org/licenses/>.


import argparse
import os
import subprocess
import sys
import tempfile
from datetime import datetime
import cve_lib

ACTION_ADD_REASON = "add-reason"
ACTION_EDIT_REASON = "edit-reason"
ACTION_SKIP = "skip"

EXPECTED_CVE_DESCRIPTIONS = (
    "UNSUPPORTED", # ** UNSUPPORTED WHEN ASSIGNED **
    "DISPUTED", # ** DISPUTED **
    "REJECT", # ** REJECT **
    "Note:", # **Note:** This is only exploitable
    "This", # *This bug only affects
    "info", # *info` actually points
    "not" #*not* get upgraded
)

def get_cvss_base_severity(cvss_information):
    base_severity = None
    for cvss in cvss_information:
        if cvss['source'] == "nvd":
            cvss_base_severity = cvss['baseSeverity']
            if cvss_base_severity != "NONE":
                    base_severity = cvss_base_severity
    return base_severity


def display_command_file_usage(output, line_prefix=''):
    output.write(f'{line_prefix} The following commands can be used in this file:\n')
    output.write(f'{line_prefix} \n')
    output.write(f'{line_prefix}"* Add a CVE Ubuntu priority reason to the tracker:"\n')
    output.write(f'{line_prefix}"  <CVE> {ACTION_ADD_REASON} <REASON> ..."\n')
    output.write(f'{line_prefix}"* Add a CVE Ubuntu priority reason in your editor:"\n')
    output.write(f'{line_prefix}"  <CVE> {ACTION_EDIT_REASON} ..."\n')
    output.write(f'{line_prefix}"* Temporarily skip over a CVE:"\n')
    output.write(f'{line_prefix}"  <CVE> {ACTION_SKIP}\n"\n')
    output.flush()


def process_command_file(cves_output_content):
    cves_output_content.seek(0)
    line_number = 0
    cves = set()
    skipped_cves = set()
    cves_to_add_reason_automatically = dict ()
    invalid_lines = dict()
    for line in cves_output_content.readlines():
        line_number += 1

        # We only want to action on lines starting with *
        if not line or not line.startswith('*'):
            continue

        line_content = line.split()
        try:
            # action lines should start with * prefix, followed by a CVE number and desired action
            (cve, action) = (line_content[1].strip().upper(), line_content[2])
        except IndexError:
            invalid_lines[str(line_number)] = [line, "Invalid line format"]
            continue

        # Ignore lines that look like action lines but are expected cve descriptions
        if cve.startswith(EXPECTED_CVE_DESCRIPTIONS):
            continue

        if not cve.startswith('CVE-'):
            # The first arg should look like a CVE ID
            invalid_lines[str(line_number)] = [line, "Invalid CVE ID format"]
            continue

        if cve in cves:
            invalid_lines[str(line_number)] = [line, f"Operation over {cve} was already performed"]
            continue

        cves.add(cve)
        # This action sets the priority reason to the file without opening an editor
        if action == ACTION_ADD_REASON:
            # If the priority reason should be added, it must be present
            try:
                reason = " ".join(line_content[3:])
            except IndexError:
                invalid_lines[str(line_number)] = [line, f"Reason was not specified for {cve}"]
                continue
            cves_to_add_reason_automatically[cve] = [line, reason]

        # This action opens an editor to edit the CVE
        elif action == ACTION_EDIT_REASON:
            try:
                # find_cve will through ValueError exception if cve file is not found
                cve_path= cve_lib.find_cve(cve)
            except ValueError as e:
                invalid_lines[str(line_number)] = [line, f"Unable to find cve file for {cve}: {e}"]
                continue
            cves_to_add_reason_in_editor[cve] = {"path": cve_path}

        elif action == ACTION_SKIP:
            # If the CVE should be skipped, no arguments are allowed
            if len(line_content) > 3:
                invalid_lines[str(line_number)] = [line, "Invalid skip command"]
                continue
            skipped_cves.add(cve)

        else:
            # The second arg must be a known action
            invalid_lines[str(line_number)] = [line, f"Unknown action {action}"]
    return invalid_lines, cves_to_add_reason_automatically, cves_to_add_reason_in_editor, skipped_cves


def active_edit_priority_reason(cve, reason):
    # TODO: check for script dir location
    # TODO: check reason input
    success = True
    cmd = ['./scripts/active_edit', '-c', cve, '-R', reason]
    try:
        subprocess.run(cmd, check=True)
    except subprocess.CalledProcessError as e:
        output(f"ERROR while updating CVE file. {e}")
        success = False
    return success


def report(errors, cves_to_add_reason_automatically, cves_to_add_reason_in_editor, skipped_cves, total, temp_file, interactive, keep_tmp_file):
    print("\n============================ Summary =============================")
    print(f"{total} CVEs needing priority reason")
    print(f"{len(skipped_cves) + len(cves_to_add_reason_automatically) + len(cves_to_add_reason_in_editor)} CVEs processed:")
    print(f" - {len(skipped_cves)} skipped CVE(s)")
    print(f" - {len(cves_to_add_reason_automatically)} CVE(s) automatically updated with their corresponding reasons")
    if not interactive:
        print(f" - {len(cves_to_add_reason_in_editor)} CVE(s) opened in editor for manual edit")
    print(f" - {len(errors)} issue(s)")
    for error in errors:
        if not interactive:
            # In non-interactive mode, we have more information to report
            print(f" - #{error}: {errors[error][1]}: {errors[error][0]}")
        else:
            print(f" - {error}: Unable to edit file.")
    if not interactive and keep_tmp_file:
        print(f"\n\ntempfile preserved at: {temp_file}")


def setup_tmp_file(keep_tmp_file, tmp_file_content_prefix):
    tmp_file_prefix="cves-needing-priority-reason."
    # By default tmpfile is deleted
    # We might want to preserve it for troubleshooting
    delete_tmp_file = True
    if keep_tmp_file:
        delete_tmp_file = False
    output = tempfile.NamedTemporaryFile(prefix=tmp_file_prefix, mode='w+', delete=delete_tmp_file)
    display_command_file_usage(output, tmp_file_content_prefix)
    return output


# TODO: move this to other cve_lib filter
def get_cves_with_mismatches(full_cves_information):
    cves_with_mismatches = dict()
    cves_with_cvss_severity = 0
    for cve in full_cves_information:
        ubuntu_priority = full_cves_information[cve]['Priority'][0]
        cvss_base_severity = get_cvss_base_severity(full_cves_information[cve]['CVSS'])
        if cvss_base_severity:
            cves_with_cvss_severity +=1
            ubuntu_priority_reason = full_cves_information[cve]['Priority'][1]
            if cvss_base_severity.lower() != ubuntu_priority and not ubuntu_priority_reason:
                cves_with_mismatches[cve] = full_cves_information[cve]
    return cves_with_mismatches, cves_with_cvss_severity


def check_date(date):
    try:
        parsed_date = datetime.strptime(date, "%Y-%m-%d")
    except ValueError as e:
        output.write(f"ERROR: invalid date argument value: {date}. {e}")
        sys.exit(1)
    return parsed_date


def spawn_editor(path):
    editor = os.getenv('EDITOR', 'vi')
    subprocess.call([editor, path])


def indent_content(text):
    return text.replace("\n", "\n ")


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "--published-since",
        help="Report CVEs published only since the date specified. Format: YYYY-MM-DD",
    )
    parser.add_argument(
        "--published-until",
        help="Report CVEs published only until the date specified. Format: YYYY-MM-DD",
    )
    parser.add_argument(
        "--packages",
        help="Report CVEs only affecting the list of comma separated packages. Format: pkg1,pkg2",
    )
    parser.add_argument(
        "--interactive",
        action ='store_true',
    )
    parser.add_argument(
        "--keep-tmp-file",
        action ='store_true',
    )
    args = parser.parse_args()

    interactive_mode = False
    original_output = sys.stdout
    keep_tmp_file = args.keep_tmp_file
    if args.interactive:
        # In interactive mode, content is print to std out
        output = sys.stdout
        interactive_mode = True
    else:
        # In non-interactive mode, content is printed to a tmpfile
        tmp_file_content_prefix = '# '
        tmp_file_action_prefix = "* "
        output = setup_tmp_file(keep_tmp_file, tmp_file_content_prefix)

    cve_table_filters = []
    since_date = None
    until_date = None
    if args.published_since:
        since_date = check_date(args.published_since)
        cve_table_filters.append({cve_lib.CVE_FILTER_NAME: cve_lib.cve_published_since, cve_lib.CVE_FILTER_ARGS: {"published_since": since_date}})

    if args.published_until:
        until_date = check_date(args.published_until)
        cve_table_filters.append({cve_lib.CVE_FILTER_NAME: cve_lib.cve_published_until, cve_lib.CVE_FILTER_ARGS: {"published_until": until_date}})

    if args.packages:
        packages = args.packages.split(",")
        cve_table_filters.append({cve_lib.CVE_FILTER_NAME: cve_lib.cve_affecting_pkgs, cve_lib.CVE_FILTER_ARGS: {"packages": packages}})

    try:
        print("\n==== Loading CVEs from UCT ====\n")
        all_cves, embargoed_cves, retired_cves, ignored_cves = cve_lib.get_all_cve_list()
        (
            _,
            _,
            _,
            _,
            full_cves_information,
        ) = cve_lib.load_table(all_cves, embargoed_cves, None, retired_cves, ignored_cves, cve_table_filters)
    except ValueError as e:
        # cve_lib.load_cve() can raises value error on CVE issues
        print(f"ERROR: unable to load CVEs: {e}")
        sys.exit(1)

    cves_to_add_reason_automatically = dict()
    cves_to_add_reason_in_editor = dict ()
    skipped_cves = set()
    errors = set()
    total_cves_to_process = 0
    tmp_file_name = None
    cves_with_mismatches, cves_with_cvss_severity = get_cves_with_mismatches(full_cves_information)
    if cves_with_mismatches:
        total_cves_to_process = len(cves_with_mismatches)

        output.write(f"\n==== Listing {total_cves_to_process} CVEs (out of {cves_with_cvss_severity}) with Ubuntu Priority different than CVSS base severity ====")

        for index, cve in enumerate(cves_with_mismatches):
            # Provide basic CVE metadata
            output.write(f"\n\n=========== {index + 1}/{total_cves_to_process}: {cve} ===========")
            output.write(f"  {indent_content(cves_with_mismatches[cve]['Description'])}")
            output.write(f"\n- Public Date: {cves_with_mismatches[cve]['PublicDate']}")
            output.write(f"\n- Ubuntu Priority: {cves_with_mismatches[cve]['Priority'][0]} || CVSS Severity: {get_cvss_base_severity(cves_with_mismatches[cve]['CVSS'])}")
            output.write(f"\n- Affected packages: {', '.join(cves_with_mismatches[cve]['pkgs'].keys())}")
            output.write(f"\n- Tags: {', '.join(cves_with_mismatches[cve]['tags'])}")
            output.write(f"\n- References: {cves_with_mismatches[cve]['References']}")
            output.write(f"\n- Bugs: {cves_with_mismatches[cve]['Bugs']}")

            # In interactive mode, ask and perform action on every CVE
            if interactive_mode:
                output.write("\n\nAdd priority reason? \nY]es, S]kip for now, or Q]uit]")
                confirm = input()
                if confirm.lower() in ('Y', 'y', 'yes', 'YES'):
                    reason = input("Please add Ubuntu priority reason: ")
                    if not active_edit_priority_reason(cve, reason):
                        errors.add(cve)
                        continue
                    # In interactive mode, we only add to cves_to_add_reason_automatically
                    # for later summary purposes.
                    cves_to_add_reason_automatically[cve] = []
                elif confirm.lower() in ('Q', 'q', 'quit', 'Quit', 'QUIT'):
                    output.write("Quiting...\n")
                    report(errors, cves_to_add_reason_automatically, cves_to_add_reason_in_editor, skipped_cves, total_cves_to_process, None, interactive_mode, keep_tmp_file)
                    sys.exit(0)
                elif confirm.lower() in ('S', 's', 'skip', 'Skip', 'SKIP'):
                    output.write(f"Skipping {cve}\n")
                    skipped_cves.add(cve)
                else:
                    output.write("\n Invalid option, skipping {cve}\n")
                    skipped_cves.add(cve)
            # In non-interactive mode, add cve info to file. Actions will be executed later
            else:
                output.write(f"\n\n{tmp_file_content_prefix}{tmp_file_action_prefix}{cve} {ACTION_ADD_REASON}")
                output.write(f"\n{tmp_file_content_prefix}{tmp_file_action_prefix}{cve} {ACTION_EDIT_REASON}")
                output.write(f"\n{tmp_file_content_prefix}{tmp_file_action_prefix}{cve} {ACTION_SKIP}")
        if not interactive_mode:
            output.flush()
            tmp_file_name = output.name
            # Show tmp file content in configured editor
            spawn_editor(output.name)
            errors, cves_to_add_reason_automatically, cves_to_add_reason_in_editor, skipped_cves = process_command_file(output)
            for cve in cves_to_add_reason_automatically:
                reason = cves_to_add_reason_automatically[cve][1]
                if not active_edit_priority_reason(cve, reason):
                    file_line = cves_to_add_reason_automatically[cve][0]
                    errors[cve]=[file_line, "Unable to add priority reason automatically."]
            for cve in cves_to_add_reason_in_editor:
                spawn_editor(cves_to_add_reason_in_editor[cve]["path"])
            # restore original sys.stdout
            sys.stdout = original_output
    report(errors, cves_to_add_reason_automatically, cves_to_add_reason_in_editor, skipped_cves, total_cves_to_process, tmp_file_name, interactive_mode, keep_tmp_file)