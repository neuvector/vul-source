#!/usr/bin/env python3
import os, argparse, re, datetime, subprocess
import cve_state_tracking

def verify_email(email):
        ''' Verifies email address format '''

        email_pattern = "^[a-zA-Z0-9. _%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]+$"

        if re.fullmatch(email_pattern, email):
                return True

        return False

def send_email(recipients, subject, body):
        ''' Email provided content to provided list of email recipients '''

        subject = "CVSS Diff Report - " + datetime.datetime.now().strftime("%Y-%m-%d")

        send_mail = ["mail", "-s", subject, ','.join(recipients)]
        process = subprocess.run(send_mail, input=body, stdout=subprocess.PIPE, universal_newlines=True)

def cal_degree_diff(priority, severity):
        '''
        Returns the degree of difference between a priority and severity

        e.g.

        - A Medium priority and a High severity results in a degree difference of 1
        - A Critical priority and a Critical severity results in a degree difference of 0

        If a provided priority or severity is currently not tracked in the scores dict, the
        max degree difference will be returned to default include those cases

        If the Ubuntu priority is equal to or larger than the CVSS severity, we will always return
        0 because we only care about instances where the CVSS severity is larger than the Ubuntu priority
        '''

        scores = {"NEGLIGIBLE":0, "LOW":1, "MEDIUM":2, "HIGH":3, "CRITICAL":4}

        # handle edge cases where the provided priority or severity is different than expected
        if priority not in scores or severity not in scores:
                return max(scores.values()) - min(scores.values())

        degree_diff = scores[severity] - scores[priority]

        # This indicates the Ubuntu priority is larger than or equal to the CVSS severity and will be excluded
        if degree_diff <= 0:
            return 0

        return degree_diff

def get_sig_source(cve, cve_d):
        '''
        Returns the most significant (if any) CVSS source available for a CVE.

        The order of precedence for choosing the most significant CVSS source is as follows:

        - CVSS score published by Ubuntu, prioritizing the latest available CVSS version
        - CVSS score published by NVD, prioritizing the latest available CVSS version
        - Maximum CVSS score published by any other source, prioritizing the latest available CVSS version
        '''

        # dict of sources:base_severities for the given CVE
        cve_severities = cve_d[cve]["severities"]

        # handle CVEs with no CVSS score
        if len(cve_severities) == 0:
                return None

        # CVSS versions and sources ordered by significance
        cvss_versions = ["4.0", "3.1", "3.0", "2.0", "1.0"]
        sig_sources = ["ubuntu", "nvd"]

        # check for the most significant Ubuntu or NVD sourced CVSS score, if any
        for source in sig_sources:
                for ver in cvss_versions:
                        cvss_source = source + ":CVSS:" + ver
                        if cvss_source in cve_severities:
                                return cvss_source

        '''
        At this point we know we do not have an Ubuntu/NVD CVSS score, we will now find the first
        most significant source/severity, prioritizing the latest available CVSS version
        '''

        scores = {"NEGLIGIBLE":0, "LOW":1, "MEDIUM":2, "HIGH":3, "CRITICAL":4}

        max_severity = float("-inf")
        max_cvss_source = ''

        for ver in cvss_versions:
                for source in cve_severities:
                        if source.endswith(ver):
                                severity = scores[cve_severities[source]]

                                if severity > max_severity:
                                        max_severity = severity
                                        max_cvss_source = source

                if max_cvss_source != '':
                        return max_cvss_source

        return None

def cal_short_metrics(severity_diffs, diff_types, package_type, min_degree_diff):
        ''' Generates a short metric summary showing the sum of diffs for each category among new, existing, and updated '''

        num_new = 0
        num_existing = 0
        num_updated = 0

        if package_type in ("security", "all"):
                num_new += len(severity_diffs["security"]["new"])
                num_existing += len(severity_diffs["security"]["existing"])
                num_updated += len(severity_diffs["security"]["updated"])

        if package_type in ("kernel", "all"):
                num_new += len(severity_diffs["kernel"]["new"])
                num_existing += len(severity_diffs["kernel"]["existing"])
                num_updated += len(severity_diffs["kernel"]["updated"])

        total = 0

        metrics_output = f"-- Metrics for a difference of at least {min_degree_diff} degree(s) --\n"

        if "new" in diff_types:
                metrics_output += f"\n\t {num_new} - newly added CVEs with severity differences"
                total += num_new
        if "existing" in diff_types:
                metrics_output += f"\n\t {num_existing} - previously existing CVEs with severity differences"
                total +=  + num_existing
        if "updated" in diff_types:
                metrics_output += f"\n\t {num_updated} - CVEs that have just been updated and have severity differences"
                total += num_updated

        metrics_output += f"\n\n\t Total: {total} - CVEs"

        return metrics_output, total

def get_severity_diffs(curr_d, prev_d, req_pkg_type, min_year, min_degree_diff):
        '''
        This function will record CVEs that have differing Ubuntu priorities and CVSS severities

        It will do so by comparing the most up to date CVE data in $UCT, being passed in as curr_d, to a previous cve
        state snapshop that we have saved locally (e.g. the last time we ran this process) which is passed in as prev_d

        The diffs we are interested and will be tracking are:
                new
                        - these are newly added cves (to $UCT) that have a differing priority/cvss severity
                        - this will be considered a "new" diff

                existing
                        - these are already existing cves with a differing priority/cvss severity that we
                          already know about / have seen and reported on previously
                        - this will be considered an "existing" diff

                updated
                        - these are already existing cves that have received an updated (or are receiving for the first
                          time) priority and/or cvss severity and are in state of having a differing priority/cvss severity
                        - this will be considered a "new" diff
        '''

        diffs = {"security": {"new":[], "existing":[], "updated":[]},
                 "kernel": {"new":[], "existing":[], "updated":[]}}

        for cve in curr_d:

                # get current cve data (from $UCT)
                curr_priority = curr_d[cve]["priority"]
                ubuntu_priority_reason = curr_d[cve]["ubuntu_priority_reason"]
                public_date = curr_d[cve]["public_date"]
                packages = curr_d[cve]["packages"]

                # extract the year from the CVE number and public date
                cve_num_date = int(cve.split('-')[1])
                public_date_year = int(public_date.split('-')[0])

                # skip CVEs not published during or after the specified min year
                if min_year != None and cve_num_date < min_year and public_date_year < min_year:
                        continue

                # identify the if this CVE affects kernel or other (security) packages
                if "linux" in packages:
                        cve_pkg_type = "kernel"

                        # skipping kernel cves if a pkg type of only security is requested
                        if req_pkg_type == "security":
                                continue
                else:
                        cve_pkg_type = "security"

                        # skipping security pkg cves if a pkg type of only kernel is requested
                        if req_pkg_type == "kernel":
                                continue

                # get the most significant CVSS source for the given cve
                curr_cvss_source = get_sig_source(cve, curr_d)

                # skip cves we do not need to compare (e.g. they currently do not have a priority or severity that we care about in $UCT)
                # additionally skip cves that have an ubuntu_priority_reason
                if curr_priority == '' or curr_cvss_source == None or ubuntu_priority_reason != '':
                        continue

                curr_severity = curr_d[cve]["severities"][curr_cvss_source]

                # if the degree of difference between the current cve priority and severity is less than the requested min_degree_diff, skip it
                if cal_degree_diff(curr_priority, curr_severity) < min_degree_diff:
                        continue

                # checking if the cve has been newly added since our last check
                if cve not in prev_d:
                        diffs[cve_pkg_type]["new"].append({"cve":cve, "priority":curr_priority, "cvss_source":curr_cvss_source, "severity":curr_severity})
                        continue

                '''
                At this point we know the cve is pre-existing and has a differing priority/severity of at least min_degree_diff
                '''

                # get previous cve data (from local yaml db)
                prev_priority = prev_d[cve]["priority"]
                prev_cvss_source = get_sig_source(cve, prev_d)

                if prev_cvss_source != None:
                        prev_severity = prev_d[cve]["severities"][prev_cvss_source]
                else:
                        prev_severity = None

                # checking if the priority or severity of the cve has changed since the last check
                if curr_priority != prev_priority or curr_severity != prev_severity:
                        diffs[cve_pkg_type]["updated"].append({"cve":cve, "priority":curr_priority, "cvss_source":curr_cvss_source, "severity":curr_severity, "prev_priority":prev_priority, "prev_cvss_source":prev_cvss_source, "prev_severity":prev_severity})
                        continue

                # previously existing mismatch
                diffs[cve_pkg_type]["existing"].append({"cve":cve, "priority":curr_priority, "cvss_source":curr_cvss_source, "severity":curr_severity})

        return diffs

def generate_cvss_diff_report(severity_diffs, diff_types, detail_level):
        ''' Generates a report of identified severity diffs for the specified diff type(s) (new/existing/updated) and detail level (min/less/full) '''

        if detail_level in ("less", "full"):
                output = "-- Start of CVE Severity Diff Report --"
        else: # detail_level == "min"
                output = ""

        for diff_type in diff_types:
                if detail_level in ("less", "full"):
                        output += f"\n\n- {diff_type} cves -"

                for pkg_type in severity_diffs:
                        diffs = severity_diffs[pkg_type][diff_type]

                        # skip displaying pkg_type if we do not have any diffs to report for that type
                        if len(diffs) == 0:
                                continue

                        if detail_level in ("less", "full"):
                                output += f"\n\n\t({pkg_type} cves)\n"

                        for diff in diffs:
                                cve = diff["cve"]
                                priority = diff["priority"]
                                severity = diff["severity"]
                                cvss_source = diff["cvss_source"]


                                if detail_level == "min":
                                        output += f"{cve}\n"

                                elif detail_level == "less":
                                        output += f"\n\t{cve} - {priority} != {severity}"

                                else:
                                        if diff_type in ["new", "existing"]:
                                                output += f"\n\t{cve}:\n\t\tUbuntu Priority {priority} != {cvss_source} - {severity}"

                                        else: # updated cves
                                                prev_priority = diff["priority"]
                                                prev_severity = diff["prev_severity"]
                                                prev_cvss_source = diff["prev_cvss_source"]

                                                updates = ''

                                                if prev_priority != priority:
                                                        updates += f"\n\t\tPriority: {prev_priority} -> {priority}"
                                                if prev_severity != severity:
                                                        updates += f"\n\t\tSeverity: {prev_severity} -> {severity}"

                                                output += f"\n\t{cve}:" + updates + f"\n\t\tUbuntu Priority {priority} != {cvss_source} - {severity}"
        if detail_level in ("less", "full"):
                output += "\n\n--"
        else:
                output = output.strip()

        return output

def main():
        parser = argparse.ArgumentParser(description="Checks for and alerts on CVEs in UCT with differing priorities and severities")

        # detail/content options
        parser.add_argument("--detail-level", default="min", choices=["min", "less", "full"], help="Level of detail for generated output (default=less)")
        parser.add_argument("--diff-type", default="new", choices=["new", "existing", "all"], help="Choose to see only a report of only new, existing, or all (full) diffs (default=new)")
        parser.add_argument("--package-type", default="all", choices=["security", "kernel", "all"], help="Choose if the report should include CVEs against only kernel, security, or all packages (default=all)")
        parser.add_argument("-n", "--no-update", action="store_true", help="Allows for a dry run of the report, will not update CVE state tracking data")
        parser.add_argument("-d", "--degree-diff", type=int, default=1, help="Defines the degree of difference between priorities and severities to search for (default=1)")
        parser.add_argument("-m", "--metrics", action="store_true", help="Prepends out a short metrics summary to output")
        parser.add_argument("-y", "--year-start", type=int, default=None, help="Output will be based on CVEs published on or after the provided year (default 2024)")

        # output options
        parser.add_argument("-p", "--print-report", action="store_true", help="Will print output locally")
        parser.add_argument("-e", "--email-report", type=str, help="Provided value must be a comma separated string of emails to have results sent to")

        args = parser.parse_args()

        # local file in which we are tracking the previous state of each cve (will be stored in $UCT/cache/)
        local_snapshot_file = "cve-state-snapshot.yaml"

        # handling path to $UCT/cache/ both from $UCT/ and $UCT/scripts/
        if os.getcwd().endswith("scripts"):
                local_snapshot_file = "../cache/" + local_snapshot_file
        else:
                local_snapshot_file = "./cache/" + local_snapshot_file

        # load in local cve snapshot db
        local_cve_d = cve_state_tracking.load_cve_yaml_file(local_snapshot_file)

        # load in current cve data from UCT
        cveinfo = cve_state_tracking.get_cveinfo()
        uct_d = cve_state_tracking.parse_cveinfo(cveinfo)

        # identifying types of diffs we want to report on
        if args.diff_type == "all":
                diff_types = ["new", "updated", "existing"]
        elif args.diff_type == "new":
                diff_types = ["new", "updated"]
        else:
                diff_types = ["existing"]

        # generate dict of cves that have differing cvss severities and ubuntu priorities
        severity_diffs = get_severity_diffs(uct_d, local_cve_d, args.package_type, args.year_start, args.degree_diff)

        # generate report
        cvss_diff_report = generate_cvss_diff_report(severity_diffs, diff_types, args.detail_level)

        # include metric summary at the start of of the CVSS diff report if requested
        metrics_output, total_diffs = cal_short_metrics(severity_diffs, diff_types, args.package_type, args.degree_diff)

        if args.metrics:
                cvss_diff_report = metrics_output + "\n\n" + cvss_diff_report

        # locally print out results/report if requested
        if args.print_report:
                print(cvss_diff_report)

        # email results/report if requested
        if total_diffs > 0 and args.email_report != None:

                # verifying format of provided emails
                valid_emails = []
                invalid_emails = []

                emails = args.email_report.split(',')

                for email in emails:
                        email = email.strip()

                        if verify_email(email):
                                valid_emails.append(email)
                        else:
                                invalid_emails.append(email)

                # handling the potential of having been provided invalid email addresses
                if len(invalid_emails) > 0:
                        warning_message = "WARNING: the following emails are not valid email addresses: " + ", ".join(invalid_emails)

                        if len(valid_emails) > 0:
                                warning_message += "\nThe report has only been emailed to the following: " + ", ".join(valid_emails)
                        else:
                                warning_message += "\nPlease address the invalid emails above, the report has not been sent."

                        cvss_diff_report = warning_message + "\n\n" + cvss_diff_report
                        print(warning_message)

                # if at least 1 valid email has been provided, the report will be emailed
                if len(valid_emails) > 0:
                        subject = "CVSS Diff Report - " + datetime.datetime.now().strftime("%Y-%m-%d")
                        send_email(valid_emails, subject, cvss_diff_report)

        # update local cvss db with current state of $UCT if not a dry run
        if not args.no_update:

                # remove keys for each cve in uct_d that we do not need to save to the yaml file
                untracked_keys = ("public_date", "packages", "ubuntu_priority_reason")

                for cve in uct_d:
                        for key in untracked_keys:
                                if key in uct_d[cve]:
                                        del uct_d[cve][key]

                cve_state_tracking.write_cve_yaml_file(local_snapshot_file, uct_d)

if __name__ == "__main__":
        main()
