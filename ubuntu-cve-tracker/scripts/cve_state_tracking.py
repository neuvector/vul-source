#!/usr/bin/env python3
#
# SPDX-License-Identifier: GPL-3.0-only 
#
# This file is part of the Ubuntu CVE Tracker (UCT) scripts, its purpose is to
# provide helper functions to work with the tracker's CVE files.
#
# Author: Ian Constantin <ian.constantin@canonical.com>
# Copyright 2024 Canonical Ltd.
#
# This program is free software: you can redistribute it and/or modify it under
# the terms of the GNU General Public License version 3, as published by the
# Free Software Foundation.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranties of MERCHANTABILITY,
# SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License along with
# this program. If not, see <http://www.gnu.org/licenses/>.


import yaml, sys, os
import cve_lib

def load_cve_yaml_file(filename):
        ''' loads in a yaml file keyed by cves '''

        # check if the file does not exist
        if not os.path.exists(filename):
                # touching file to create it
                with open(filename, 'w') as create_file:
                        pass

                # returning empty dict of cves
                return {}

        with open(filename, 'r') as inF:
                cves = yaml.safe_load(inF)

        # handling case of an empty snapshot file
        if cves == None:
                cves = {}

        return cves

def write_cve_yaml_file(filename, cve_d):
        ''' overwrites specified yaml file provided cve dict '''

        with open(filename, 'w') as outF:
                yaml.dump(cve_d, outF)

def get_cveinfo():
	''' returns a dict of cves and their corresponding data from $UCT '''

	active_cves, embargoed_cves = cve_lib.get_cve_list()

	table, priority, updated_cves, namemap, cveinfo = cve_lib.load_table(active_cves, embargoed_cves)

        # clearing out embargoed cves
	for cve in embargoed_cves:
                cveinfo.pop(cve)

	return cveinfo

def parse_cveinfo(cveinfo):
        ''' returns a dict of cves and their corresponding values (that we are interested in) '''

        cve_d = {}

        for cve in cveinfo:
                priority = cveinfo[cve]["Priority"][0].upper().strip()
                ubuntu_priority_reason = cveinfo[cve]["Priority"][1].strip()

                public_date = cveinfo[cve]["PublicDate"].strip()
                packages = cveinfo[cve]["pkgs"]

                cve_d[cve] = {"priority":priority, "severities":{}, "public_date":public_date, "packages":packages, "ubuntu_priority_reason":ubuntu_priority_reason}

                for entry in cveinfo[cve]["CVSS"]:
                        source = entry["source"].strip()
                        version = entry["vector"][:entry["vector"].index('/')].strip()
                        severity = entry["baseSeverity"].upper().strip()

                        cve_d[cve]["severities"][f"{source}:{version}"] = severity

        return cve_d
