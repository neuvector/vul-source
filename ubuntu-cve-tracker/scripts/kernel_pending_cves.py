#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
# Author: Steve Beattie <steve.beattie@canonical.com>
# Author: Rodrigo Figueiredo Zaiden <rodrigo.zaiden@canonical.com>
# Copyright (C) 2005-2025 Canonical Ltd.
#
# This script is distributed under the terms and conditions of the GNU General
# Public License, Version 2 or later. See http://www.gnu.org/copyleft/gpl.html
# for details.
#
# This script is used for reporting and fixing up kernels that were
# addressed in an update before the CVE was assigned for it. The kernel
# triage bot will mark it as pending with a version that predates the
# last USN issued, so either report or fixup the pending CVE statuses.

import os
import sys
import yaml
import argparse
import requests

import cve_lib
import usn_lib
from kernel_lib import get_kernel_pending_fixes
from uct.config import read_uct_config

def load_yaml_file(debug=False):
    KERNEL_SRU_TOOLS = 'kernel_sru_tools'
    config = read_uct_config()
    if config.get(KERNEL_SRU_TOOLS):
        kernel_series_file = os.path.join(config[KERNEL_SRU_TOOLS], 'info', 'kernel-series.yaml')
        try:
            with open(kernel_series_file, "r") as f:
                return yaml.safe_load(f)
        except yaml.YAMLError as e:
            print(f"Error parsing local kernel-series YAML: {e}")

    kernel_series_url = "https://kernel.ubuntu.com/info/kernel-series.yaml"
    if debug:
        print(f"{KERNEL_SRU_TOOLS} not configured, trying to fetch kernels from {kernel_series_url}")

    try:
        response = requests.get(kernel_series_url, timeout=10)
        response.raise_for_status()
        return yaml.safe_load(response.text)
    except (requests.RequestException, yaml.YAMLError) as e:
        print(f"Error fetching kernel-series YAML from URL: {e}")

    error_message = f'''
Not possible to find all kernels. {KERNEL_SRU_TOOLS} variable is not configured
and {kernel_series_url} does not seem to be available. The alternatives are:
 - Provide kernels with argument -k (--kernel) [eg.: -k linux linux-lowlatency linux-aws]
 - Configure {KERNEL_SRU_TOOLS} path in ubuntu-cve-tracker.conf;
 - Verify why {kernel_series_url} is not responding;

To configure {KERNEL_SRU_TOOLS}:
  $ git clone https://kernel.ubuntu.com/forgejo/kernel/kernel-versions.git
  $ echo >> ~/.ubuntu-cve-tracker.conf
  $ echo "{KERNEL_SRU_TOOLS}='$(pwd)/kernel-versions'" >> ~/.ubuntu-cve-tracker.conf
'''
    print(error_message)
    sys.exit(1)

def main(argv=None):
    parser = argparse.ArgumentParser(description='Script to report fixed Kernel CVEs')
    parser.add_argument('-d', '--debug', action='store_true', help='Debugging mode')
    parser.add_argument('-D', '--database', action='store', help='USN database pickle')
    parser.add_argument('-r', '--release', action='store', nargs='*', help='Release(s) to limit the search, default is all')
    parser.add_argument('-k', '--kernel', action='store', nargs='*', help='Kernel(s) to limit the search, default is all')
    parser.add_argument('-u', '--update', action='store_true', help='Update status to released')
    args = parser.parse_args(argv)

    kernels = set()
    releases = set()

    if args.kernel:
        kernels = args.kernel
    else:
        kernel_series = load_yaml_file(args.debug)
        for release in kernel_series:
            if release == 'defaults': continue
            if 'sources' in kernel_series[release]:
                for kernel in kernel_series[release]['sources']:
                    kernels.add(kernel)

    if args.release:
        releases = args.release
    else:
        # cleaning the release list with:
        # cve_lib.all_releases - cve_lib.external_releases
        releases = [x for x in cve_lib.all_releases if x not in cve_lib.external_releases]
    releases = cve_lib.release_sort(releases)

    active, embargoed = cve_lib.get_cve_list()
    cve_lib.build_subproject_dir_cache()
    allcves = cve_lib.load_all(active, embargoed)

    usndb = usn_lib.USNdb([], args.database, opt=usn_lib.USNdbOpt(use_glitches=True, debug=args.debug))

    for kernel in sorted(kernels):
        for release in releases:
            flag_header=True

            if args.debug:
                print(f'{kernel} {release}')

            last_usn_version = usndb.get_latest_usn_version(kernel, cve_lib.get_orig_rel_name(release))
            if last_usn_version:
                kernel_release_version = f'\n{kernel} {release} {last_usn_version}'
                if args.debug:
                    print(kernel_release_version)

                pending_fixes = get_kernel_pending_fixes(allcves, kernel,'0', last_usn_version,
                                                        only_releases=[release])
                if pending_fixes:
                    for cve, _, _, state, version in pending_fixes:
                        if state == 'pending':
                            # use the flag to print only once, per affected kernel
                            # if not already printed using debug argument
                            if flag_header and not args.debug:
                                print(kernel_release_version)
                                flag_header=False

                            print(f'{cve}: {state} {version}')
                            if args.update:
                                cve_lib.update_state(cve_lib.find_cve(cve), kernel,
                                                    release, "released", version)

if __name__ == "__main__":
    main()
