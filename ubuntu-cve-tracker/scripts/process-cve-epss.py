import json, yaml, requests, time, os, datetime, argparse
import cve_state_tracking

def filter_epss_entries(cve_d, threshold, min_epss_score):
        ''' this will remove all cves from cve_d that have a date older than threshold days or an epss score lower than min_epss_score '''

        for cve in tuple(cve_d.keys()):
                epss = cve_d[cve]["epss"]
                date = cve_d[cve]["date"]

                epss_date = datetime.datetime.strptime(date, "%Y-%m-%d").date()
                today = datetime.datetime.today().date()

                diff = (today - epss_date).days

                if diff > threshold or epss < min_epss_score:
                        cve_d.pop(cve)

        return cve_d

def get_sig_epss_scores(epss):
        ''' queries the first.org EPSS api to retrieve all the CVEs that currently have an EPSS score greater than the one provided '''

        '''
        The api seems to max out at a results limit of 10,000, however, timeout issues have been observed when using larger limit + offset
        combinations over sequential queries. A limit of 2,000 and subsequent offset increments of 2,000 seems to be provide stable performance
        '''
        limit = 2000
        offset = 0

        # amount of times we want to resend a request to the api in case of a failure
        retries = 3
        delay = 0

        # this will hold the cves and epss scores that we retrieve from the api
        cve_d = {}

        # endpoint url to the first epss api
        url = "https://api.first.org/data/v1/epss?"

        while True: #loop sequentially until we retrieve all results from the api

                try: # checking to see if our request resulted in an http error (most likely a timeout)
                        response = requests.get(url, params={"epss-gt":epss, "limit":limit, "offset":offset})
                        response.raise_for_status()
                    
                except Exception as e:
                        print(e)

                        # exit if max number of retires or delay has been reached, otherwise, increment sleep delay and try again
                        retries -= 1

                        if retries == 0 or delay == 60:
                                print("Too many failures for first.org epss api, exiting ...")
                                exit()
                        else:
                                # incrementing delay for the next request
                                delay += 5

                                # sleep for the specified number of seconds (if any)
                                time.sleep(delay)

                                continue

                # reset retries (in case the request initially failed and afterwards succeeded), carrying current delay forward
                retries = 3

                # convert request response to a dict
                response_data = response.json()

                # the total value returned by the api signifies how many results match our provided params
                total = response_data["total"]
                data = response_data["data"]

                # add the entries we received to our cve dict
                for entry in data:
                        cve_d[entry["cve"]] = {"epss":entry["epss"], "date":entry["date"]}

                # if we have not yet retrieved all the available results, increment the offset by our limit and continue querying
                if len(cve_d) < total:
                        offset += limit
                        continue

                return cve_d

def main():
        parser = argparse.ArgumentParser(description="Queries first.org epss api for cve epss scores")

        parser.add_argument("-e", "--epss-score", type=str, default="0.95", help="The epss score we will consider significant (default=0.95)")
        parser.add_argument("-d", "--days-threshold", type=int, default=30, help="The number of days after which a local epss score is considered old and will be removed")

        args = parser.parse_args()

        # query first.org epss api for cves with an EPSS score greater than sig_epss_score
        sig_epss_score = args.epss_score
        sig_cves = get_sig_epss_scores(sig_epss_score)

        # load in current cve data from $UCT/active
        cveinfo = cve_state_tracking.get_cveinfo()

        # filter out cves in sig_cves that are not currently in $UCT/active
        for cve in tuple(sig_cves.keys()):
            if cve not in cveinfo:
                sig_cves.pop(cve)

        # local file in which we are tracking cves with a significant epss score (will be stored in $UCT/cache/)
        local_epss_file = "cve-epss.yaml"

        # handling path to $UCT/cache/ both from $UCT/ and $UCT/scripts/
        if os.getcwd().endswith("scripts"):
                local_epss_file = "../cache/" + local_epss_file
        else:
                local_epss_file = "./cache/" + local_epss_file

        # load in local cve snapshot db
        local_sig_cves = cve_state_tracking.load_cve_yaml_file(local_epss_file)

        # updating the cve-epss scores that we are tracking, new ones will be added, existing ones will have their date and score updated
        local_sig_cves.update(sig_cves)

        # remove outdated entries or entries with an epss score lower than the currently set sig_epss_score
        threshold = args.days_threshold
        filter_epss_entries(local_sig_cves, threshold, sig_epss_score)

        # update local epss file
        cve_state_tracking.write_cve_yaml_file(local_epss_file, local_sig_cves)

if __name__ == "__main__":
        main()
