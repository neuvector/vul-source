#!/usr/bin/env python3
#
# Author: Diogo Sousa <diogo.sousa@canonical.com>
#
# Report the point in time UCT status of CVEs contained in the KEV
#
import csv
import json
import os, sys
import tempfile
from argparse import ArgumentParser, Namespace
from json import JSONDecodeError

import requests
from requests import HTTPError

import cve_lib

KEV_CATALOG_URL = "https://www.cisa.gov/sites/default/files/feeds/known_exploited_vulnerabilities.json"


def get_pending_packages(packages: dict[str, dict[str, list[str]]]) -> list[tuple[str, str, str]]:
    pending = []
    for package, statuses in packages.items():
        esm_apps_normal_releases = {release.split("/")[1] for release in statuses.keys() if "esm-apps" in release}
        for suite, status in statuses.items():
            if "upstream" in suite or "devel" in suite:
                continue
            if status[0] in {"needed", "needs-triage", "deferred"}:  # First entry in status is the present state
                if suite not in esm_apps_normal_releases:  # Do not add release if release has an esm-apps entry
                    pending.append((package, suite, status[0]))

    return pending


def get_not_for_us_data() -> set[str]:
    uct_path = os.getenv("UCT", default=".")
    not_for_us = set()
    try:
        with open(f"{uct_path}/ignored/not-for-us.txt", mode="r", encoding="utf-8") as f:
            for line in f:
                if "#" in line:
                    not_for_us.add(line.strip().split(" ")[0])
                else:  # Multiple CVEs per line
                    not_for_us.update(line.strip().split(" "))
    except OSError as err:
        print("Error while reading not-for-us.txt, proceeding anyway...", err)

    return not_for_us


def get_kev_data() -> dict[str, str | list[dict[str, str | list[str]]]]:
    try:
        response = requests.get(KEV_CATALOG_URL, timeout=30)
        response.raise_for_status()
        return json.loads(response.content)
    except HTTPError as http_err:
        print("Failed to fetch data from the CISA site", http_err)
    except JSONDecodeError as json_err:
        print("Failed to parse data from the CISA site", json_err)
    # TODO handle errors in a more gracious manner
    sys.exit(-1)


def display_status(cve: str, packages: dict[str, dict[str, list[str]]]):
    # TODO improve presentation style
    for package, statuses in packages.items():
        one_time = False
        for suite, status in statuses.items():
            if "upstream" in suite or "devel" in suite:
                continue
            if "needed" in status or "needs-triage" in status or "deferred" in status:
                if not one_time:
                    print("=" * 20, cve, "=" * 20)
                    one_time = True
                print(package, suite, " ".join(entry for entry in status if entry))
        else:
            if one_time:
                print("-" * (42 + len(cve)))


def display_summary(not_found, status_tracker, conclusive_count, pending_fixes):
    # TODO improve presentation style
    print("<!-- Summary -->")
    print(f"Not found: {len(not_found)}")
    if not_found:
        print(",".join(not_found))
    else:
        print("All CVEs are present in some capacity within UCT")

    print(f"Total CVEs: {len(status_tracker)}")
    print(
        "Not for us:",
        p := sum(1 for v in status_tracker.values() if v is False),
        f"({(p / len(status_tracker)) * 100:.2f}%)",
    )
    print("===")
    print("Tracked:", q := len(status_tracker) - p)
    print("Completed:", conclusive_count, f"({(conclusive_count / q) * 100:.2f}%)")

    print("Pending:", q - conclusive_count, f"({(1 - (conclusive_count / q)) * 100:.2f}%)")
    if pending_fixes:
        print("\n".join(sorted(set(pending_fixes))))
    print("===")


def create_temporary_csv_file(csv_rows: list[dict[str, str]]) -> str:
    with tempfile.NamedTemporaryFile(mode="w", delete=False, encoding="utf-8") as tmp:
        writer = csv.DictWriter(tmp, fieldnames=csv_rows[0].keys())
        writer.writeheader()
        writer.writerows(csv_rows)
        return tmp.name


def properly_tagged(tags):
    return "*" in tags and "cisa-kev" in tags.get("*")


def is_fips_only(packages_pending: list[tuple[str, str, str]]) -> bool:
    # As per FIPS PM, only fips-updates should be considered for these purposes
    return all(y.startswith("fips/") for x, y, z in packages_pending)


def main(args: Namespace):
    data = get_kev_data()

    # Build a CVE -> details map for KEV
    kev = {}
    for vuln in data["vulnerabilities"]:
        kev[vuln["cveID"]] = vuln

    # Ignored doesn't grab what is in not-for-us.txt
    full_data, embargo, retired, ignored = cve_lib.get_all_cve_list()

    not_for_us = get_not_for_us_data()

    not_for_us.update(ignored)

    *_, full_cve_information = cve_lib.load_table(full_data, embargo, None, retired, ignored, [])

    status_tracker = {}
    priority_tracker = {}
    pending_cves = []
    conclusive_counter = 0

    # CSV preparation
    csv_keys = ["cve", "package", "repository", "status", "ubuntu_priority", "cvss_score", "cvss_priority"]
    csv_rows = []

    not_found = []
    for cve_id in sorted(kev):
        if cve_id in not_for_us:
            status_tracker[cve_id] = False
        elif cve_id in full_cve_information:
            status_tracker[cve_id] = True

            cve_info = full_cve_information[cve_id]
            # Check for CVE level tags
            if not properly_tagged(cve_info["tags"]):
                raise AttributeError(f"{cve_id} is not properly tagged")

            packages_pending = get_pending_packages(cve_info["pkgs"])

            if not packages_pending or is_fips_only(packages_pending):
                conclusive_counter += 1
                if args.verbose:
                    print(f"Work on {cve_id} is concluded, no entries marked as 'needed', 'needs-triage' or 'deferred'")
            else:
                priority_tracker[cve_id] = cve_info["Priority"][0]
                pending_cves.append(cve_id)
                if args.csv:  # Build the rows
                    for package, suite, status in packages_pending:
                        csv_rows.append(
                            dict(
                                zip(
                                    csv_keys,
                                    [
                                        cve_id,
                                        package,
                                        suite,
                                        status,
                                        priority_tracker[cve_id],
                                        cve_info["CVSS"][0]["baseScore"] if cve_info["CVSS"] else "0.0",
                                        cve_info["CVSS"][0]["baseSeverity"] if cve_info["CVSS"] else "TBD",
                                    ],
                                )
                            )
                        )

                if args.verbose:
                    display_status(cve_id, cve_info["pkgs"])
        else:
            not_found.append(cve_id)

    display_summary(not_found, status_tracker, conclusive_counter, pending_cves)

    if args.csv and csv_rows:
        print(f"CSV created in {create_temporary_csv_file(csv_rows)}")

    print("All done!")
    sys.exit(0)


if __name__ == "__main__":
    parser = ArgumentParser()

    parser.add_argument("--csv", help="Outputs to a CSV in /tmp", action="store_true")
    parser.add_argument("-v", "--verbose", help="Verbose CLI output", action="store_true")

    main(parser.parse_args())
