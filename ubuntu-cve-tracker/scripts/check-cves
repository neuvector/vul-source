#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# Scan for new CVEs, and report on stdout.
#
# Author: Martin Pitt <martin.pitt@ubuntu.com>
# Author: Kees Cook <kees@ubuntu.com>
# Author: Jamie Strandboge <jamie@ubuntu.com>
# Author: Marc Deslauriers <marc.deslauriers@ubuntu.com>
# Author: Steve Beattie <sbeattie@ubuntu.com>
# Copyright (C) 2005-2022 Canonical Ltd.
#
# This script is distributed under the terms and conditions of the GNU General
# Public License, Version 2 or later. See http://www.gnu.org/copyleft/gpl.html
# for details.


from datetime import datetime, timezone, date as datetime_date
import typing
import json
import math
import argparse
import os
import os.path
import random
import re
import shutil
import subprocess
import sys
import tempfile
import time
import urllib.request
import xml.sax
import xml.sax.handler
import xml.sax.xmlreader
from html import escape
import progressbar

import cve_lib
import source_map
from uct.cpes import CPEs
from uct.ignored_cache import IgnoredCache
from uct.suggestions import IgnoreSuggestions
from uct.config import read_uct_config

# load settings, if any
uct_config = read_uct_config()

# fmt: off
parser = argparse.ArgumentParser(prog="check_cves", description="check_cves builds UCT with new CVE data")
parser.add_argument('uris', nargs='*', help="URIs to fetch CVEs")
parser.add_argument("-r", "--report", help="Just report CVEs that need checking", action="store_true")
parser.add_argument("-v", "--verbose", help="Report verbose details", action="store_true")
parser.add_argument("-d", "--debug", help="Report debugging information", action="store_true")
parser.add_argument("-k", "--known", help="Only report CVEs already known", action="store_true")
parser.add_argument("-N", "--skip-nfu", help="Skip any CVEs marked as NFU (used with -k)", action="store_true")
parser.add_argument("-R", "--refresh", help="Refresh CVE descriptions", action="store_true")
parser.add_argument("-S", "--score-refresh", help="Refresh CVSS scores values only", action="store_true")
# TODO: implement --refresh choices
# parser.add_argument("-R", "--refresh", choices=["all", "cvss", "description", "public_date", "urls"], help="Refresh CVE data")
parser.add_argument("--untriaged", help="Process untriaged CVEs from output of locate_cves.py", metavar="FILE")
parser.add_argument("--mbox", help="Process untriaged CVEs from mbox file", metavar="FILE")
parser.add_argument("--import-missing-debian", help="Process missing Debian CVEs", action="store_true")
# TODO: deprecate --rhel8oval, upstream data stream has ended
parser.add_argument("--rhel8oval", help="Process untriaged RHEL8 CVEs", metavar="FILE")
parser.add_argument("--cisa-kev", help="Process the specified CISA KEV and update CVE tags accordingly.", metavar="FILE")
parser.add_argument("--cve", help="Check only the listed comma-separated CVEs and ignore others", action="store")
parser.add_argument("-e", "--experimental", help="Enable experimental mode", action="store_true")
parser.add_argument("--mistriaged", help="Process the specified number of possible mistriaged CVEs compared to Debian\nImplies --import-missing-debian", action="store", type=int, default=0)
parser.add_argument("--only-mistriaged", help="Process only possible mistriaged CVEs compared to Debian\nImplies --import-missing-debian", action="store_true")
args = parser.parse_args()
# fmt: on

def process_cisa_kev(cisa_kev):
    with open(cisa_kev) as f:
        data = json.load(f)
    for vuln in data["vulnerabilities"]:
        cve = vuln["cveID"]
        # check it is tagged with the cisa-kev tag
        try:
            cvefile = cve_lib.find_cve(cve)
        except ValueError:
            # this is a CVE we don't know about yet - ignore it for now
            continue
        data = cve_lib.load_cve(cvefile)
        if cve_lib.GLOBAL_TAGS_KEY in data["tags"] and "cisa-kev" in data["tags"][cve_lib.GLOBAL_TAGS_KEY]:
            continue
        cve_lib.add_tag(cvefile, cve_lib.GLOBAL_TAGS_KEY, "cisa-kev")
        cve_lib.add_reference(cvefile, "https://www.cisa.gov/known-exploited-vulnerabilities-catalog")
        # TODO - should we also bump the priority to high and add a reason as
        # being listed in the KEV?
        continue
         # this is a CVE we don't know about yet - ignore it for now


if args.cisa_kev:
    process_cisa_kev(args.cisa_kev)
    sys.exit(0)

experimental = os.getenv('CHECK_CVES_EXPERIMENTAL', False)
breakfix = os.getenv('CHECK_CVES_BREAKFIX', True)

# Pull in package details
source = source_map.load()
allsrcs = set()
for release in list(source.keys()):
    allsrcs.update(set(source[release].keys()))
# remove common words which also happen to be names
# of source packages since our ignore suggestion is
# likely to sometimes contain these
COMMON_WORDS = ['an', 'and', 'context', 'file', 'modules', 'the', 'when']
allsrcs.difference_update(set(COMMON_WORDS))
allsrcs.update(set(cve_lib.package_db.keys()))

BUILT_USING_MAP = None
# build list of known homepages for source packages
HOMEPAGES_MAP = {}
for release in list(source.keys()):
    for src in source[release]:
        try:
            homepage = source[release][src]['homepage']
            HOMEPAGES_MAP.setdefault(src, set())
            HOMEPAGES_MAP[src].add(homepage)
        except KeyError:
            pass


DEST_DIR = "."

# Skip stuff older than 2005
CVE_LIMIT = 2004

MISTRIAGED_HINT = 'Previously triaged as ignored in Ubuntu\n\n'

IGNORE_STRINGS = [
    "** REJECT **", "Internet Explorer", "Microsoft Edge", "Windows 98",
    "Windows 2000", "Windows XP", "Windows Server 2003", "Windows NT",
    "Mercury Board", "ZeroBoard", "AntiVirus", "Microsoft", "SGI IRIX",
    "FreeBSD", "IBM AIX", "SCO", "OS X", "Mac OS", "Apple QuickTime",
    "Cisco", "ActiveX", "Joomla!", "TYPO3", "Linksys", "Netgear",
    "TP-LINK", "Belkin", "Juniper", "Microsoft OneDrive",
    "IBM WebSphere", "Oracle Fusion Middleware", "Foxit Reader",
    "Oracle E-Business Suite", "Oracle PeopleSoft", "Oracle Hyperion",
    "Oracle Database Server", "Oracle Food and Beverage Applications",
    "Oracle Siebel CRM", "Oracle Financial Services Applications",
    "Oracle Construction and Engineering", "Oracle Commerce",
    "Oracle Enterprise Manager", "F5 BIG-IP", "Adobe Acrobat and Reader"
]

IGNORE_URLS = {
    "https://patchstack.com/database/vulnerability/.*/wordpress.*": "WordPress Plugin",
    "https://patchstack.com/database/wordpress/plugin/.*": "WordPress Plugin",
    "https://patchstack.com/database/wordpress/theme/.*": "WordPress Theme",
    "https://www.wordfence.com/threat-intel/vulnerabilities/id/.*?source=cve": "WordPress Plugin",
    "https://wpscan.com/vulnerability/.*": "WordPress Plugin",
    "https://www.zyxel.com/global/en/support/security-advisories/.*": "Zyxel",
    "https://www.manageengine.com/.*": "Zoho ManageEngine",
    "https://www.qnap.com/en/security-advisory/.*": "QNAP",
    "https://cert-portal.siemens.com/productcert/.*": "Siemens",
    "https://csr.msi.com/global/product-security-advisories/.*": "MSI",
}

def merge_list(list1, list2, intersection=None):
    """Write the union of list and list2 into list. If intersection is not
    None, that list will be filled with the intersection of list and list2."""

    for item in list2:
        if item not in list1:
            list1.append(item)
        else:
            if intersection is not None:
                intersection.append(item)


def subtract_list(list1, list2):
    """Remove all elements from list which occur in list2."""

    for item in list2:
        if item in list1:
            list1.remove(item)


def _wrap_desc(desc):
    return cve_lib.wrap_text(desc)

def _spawn_editor(path):
    editor = os.getenv('EDITOR', 'vi')
    subprocess.call([editor, path])

def debug(msg):
    if args.debug:
        print(msg, file=sys.stderr)


def prompt_user(msg):
    '''function for prompting for user input; designed to cope with
    flushing output'''
    if sys.version_info[0] < 3 or (sys.version_info[0] == 3 and sys.version_info[1] < 3):
        print(msg, end='')
        sys.stdout.flush()
    else:
        # print function supports flush= argument
        print(msg, flush=True, end='')



class PercentageFile(object):
    def __init__(self, filename):
        self.name = filename
        self.size = os.stat(filename)[6]
        self.delivered = 0
        self.f = open(filename, encoding='utf-8', errors='replace')
        widgets = [progressbar.Percentage(), ' ',
                   progressbar.Bar(marker='=', left='[', right=']'),
                   ' ', str(self.size), ' ', progressbar.ETA()]
        self.bar = progressbar.ProgressBar(widgets=widgets,
                                           maxval=self.size).start()

    def read(self, size=None):
        if size is None:
            data = self.f.read()
        else:
            data = self.f.read(size)

        self.delivered += len(data)

        if self.size != 0:
            self.bar.update(self.delivered)
            if self.size == self.delivered:
                self.bar.finish()

        return data

    def close(self):
        return self.f.close()


def convert_to_nvd(cves=[], desc=lambda _: ""):
    # convert to nvd format dict (like nvd json)
    nvd = {"CVE_data_type": "CVE",
           "CVE_data_format": "MITRE",
           "CVE_data_version": "4.0",
           "CVE_data_timestamp": datetime.now(timezone.utc).strftime("%Y-%m-%dT%H:%MZ"),
           "CVE_Items": []}

    keys = list(cves.keys())
    keys.sort()
    for cve in keys:
        refs = []
        if cve in cves and 'refs' in cves[cve] and len(cves[cve]['refs']) > 0:
            for r in cves[cve]['refs']:
                refs.append({"name": r,
                             "url": r,
                             "refsource": "MISC"})
        item = {"cve":
                {"data_type": "CVE",
                 "data_format": "MITRE",
                 "data_version": "4.0",
                 "CVE_data_meta": {"ID": cve},
                 "references": {"reference_data": refs},
                 "description": {"description_data": [
                     {"lang": "en",
                      "value": desc(cve) if desc else ""}
                 ]}},
                "configurations": {"CVE_data_version": "4.0",
                                   "nodes": []},
                "publishedDate": cves[cve]['date'].strftime("%Y-%m-%dT%H:%MZ")}
        # add packages as cpes
        if 'pkgs' in cves[cve]:
            item["configurations"]["nodes"].append(
                {"operator": "OR",
                 "cpe_match": []})
            for pkg in cves[cve]['pkgs']:
                item["configurations"]["nodes"][0]["cpe_match"].append(
                    {"vulnerable": True,
                     # assume all are applications and use a wildcard for vendor
                     # so it will be ignored later by
                     # get_ignore_suggestion_from_cpe()
                     "cpe23Uri": "cpe:2.3:a:*:" + pkg + ":*:*:*:*:*:*:*:*"})
        if cve in cves and 'cvss' in cves[cve]:
            try:
                cvssV3 = cve_lib.parse_cvss(cves[cve]['cvss'])
                item["impact"] = cvssV3
            except ValueError:
                pass
        nvd["CVE_Items"].append(item)
    return nvd


def import_debian(handler):
    '''Import Debian CVEs and DSAs missing from the tracker'''
    cves = dict()

    today = datetime_date.today()
    known = set(cve_known_list + cve_ignore_list)

    def ever_existed(pkg):
        for rel in source:
            if pkg in source[rel]:
                return True
        return False

    def mistriaged(cve):
        if cve in CVE_IGNORE_NFU_SET and \
           cve not in CVE_IGNORE_MISTRIAGED_LIST and \
           handler.debian[cve]['state'] == 'FOUND':
            # check that at least one of the assigned packages exist
            # in Ubuntu
            for pkg in handler.debian[cve]['pkgs'].keys():
                # ignore package if debian says is not affected
                if handler.debian[cve]['pkgs'][pkg]['state'] == '<not-affected>':
                    continue
                if ever_existed(pkg):
                    return True
        return False

    # pull in CVEs from data/DSA/list
    dsas = cve_lib.load_debian_dsas(uct_config['secure_testing_path'] + '/data/DSA/list', args.verbose)
    for dsa in dsas:
        for cve in dsas[dsa]['cves']:
            if not cve_lib.CVE_RE.match(cve):
                if args.verbose:
                    print(f"Skipping {cve}, not well-formed?", file=sys.stderr)
                continue

            year = int(re.split('-', cve)[1])
            if year < CVE_LIMIT:
                continue

            # If we already know about the CVE, skip it unless is
            # mistriaged
            if cve in known:
                if mistriaged(cve):
                    # add a note about how this was originally classified
                    dsas[dsa]['desc'] = MISTRIAGED_HINT + dsas[dsa]['desc']
                else:
                    continue

            cves[cve] = dict()
            cves[cve]['subject'] = escape(dsas[dsa]['desc'])
            cves[cve]['date'] = dsas[dsa]['date']

            if args.verbose:
                print(f"Processing {dsa}: {dsas[dsa]['desc']} ({cves[cve]['date']})", file=sys.stderr)

    # Now pull in CVEs from the data/CVE/list
    for cve in handler.debian:
        if args.verbose:
            print(f"[--- Processing {cve} ---]", file=sys.stderr)

        if cve in cves:
            if args.verbose:
                print(f"Skipping {cve}, already found in DSA", file=sys.stderr)
            continue

        if not cve_lib.CVE_RE.match(cve):
            if args.verbose:
                print(f"Skipping {cve}, not well-formed?", file=sys.stderr)
            continue

        year = int(re.split('-', cve)[1])
        if year < CVE_LIMIT:
            if args.verbose:
                print(f"Skipping {cve}, year {year} predates {CVE_LIMIT}", file=sys.stderr)
            continue

        # If we already know about the CVE, skip it unless is mistriaged
        if cve in known:
            if mistriaged(cve):
                # add a note about how this was originally classified
                handler.debian[cve]['desc'] = MISTRIAGED_HINT + handler.debian[cve]['desc']
            else:
                if args.verbose:
                    print(f"Skipping {cve}, already known", file=sys.stderr)
                continue

        if handler.debian[cve]['desc'] or handler.debian[cve]['state'] == 'FOUND':
            cves[cve] = dict()
            cves[cve]['subject'] = escape(handler.debian[cve]['desc'])
            if cves[cve]['subject'] == '':
                cves[cve]['subject'] = '[Unknown description]'

            # just make something up. It'll get adjusted whenever mitre adds it
            date = f"{year}-12-31"
            if year >= today.year:
                date =  f"{today.year}-{today.month}-{today.day}"
            cves[cve]['date'] = datetime.strptime(date, "%Y-%m-%d")

            if args.verbose:
                print(f"Processing {cve}: {handler.debian[cve]['desc']} ({cves[cve]['date']})", file=sys.stderr)

    nvd = convert_to_nvd(cves, lambda cve: cves[cve]['subject'])
    tmp = tempfile.NamedTemporaryFile(mode='w', prefix='debian-import_', suffix='.json', delete=False)
    tmpname = tmp.name
    tmp.file.write(json.dumps(nvd))
    tmp.close()

    return tmpname


class RHEL8OVALHandler(xml.sax.handler.ContentHandler):
    """SAX handler for processing rhel8 OVAL XML."""

    def __init__(self):
        # For per-hit processing
        self._curr_vuln = None
        self._curr_cve = None
        self._curr_pkgs = []
        self._curr_url = []
        self._curr_source = None

        self._curr_chars_collect = False
        self._curr_chars = ""

        self._timestamp = None
        self._cves = dict()

    def startElement(self, name, attrs):
        if name == 'oval:timestamp':
            if args.verbose:
                print("Parsing RHEL8 OVAL schema", file=sys.stderr)
            self._curr_chars_collect = True
            self._curr_chars = ""
        if name == "definition" and attrs['class'] == 'vulnerability':
            self._curr_vuln = attrs['id']
            self._curr_desc = None
            self._curr_cve = None
            self._curr_url = None
        if name == "title":
            self._curr_chars_collect = True
            self._curr_chars = ""
        if name == "reference":
            self._curr_cve = attrs['ref_id']
            if 'ref_url' in attrs:
                self._curr_url = attrs['ref_url']

    def characters(self, content):
        if self._curr_chars_collect:
            self._curr_chars += content

    def endElement(self, name):
        self._curr_chars_collect = False
        if name == 'oval:timestamp':
            self._timestamp = datetime.strptime(self._curr_chars, "%Y-%m-%dT%H:%M:%S")
        if name == "title":
            title = self._curr_chars
            # rhel oval titles are of form "CVE-XXXX-XXXX Name: Description
            # here (priority)" - we want to keep "Name: Description here"
            self._curr_desc = ' '.join(title.split(' ')[1:-1])
        if name == "definition":
            self._cves.setdefault(self._curr_cve, dict())
            self._cves[self._curr_cve].setdefault('desc', self._curr_desc)
            self._cves[self._curr_cve].setdefault('refs', [self._curr_url])
            self._cves[self._curr_cve].setdefault('date', self._timestamp)

    def cves(self):
        return self._cves


def read_rhel8oval_file(f):
    '''Read in rhel8 oval
       This is sneaky because we read in the oval and then output a fake JSON
       file for processing.
    '''
    if not os.path.isfile(f):
        print(f"'{f}' not a file", file=sys.stderr)
        sys.exit(1)

    name = os.path.abspath(f + ".json")
    if os.path.exists(name):
        print(f"'{name}' already exists", file=sys.stderr)
        sys.exit(1)

    parser = xml.sax.make_parser()
    handler = RHEL8OVALHandler()
    parser.setContentHandler(handler)
    parser.parse(f)

    cves = handler.cves()
    nvd = convert_to_nvd(cves, lambda cve: cves[cve]['desc'])
    tmp = tempfile.NamedTemporaryFile(mode='w', prefix='rhel8oval-import_', suffix='.json', delete=False)
    tmpname = tmp.name
    tmp.file.write(json.dumps(nvd))
    tmp.close()

    return tmpname

def read_locate_cves_output(f):
    '''Read in output of UCT/scripts/locate_cves.py
       This is sneaky because we read in the output and then output a fake JSON
       file for processing.
    '''
    if not os.path.isfile(f):
        print(f"'{f}' not a file", file=sys.stderr)
        sys.exit(1)

    name = os.path.abspath(f + ".json")
    if os.path.exists(name):
        print(f"'{name}' already exists", file=sys.stderr)
        sys.exit(1)

    with open(f) as _f:
        lines = _f.readlines()
    cves = dict()
    cve = None
    subject = ""
    for line in lines:
        if line == "\n":  # record delimiter
            if cve is not None:
                cves[cve]['subject'] = subject
            cve = None
            subject = ""
            continue

        if line.startswith("Couldn't find CVE"):
            cve = line.split()[2]
            if not cve_lib.CVE_RE.match(cve):
                print(f"Skipping malformed CVE: '{cve}' from '{f}'", file=sys.stderr)
                cve = None
            elif cve in cves:
                if args.verbose:
                    print(f"Skipping duplicate '{cve}' from '{f}'", file=sys.stderr)
                cve = None
            else:
                if args.verbose:
                    print(f"Adding '{cve}'", file=sys.stderr)
                cves[cve] = dict()
            continue

        if cve is None:
            continue

        if line.startswith("Message date:"):
            try:
                date = " ".join(line.split(": ")[1].strip().split()[0:5])
                cves[cve]['date'] = datetime.strptime(date, "%a, %d %b %Y %H:%M:%S")
            except Exception:
                print(f"Could not process date '{line}', skipping {cve} from '{f}'", file=sys.stderr)
                del cves[cve]
                cve = None
                continue
        if line.startswith("Message subject:") or subject != "":
            s = re.sub(r'Message subject: ', "", line)
            if subject == "":
                subject = s.strip()
            else:
                subject += " " + s.strip()

        # Try to fake up some urls
        rhsa_regex = r'\[RHSA-\d\d\d\d:\d+-\d+\]'
        osssec_regex = r'\[oss-security\]'
        if re.search(r'' + rhsa_regex, subject):
            rhsa = re.sub(r'.*(%s).*' % rhsa_regex, r'\1', subject).strip('[|]')
            url = "https://rhn.redhat.com/errata/%s-%s.html" % (rhsa.split(':')[0], rhsa.split(':')[1].split('-')[0])
            cves[cve].setdefault('refs', [] + [url])
        elif re.search(r'' + osssec_regex, subject) and 'date' in cves[cve]:
            # NOTE: while we can determine the url for the year/month/day, we
            # cannot determine the specific message on that day. This gets us
            # close though, so use it.
            url = "http://www.openwall.com/lists/oss-security/" + cves[cve]['date'].strftime('%Y/%m/%d')
            cves[cve].setdefault('refs', [] + [url])

    nvd = convert_to_nvd(cves, lambda c: f'''ML-Date: {cves[c]['date']}, ML-Subject: {escape(cves[c]['subject'])}''')

    tmp = tempfile.NamedTemporaryFile(mode='w', prefix='locate-cves-import_', suffix='.json', delete=False)
    tmp.file.write(json.dumps(nvd))

    tmp.close()
    shutil.move(tmp.name, name)
    return name


def read_mbox_file(f):
    '''Run an mbox file through UCT/scripts/locate_cves.py
       And process through read_locate_cves_output()
    '''
    if not os.path.isfile(f) and not os.path.isdir(f):
        print(f"'{f}' not a file", file=sys.stderr)
        sys.exit(1)

    child = subprocess.Popen(['./scripts/locate_cves.py', f], stdout=subprocess.PIPE, universal_newlines=True)
    out, _ = child.communicate()

    tmp = tempfile.NamedTemporaryFile(mode='w', prefix='mbox-import_', suffix='.out', delete=False)
    tmpname = tmp.name
    tmp.file.write(out)
    tmp.close()

    json_file = read_locate_cves_output(tmpname)
    os.unlink(tmpname)
    return json_file


def dpkg_compare_versions(v1, op, v2):
    import subprocess
    try:
        sp = subprocess.Popen(['dpkg', '--compare-versions', v1, op, v2], close_fds=True)
    except OSError as e:
        return [127, str(e)]
    sp.communicate()
    if sp.returncode == 0:
        return True
    return False


def get_built_using(pkgs=[]):
    global BUILT_USING_MAP
    if BUILT_USING_MAP is None:
        BUILT_USING_MAP = source_map.load_built_using_collection(
                              source_map.load(data_type='packages'))

    out = ""
    for pkg in pkgs:
        out += source_map.get_built_using(BUILT_USING_MAP, pkg)

    return out


def cvss_source_from_filename(name):
    sources = ['nvd', 'rhel']
    for source in sources:
        if source in name:
            return source
    return 'unknown'


class CVEHandler(xml.sax.handler.ContentHandler):
    """SAX handler for processing mitre's CVE database XML."""

    def __init__(self, ignore=[]):
        # For per-hit processing
        self.curr_cve = None
        self.curr_desc = None
        self.curr_cvss = []
        self.curr_cpes = []
        self.curr_desc_ready = False
        self.curr_refs = []
        self.curr_chars_collect = False
        self.curr_chars = ""
        self.num_ignored = 0
        self.num_added = 0
        self.num_skipped = 0
        self.curr_public = None

        # For long-term (human) processing
        self.cve_ignore = set()
        for cve in ignore:
            self.cve_ignore.add(cve)
        self.cve_seen = set()
        self.cve_list = []
        self.cve_data = dict()
        self.saved_ignore_cache = IgnoredCache()
        self.saved_package = ""
        self.saved_cve = ""
        self.debian = None

        # get ignore suggestion
        self.ignore_suggestion = IgnoreSuggestions()
        self.cpes = CPEs()
        # File-type detection


        # Load debian CVE states, if configured
        if 'secure_testing_path' in uct_config:
            self.debian = cve_lib.load_debian_cves(uct_config['secure_testing_path'] + '/data/CVE/list')

    def updateTimestamp(self):
        # Get UTC time
        timestamp = time.strftime("%Y-%m-%d %H:%M:%S", time.gmtime())

        # Append to timestamp file list
        with open(f'{DEST_DIR}/check-cves.log', 'a') as f:
            f.write(
                f"{timestamp} UTC - "
                f"{self.num_added} added, "
                f"{self.num_ignored} ignored, "
                f"{self.num_skipped} skipped, "
                f"{self.num_added + self.num_ignored} total - "
                f"files: {[os.path.basename(x) for x in args.uris]}\n"
            )

    def printReport(self):
        print('\n============================ Triage summary =============================')
        print(f"\n {self.num_added: 4d} CVEs added")
        print(f" {self.num_ignored: 4d} CVEs ignored")
        print(f" {self.num_skipped: 4d} CVEs skipped")
        print("---------------------------")
        print(f"{self.num_added + self.num_ignored: 5d} total CVEs triaged")
        updates_detected, updates_details = self.detect_updates_to_external_repositories()
        if updates_detected:
            print('\n====================== External updates detected ========================')
            print(updates_details)
            print("\n Please remember to push the above changes if appropriate")

    def detect_updates_to_external_repositories(self):
        external_repositories = [cve_lib.subprojects_dir, cve_lib.embargoed_dir]
        updates_detected = False
        updates_details = ""
        for repository_dir in external_repositories:
            cmd = ['git', '-C', repository_dir, 'status', '--porcelain']
            try:
                process = subprocess.run(
                    cmd,
                    stdout=subprocess.PIPE,
                    stderr=subprocess.PIPE,
                    universal_newlines=True,
                    check=True,
                )
                if process.returncode == 0 and process.stdout:
                    if process.stdout:
                        updates_detected = True
                        updates_details += f"\n {repository_dir} \n {process.stdout}"
            except subprocess.CalledProcessError as exception:
                print(exception)
                updates_detected = False
        return updates_detected, updates_details

    # Some descriptions contain embedded dos line endings, replace
    # them with spaces. If other filtering of descriptions needs
    # to occur, can be added here.
    def filter_desc(self, desc):
        return desc.replace('\r', ' ')

    def parse_json(self, fp):
        nvd = json.load(fp)

        def parse_json_cve(cve):
            template_cve = {"data_type": "CVE",
                            "data_format": "MITRE",
                            "data_version": "4.0"}
            for key in list(template_cve.keys()):
                if key not in cve or cve[key] != template_cve[key]:
                    raise KeyError(f"NVD JSON in '{fp.name}' seems invalid")

            metadata = cve["CVE_data_meta"]
            if not re.match(r'^CVE-\d{4}-\d{4,}$', metadata["ID"]):
                print(f"Ignoring invalid CVE with ID '{metadata['ID']}'")
                return
            self.curr_cve = metadata["ID"]

            # Some MITRE CVE data that were REJECT has no more references field
            # so need to handle it.
            try:
                for ref in cve["references"]["reference_data"]:
                    self.curr_refs += [(ref["refsource"], ref["name"], ref["url"])]
            except Exception:
                pass

            # find an english description
            for desc in cve["description"]["description_data"]:
                if desc["lang"] in ["en", "eng"]:
                    if self.curr_desc is None:
                        self.curr_desc = desc["value"]
                    else:
                        self.curr_desc += " " + desc["value"]
            if self.curr_desc is None:
                self.curr_desc = ""
            else:
                self.curr_desc = self.filter_desc(self.curr_desc)
            self.handle_cve()

        def parse_json_record(record):
            template_nvd = {"CVE_data_type": "CVE",
                            "CVE_data_format": "MITRE",
                            "CVE_data_version": "4.0"}
            # check for expected fields
            for key in list(template_nvd.keys()):
                if key not in record or record[key] != template_nvd[key]:
                    raise KeyError(f"NVD JSON in '{fp.name}' seems invalid - missing key '{key}'")
            for item in record["CVE_Items"]:
                self.curr_cvss = []
                self.curr_cpes = []
                self.curr_refs = []
                self.curr_desc = None
                if "publishedDate" in item:
                    # convert from YYYY-MM-DDTHH:MMZ to YYYY-MM-DD HH:MM:SS UTC
                    self.curr_public = item["publishedDate"].replace("T", " ").replace("Z", ":00 UTC")
                else:
                    self.curr_public = None
                # add cvss if available
                try:
                    cvss = dict()
                    # map filename to source
                    cvss['source'] = cvss_source_from_filename(fp.name)
                    cvss['vector'] = item["impact"]["baseMetricV3"]["cvssV3"]["vectorString"]
                    cvss['baseScore'] = item["impact"]["baseMetricV3"]["cvssV3"]["baseScore"]
                    cvss['baseSeverity'] = item["impact"]["baseMetricV3"]["cvssV3"]["baseSeverity"]
                    self.curr_cvss += [cvss]
                except KeyError:
                    pass
                # add cpes if available
                try:
                    for node in item["configurations"]["nodes"]:
                        # TODO: add support for other operators (AND, OR
                        # combined with 'negate' as an attribute) plus
                        # multi-levels (ie. (AND (OR cpe cpe...)) rather than
                        # just (OR cpe cpe)
                        if node["operator"] == "OR":
                            for cpe in node["cpe_match"]:
                                self.curr_cpes += [cpe["cpe23Uri"]]
                except KeyError:
                    pass
                cve = item["cve"]
                parse_json_cve(cve)

        # support a list of records
        if isinstance(nvd, list):
            for record in nvd:
                try:
                    parse_json_record(record)
                except KeyError:
                    # try just parsing this as a CVE entry since that is what
                    # the mozilla CVE feed uses
                    self.curr_cvss = []
                    self.curr_cpes = []
                    self.curr_refs = []
                    self.curr_desc = None
                    self.curr_public = None
                    parse_json_cve(record)
        else:
            parse_json_record(nvd)


    def startElement(self, name, attrs):
        if name == "item":
            if args.verbose:
                print("Parsing Mitre XML schema", file=sys.stderr)
            self.curr_cve = attrs['name']
            self.curr_refs = []
            self.curr_url = None
            self.curr_desc = None
            self.curr_cvss = []
            self.curr_cpes = []
        if name == "desc":
            self.curr_chars_collect = True
            self.curr_chars = ""
        if name == "ref":
            self.curr_chars_collect = True
            self.curr_chars = ""
            self.curr_url = None
            self.curr_source = None
            if 'url' in attrs:
                self.curr_url = attrs['url']
            if 'source' in attrs:
                self.curr_source = attrs['source']

    def characters(self, content):
        if self.curr_chars_collect:
            self.curr_chars += content

    def endElement(self, name):
        self.curr_chars_collect = False
        # Mitre items
        if name == "desc":
            self.curr_desc = self.filter_desc(self.curr_chars)
            # MITRE XML sometimes contains CPEs within the CVE description so
            # try our best to extract these if they are present
            self.curr_cpes = self.cpes.extract_cpes(self.curr_desc)
        if name == "item":
            self.handle_cve()
        if name == "ref":
            self.curr_refs += [(self.curr_source, self.curr_chars, self.curr_url)]

    def handle_cve(self):
        if not self.curr_cve or not self.curr_desc:
            return
        # Skip CVEs we know about already unless this is a mistriaged CVE
        if self.curr_cve in self.cve_ignore and MISTRIAGED_HINT not in self.curr_desc:
            return

        limit = CVE_LIMIT
        if not args.refresh and not args.score_refresh:
            limit = 2005
        if int(self.curr_cve.split("-")[1]) < limit:
            return

        # Check for ** RESERVED **
        s = '** RESERVED **'
        if self.curr_desc.find(s) >= 0 and self.curr_desc.find("Linux") < 0:
            return

        if self.curr_cve in self.cve_seen:
            print(f"Skipping repeat: {self.curr_cve}", file=sys.stderr)
            return
        self.cve_seen.add(self.curr_cve)

        self.cve_list += [self.curr_cve]
        self.cve_data.setdefault(self.curr_cve, dict())
        self.cve_data[self.curr_cve].setdefault('desc', self.curr_desc)
        self.cve_data[self.curr_cve].setdefault('public', self.curr_public)
        self.cve_data[self.curr_cve].setdefault('refs', [] + self.curr_refs)
        self.cve_data[self.curr_cve].setdefault('cvss', [] + self.curr_cvss)
        self.cve_data[self.curr_cve].setdefault('cpes', [] + self.curr_cpes)

    def cves(self):
        return self.cve_list

    def display_command_file_usage(self, f, line_prefix=''):
        # fmt: off
        f.write(f'{line_prefix}The following commands can be used in this file:\n')
        f.write(f'{line_prefix}\n')
        f.write(f'{line_prefix}* Add a new CVE to the tracker:\n')
        f.write(f'{line_prefix}  <CVE> add <PRIORITY> <PACKAGE> [PACKAGE] ...\n')
        f.write(f'{line_prefix}* Add a new CVE to the tracker and open it in your editor:\n')
        f.write(f'{line_prefix}  <CVE> edit <PRIORITY> <PACKAGE> [PACKAGE] ...\n')
        f.write(f'{line_prefix}* Unembargo a CVE that is now public:\n')
        f.write(f'{line_prefix}  <CVE> unembargo>\n')
        f.write(f'{line_prefix}* Permanently ignore a CVE:\n')
        f.write(f'{line_prefix}  <CVE> ignore <REASON>\n')
        f.write(f'{line_prefix}* Temporarily skip over a CVE:\n')
        f.write(f'{line_prefix}  <CVE> skip\n\n')
        # fmt: on
        f.flush()

    def find_hint_in_external_subprojects(self, software_hints_from_cve_description):
        external_subprojects = {}
        for subproject in cve_lib.external_releases:
            if subproject in source:
                aliases = source_map.get_all_aliases(source, subproject)
                for hint in software_hints_from_cve_description:
                    if hint in COMMON_WORDS:
                        continue

                    if hint in source[subproject]:
                        if 'aliases' in source[subproject][hint]:
                            external_subprojects.setdefault(subproject, set()).add(','.join(source[subproject][hint]['aliases']))
                        else:
                            external_subprojects.setdefault(subproject, set()).add(hint)
                    elif hint in aliases:
                        external_subprojects.setdefault(subproject, set()).add(hint)

        return external_subprojects

    def display_cve(self, cve, file: typing.IO=sys.stdout, line_prefix=None, wrap_desc=False):
        class CVEOutput:
            def __init__(self, file, line_prefix=None):
                self.file = file
                self.line_prefix = line_prefix

            def write(self, buf):
                if not line_prefix:
                    self.file.write(buf)
                else:
                    for line in buf.splitlines(True):
                        self.file.write((line_prefix + line).rstrip() + '\n')

        orig_stdout = sys.stdout
        if file != sys.stdout:
            sys.stdout = CVEOutput(file, line_prefix)

        # Check if this was once an embargoed issue
        if cve in CVE_EMBARGO_LIST:
            print('**!!** no longer embargoed **!!**')
            print('==========================details from embargo entry==========================')
            with open(os.path.join('embargoed', cve)) as f:
                print(f.read().rstrip())
            print('=================================end details==================================')
        # Display CVE information
        if self.cve_data[cve]['public']:
            print(f" Published: {self.cve_data[cve]['public']}")
        for ref in self.cve_data[cve]['refs']:
            print(f' {ref[0]}: {ref[1]}', end='')
            # Do not repeat URL if it matches the contents of the reference
            if ref[2] and ref[1].strip() != ref[2].strip():
                print(f' {ref[2]}', end='')
            print()
        if wrap_desc:
            print(_wrap_desc(self.cve_data[cve]['desc']))
        else:
            print('\n======================== CVE details ==========================')
            print(f' {cve}')
            print(f" {self.cve_data[cve]['desc']}")
        for cvss in self.cve_data[cve]['cvss']:
            print(f" CVSS ({cvss['source']}): {cvss['vector']} [{cvss['baseScore']: .1f}]")

        proposed_ignores = set()
        proposed_ignores.add(self.ignore_suggestion.get_ignore_suggestion(self.cve_data[cve]['desc']))
        for cpe in self.cve_data[cve]['cpes']:
            proposed_ignores.add(self.ignore_suggestion.get_ignore_suggestion_from_cpe(cpe))
        if self.debian and cve in self.debian:
            print('\n======================= Debian details ========================')
            print(f" Debian CVE Tracker: {self.debian[cve]['state']}")
            if len(self.debian[cve]['note']):
                print("\t" + "\n\t".join(self.debian[cve]['note']))
            for pkg in self.debian[cve]['pkgs']:
                info = []
                if self.debian[cve]['pkgs'][pkg]['priority']:
                    info.append(self.debian[cve]['pkgs'][pkg]['priority'])
                if self.debian[cve]['pkgs'][pkg]['bug']:
                    info.append(self.debian[cve]['pkgs'][pkg]['bug'])
                if self.debian[cve]['pkgs'][pkg]['note']:
                    info.append(self.debian[cve]['pkgs'][pkg]['note'])
                print(f"  Debian: {pkg}: {self.debian[cve]['pkgs'][pkg]['state']} ({'; '.join(info)})")
                # Display version and component details for Ubuntu's pkg
                answer = source_map.madison(source, pkg)
                for name in sorted(answer.keys()):
                    for pkg in sorted(answer[name].keys()):
                        print(f'    Ubuntu: {pkg} | {answer[name][pkg]} | {name}')
            # no debian info, display possible commented ignore command when
            # using command file (i.e. wrap_desc is true)
            if (self.debian[cve]['state'] == 'RESERVED' or self.debian[cve]['state'] is None) and wrap_desc:
                for proposed_ignore in proposed_ignores:
                    # ensure we don't add extra newlines in the command file
                    print(f'{cve} ignore "{proposed_ignore}"', end='')
                print('')
        else:
            for proposed_ignore in proposed_ignores:
                # ensure we don't add extra newlines in the command file
                print(f'{cve} ignore "{proposed_ignore}"', end='' if wrap_desc else '\n')
            if wrap_desc:
                print('')

        # use cpe if available otherwise fallback to software hints from description
        if len(self.cve_data[cve]['cpes']) > 0:
            software_hints_from_cve_desc = map(lambda x: x.split(':')[4], self.cve_data[cve]['cpes'])
        else:
            software_hints_from_cve_desc = self.get_software_hints_from_cve_description(self.cve_data[cve]["desc"])
        if software_hints_from_cve_desc:
            software_hints_per_external_releases = self.find_hint_in_external_subprojects(software_hints_from_cve_desc)
            if software_hints_per_external_releases:
                print('\n==================== Subprojects details ======================')
                print(' External subprojects possibly affected: ')
                for affected_subproject in software_hints_per_external_releases:
                    print("    - " + affected_subproject + ": " + " - ".join(
                        software_hints_per_external_releases[affected_subproject]))
        # once again, announce formerly embargoed status
        if cve in CVE_EMBARGO_LIST:
            print('**!!**            no longer embargoed             **!!**')
            print('**!!** ensure this is correct before unembargoing **!!**')

        if file != orig_stdout:
            sys.stdout = orig_stdout
            file.flush()

    def get_cve_suggestions(self, cve):
        action = 'skip'
        reason = ""
        packages = []
        # Skip CVEs that are obviously not about Ubuntu
        for s in IGNORE_STRINGS:
            if re.search('(^| )%s' % re.escape(s), self.cve_data[cve]['desc'], flags=re.MULTILINE) and self.cve_data[cve]['desc'].find("Linux") < 0:
                action = 'ignore'
                reason = s
        # if cve is in embargo list (but now public), default to unembargo action
        if cve in CVE_EMBARGO_LIST:
            action = 'unembargo'
            reason = ""
        else:
            # use cpe if available otherwise fallback to software hints from description
            if len(self.cve_data[cve]['cpes']) > 0:
                words = set(map(lambda x: " ".join(x.split(':')[4]), self.cve_data[cve]['cpes']))
            else:
                words = self.get_software_hints_from_cve_description(self.cve_data[cve]["desc"])
            # Default to Debian state, if available
            if self.debian and cve in self.debian and self.debian[cve]['state']:
                if self.debian[cve]['state'].startswith('NOT-FOR-US:'):
                    action = 'ignore'
                    reason = self.debian[cve]['state'].split(':', 1)[1].lstrip()
                if self.debian[cve]['state'] == 'FOUND':
                    action = 'add'
                    packages = list(self.debian[cve]['pkgs'].keys())
                    if len(self.debian[cve]['pkgs']) == 1:
                        pkg = packages[0]
                        if self.debian[cve]['pkgs'][pkg]['state'] == '<itp>':
                            # software has not been admitted into debian
                            action = 'ignore'
                            reason = f"{pkg}: <itp> (dbug {self.debian[cve]['pkgs'][pkg]['bug']})"
                if self.debian[cve]['state'] == 'REJECTED':
                    action = 'ignore'
                    reason = 'REJECTED'
            # try based on description
            words = self.get_software_hints_from_cve_description(self.cve_data[cve]['desc'])
            if action == 'skip':
                # try and hint if any of the references use a URL that is within
                # a known packages Homepage from HOMEPAGES_MAP or within
                # IGNORE_URLS
                if 'refs' in self.cve_data[cve]:
                    for ref in self.cve_data[cve]['refs']:
                        url = ref[2]
                        for url_re in IGNORE_URLS:
                            if re.search(url_re, url):
                                print(f"Detected URL: {url} matches {url_re}")
                                action = 'ignore'
                                reason = IGNORE_URLS[url_re]
                                break
                        if action == 'ignore':
                            break
                        for srcpkg in HOMEPAGES_MAP:
                            for homepage in HOMEPAGES_MAP[srcpkg]:
                                # TODO: do smarter matching than this
                                if homepage in url:
                                    print(f"Detected {srcpkg} homepage in reference URL: {url}")
                                    action = 'add'
                                    packages.append(srcpkg)
                # try and hint if the detected product name contains any known
                # package names - this list also contains aliases and so we want
                # to transform the aliases back into their known package name
                # otherwise it will likely confuse the human doing CVE triage to
                # suggest a package name that doesn't actually exist
                hints = words & allsrcs
                if len(hints) > 0 and action != "ignore":
                    packages = []
                    for hint in hints:
                        # use preferred name of package instead of the one that matched
                        # that we matched
                        if hint in cve_lib.package_db:
                            hint = cve_lib.package_db[hint]["name"]
                        packages.append(hint)
                    action = 'add'

            # Regardless of Ubuntu software, try and hint if the detected product
            # name contains any external software name
            external_software_hints = self.find_hint_in_external_subprojects(words)
            if external_software_hints:
                action = 'add'
                for software in external_software_hints.values():
                    packages.extend(list(software))

        # remove any duplicates
        uniq = []
        for p in packages:
            if p not in uniq:
                uniq.append(p)
        packages = uniq
        # ensure is always a string of package names
        packages = " ".join(packages)

        return (action, reason, packages)

    def get_software_hints_from_cve_description(self, cve_description):
        desc = self.ignore_suggestion.get_ignore_suggestion(cve_description)
        # split based on brackets and other chars which aren't going to be
        # helpful in matching a package name etc
        words = set(filter(None, re.split("[\\s\\(\\){}\\[\\]!\\?\\\\/]+", desc.lower())))
        return words

    def human_process_cve(self, cve, action='skip', reason='', package=''):
        user_input = ''
        while user_input == "" or user_input[0] not in ['i', 'a', 's', 'q', 'r', 'u']:
            if cve in CVE_EMBARGO_LIST:
                prompt_user(f'\nS]kip for now, U]nembargo, or Q]uit? [{action}] ')
            else:
                prompt_user(f'\nA]dd (or R]epeat), I]gnore forever, S]kip for now, or Q]uit? [{action}] ')
            user_input = sys.stdin.readline().strip().lower()
            if user_input == "":
                user_input = action
            elif cve not in CVE_EMBARGO_LIST and user_input[0] == 'u':
                print(f'\n{cve} does not seem to be an embargoed CVE.')
                user_input = ''  # loop back to the user prompt
            elif cve in CVE_EMBARGO_LIST and user_input[0] in ['a', 'r', 'i']:
                print(f'\nInvalid action for an embargoed CVE ({cve}).')
                user_input = ''  # loop back to the user prompt

        if user_input.startswith('q'):
            self.printReport()
            self.updateTimestamp()
            sys.exit(0)
        elif user_input.startswith('a') or user_input.startswith('r'):
            do_repeat = False
            if user_input.startswith('r'):
                user_input = self.saved_package
                do_repeat = True
            else:
                user_input = ""
                while user_input == "":
                    prompt_user('Package(s) affected? ')
                    if package == "":
                        package = self.saved_package
                    if package != "":
                        prompt_user(f'[{package}] ')
                    user_input = sys.stdin.readline().strip()
                    if user_input == '':
                        user_input = package
            self.saved_package = user_input

            dst = self.add_cve(cve, user_input.split(), None)

            if do_repeat:
                subprocess.call(['./scripts/active_dup', self.saved_cve, cve])
            _spawn_editor(dst)
            self.saved_cve = cve

            print('\n===================== Dependant packages ======================')
            print(f' Detecting packages built using: {user_input}...', end='')
            sys.stdout.flush()
            built_using = ""
            try:
                built_using = get_built_using(user_input)
            except Exception as e:
                print(f"ERROR: {e}", file=sys.stderr)
                pass  # for now just show the error but don't break triage

            if built_using != "":
                print("found:\n")
                print(source_map.get_built_using_header())
                print(built_using)
                print("IMPORTANT: the above packages are candidates for rebuilds when fixes are applied to:")
                print(" %s" % "\n ".join(user_input))
            else:
                print("none detected")

        elif user_input.startswith('i'):
            ignored_reason = ""
            while ignored_reason == "":
                print('Reason to be ignored?')
                prompts = []

                # Show debian reason first, then automatically determined
                # reason, then saved reasons. This makes more sense
                # than sorting the reasons and is more predictable
                choices = [reason, self.ignore_suggestion.get_ignore_suggestion(self.cve_data[cve]['desc'])]
                choices.extend(self.saved_ignore_cache.get())
                for choice in choices:
                    if choice != "" and choice not in prompts:
                        prompts.append(choice)
                for cpe in self.cve_data[cve]['cpes']:
                    proposed_ignore = self.ignore_suggestion.get_ignore_suggestion_from_cpe(cpe)
                    if proposed_ignore not in prompts:
                        prompts.append(proposed_ignore)
                for i in range(0, len(prompts)):
                    print(f"   {chr(97 + i)}) {prompts[i]}")
                prompt_user(' > ')

                ignored_reason_input = sys.stdin.readline().strip()
                # NOTE: user is selecting a choice from prompts OR
                # entering the reason as a string
                if len(ignored_reason_input) == 1 and ignored_reason_input.isalpha():
                    try:
                        # ord('a') == 97
                        ignored_reason = prompts[ord(ignored_reason_input) - 97]
                    except IndexError:
                        print('\nError: invalid reason.\n')
                elif len(ignored_reason_input) < 3:  # Fat fingers protection
                    print('\nError: Reason must be at least 3 characters long!\n')
                else:
                    ignored_reason = ignored_reason_input
            self.saved_ignore_cache.insert(ignored_reason)
            self.ignore_cve(cve, ignored_reason)

        elif user_input.startswith('s'):
            self.skip_cve()
        elif user_input.startswith('u'):
            dst = self.unembargo_cve(cve)
            _spawn_editor(dst)
        print('')

    def process_command_file(self, f, preprocess=False):
        line_num = 0
        cves = []
        for line in f:
            line_num += 1

            orig_line = line
            line = orig_line.strip()
            if not line or line.startswith('#'):
                continue

            # Remove any duplicated whitespace such as "CVE-2017-NNN1  skip"
            line = " ".join(line.split()).strip()

            args = line.split(None, 2)
            try:
                (cve, action) = (args[0].upper(), args[1].lower())
            except IndexError:
                raise ValueError(f'Invalid formatting on line {line_num}:\n{orig_line}')

            if not cve.startswith('CVE-'):
                # The first arg should look like a CVE ID
                raise ValueError(f'Invalid CVE ID formatting ({cve}) on line {line_num}:\n{orig_line}')
            elif cve in cves:
                    raise ValueError(f'Performing multiple operations on the same CVE ({cve}) is not supported (line {line_num}):\n{orig_line}')
            cves.append(cve)

            if action == 'add' or action == 'edit':
                # If the CVE should be added, a package name and priority are
                # required
                try:
                    args = args[2].split()
                    priority = args[0].lower()
                    packages = args[1:]
                except IndexError:
                    raise ValueError(f'Invalid add command on line {line_num}:\n{orig_line}')

                if priority not in cve_lib.priorities and not priority == 'untriaged':
                    raise ValueError(f'Invalid priority on line {line_num}:\n{orig_line}')

                if os.path.exists(f'{DEST_DIR}/active/{cve}'):
                    raise ValueError(f'Updating an existing CVE is not supported (line {line_num}):\n{orig_line}')

                if preprocess:
                    continue

                if priority == 'untriaged':
                    priority = None

                cve_path = self.add_cve(cve, packages, priority)

                if action == 'edit':
                    _spawn_editor(cve_path)
            elif action == 'unembargo':
                if cve not in CVE_EMBARGO_LIST:
                    raise ValueError(f'CVE {cve} is not in the embargo database (line {line_num}):\n{orig_line}')

                if os.path.exists(os.path.join('active', cve)):
                    raise ValueError(f'Cannot unembargo {cve} because it already exists in the active directory (line {line_num}):\n{orig_line}')

                if preprocess:
                    continue

                self.unembargo_cve(cve)
            elif action == 'ignore':
                # If the CVE should be ignored, a reason is required
                try:
                    reason = args[2]
                except IndexError:
                    raise ValueError(f'Invalid ignore command on line {line_num}:\n{orig_line}')

                if preprocess:
                    continue

                self.ignore_cve(cve, reason)
            elif action == 'skip':
                # If the CVE should be skipped, no arguments are allowed
                if len(args) > 2:
                    raise ValueError(f'Invalid skip command on line {line_num}:\n{orig_line}')

                if preprocess:
                    continue

                self.skip_cve()
            else:
                # The second arg must be a known action
                raise ValueError(f'Unknown action ({action}) on line {line_num}:\n{orig_line}')

    def preprocess_cve(self, cve):
        desc = ''

        # Check if this was once an embargoed issue
        if cve in CVE_EMBARGO_LIST:
            desc += '# **!!** no longer embargoed **!!**\n'
            desc += '# ==========================details from embargo entry==========================\n'
            with open(os.path.join('embargoed', cve)) as f:
                desc += '# ' + f.read().rstrip() + '\n'
            desc += '# =================================end details==================================\n'
        # Display CVE information
        if self.cve_data[cve]['public']:
            desc += f'#  Published: {self.cve_data[cve]["public"]}\n'
        for ref in self.cve_data[cve]['refs']:
            desc += f'#  {ref[0]}: {ref[1]}'
            # Do not repeat URL if it matches the contents of the reference
            if ref[2] and ref[1].strip() != ref[2].strip():
                desc += f' {ref[2]}'
            desc += '\n'
        for line in _wrap_desc(self.cve_data[cve]['desc']).split('\n'):
            desc += f'#  {line}\n'
        if self.debian and cve in self.debian:
            desc += f"# Debian CVE Tracker: {self.debian[cve]['state']}\n"
            if len(self.debian[cve]['note']):
                for note in self.debian[cve]['note']:
                    desc += f'# \t{note}\n'
            for pkg in self.debian[cve]['pkgs']:
                info = []
                if self.debian[cve]['pkgs'][pkg]['priority']:
                    info.append('# ' + self.debian[cve]['pkgs'][pkg]['priority'])
                if self.debian[cve]['pkgs'][pkg]['bug']:
                    info.append('# ' + self.debian[cve]['pkgs'][pkg]['bug'])
                if self.debian[cve]['pkgs'][pkg]['note']:
                    info.append('# ' + self.debian[cve]['pkgs'][pkg]['note'])
                desc += "#   Debian: %s: %s (%s)\n" % (pkg, self.debian[cve]['pkgs'][pkg]['state'], "; ".join(info))
                # Display version and component details for Ubuntu's pkg
                answer = source_map.madison(source, pkg)
                for name in sorted(answer.keys()):
                    for pkg in sorted(answer[name].keys()):
                        desc += f'#     Ubuntu: {pkg} | {answer[name][pkg]} | {name}\n'

        action = 'skip'
        data = ""
        # Skip CVEs that are obviously not about Ubuntu
        for s in IGNORE_STRINGS:
            if self.cve_data[cve]['desc'].find(s) >= 0 and self.cve_data[cve]['desc'].find("Linux") < 0:
                action = 'ignore'
                data = s
        # Default to Debian state, if available
        if self.debian and cve in self.debian and self.debian[cve]['state']:
            if self.debian[cve]['state'].startswith('NOT-FOR-US:'):
                action = 'ignore'
                data = self.debian[cve]['state'].split(':', 1)[1].lstrip()
            if self.debian[cve]['state'] == 'FOUND':
                action = 'add'
                data = " ".join(self.debian[cve]['pkgs'])

        print(f'{action} {cve} {data}\n{desc}')

    def add_cve(self, cve, packages, priority=None):
        # remove from not-for-us.txt if adding and ensure we remove any
        # MISTRIAGED_HINT from the description
        if cve in CVE_IGNORE_NFU_SET:
            cmd = ['sed', '-i', f'/^{cve} #.*$/d', './ignored/not-for-us.txt']
            subprocess.call(cmd)
            self.cve_data[cve]['desc'] = self.cve_data[cve]['desc'].replace(MISTRIAGED_HINT, '')

        # Build up list of reference urls
        ref_urls = []
        if self.debian and \
           cve in self.debian and \
           'note' in self.debian[cve]:
            for line in self.debian[cve]['note']:
                tmp = line.lstrip("NOTE: ")
                if tmp.startswith("http"):
                    ref_urls.append(tmp)
        if 'refs' in self.cve_data[cve]:
            for ref in self.cve_data[cve]['refs']:
                url = ""
                if ref[1].strip().startswith("http"):
                    url = ref[1].strip()
                elif ref[2] is not None and ref[2].strip().startswith("http"):
                    url = ref[2].strip()
                else:  # no urls
                    continue

                if '//' not in url:  # invalid url
                    continue

                # ignore certain reference URLs which we don't use
                ignored_urls = ['www.securityfocus.com', 'www.osvdb.org']
                if url.split('//')[1].split('/')[0] in ignored_urls:
                    continue

                if url not in ref_urls:
                    ref_urls.append(url)

        # Build up list of bug urls
        bug_urls = []
        for pkg in packages:
            if self.debian and \
               cve in self.debian and \
               self.debian[cve]['pkgs'] and \
               pkg in self.debian[cve]['pkgs']:
                bug = None
                if self.debian[cve]['pkgs'][pkg]['priority'] and \
                   re.search(r'^bug #[0-9]+$', self.debian[cve]['pkgs'][pkg]['priority']):
                    bug = self.debian[cve]['pkgs'][pkg]['priority'].split('#')[1]
                elif self.debian[cve]['pkgs'][pkg]['bug']:
                    bug = self.debian[cve]['pkgs'][pkg]['bug']
                if bug:
                    url = "http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=" + bug
                    if url not in bug_urls:
                        bug_urls.append(url)


        # Build up command line
        cmd = ['./scripts/active_edit', '-c', cve, '--yes',
               '--public',
               # set date as now
               datetime.now(timezone.utc).strftime("%Y-%m-%d")]
        if breakfix:
            cmd.extend(['-k'])
        for url in ref_urls:
            cmd.extend(['--reference-url', url])
        for url in bug_urls:
            cmd.extend(['--bug-url', url])
        if priority:
            cmd.extend(['--priority', priority])
        if self.cve_data[cve]["desc"] is not None:
            cmd.extend(['--description', self.cve_data[cve]["desc"]])

        # capture debian not-affected states
        not_affected = []

        for pkg in packages:
            # The Debian convention is to specify the fixed version as the state
            # with the bug number as the priority for fixed bugs. Leverage this
            # with active_edit
            fixed_in = ""
            if self.debian and \
               cve in self.debian and \
               self.debian[cve]['pkgs'] and \
               pkg in self.debian[cve]['pkgs'] and \
               self.debian[cve]['pkgs'][pkg]['state']:
                if re.search(r'^[0-9]', self.debian[cve]['pkgs'][pkg]['state']):
                    fixed_version = self.debian[cve]['pkgs'][pkg]['state']
                    fixed_in = f",{fixed_version}"

                    # Now see if we can correlate this to an Ubuntu version
                    answer = source_map.madison(source, pkg)
                    for name in sorted(answer.keys()):
                        rel = name.split('/')[0].split('-')[0]  # don't care about the pocket
                        version = answer[name][pkg]
                        # Try to compare apples to apples. Ie, if one of us has
                        # an epoch and the other doesn't, don't try to be smart
                        if (':' not in version and ':' not in fixed_version) or \
                           (':' in version and ':' in fixed_version):
                            if dpkg_compare_versions(version, 'ge', fixed_version):
                                if rel == cve_lib.devel_release:
                                    rel = 'devel'
                                fixed_in += f",{rel},{version}"
                                break
                elif self.debian[cve]['pkgs'][pkg]['state'].startswith('<not-affected>') and \
                        len(self.debian[cve]['pkgs'][pkg]['priority']) > 0:
                    # capture that debian believes their version is unaffected
                    not_affected.append((pkg, f"debian: {self.debian[cve]['pkgs'][pkg]['priority']}"))
            cmd += ['-p', f"{pkg}{fixed_in}"]

        subprocess.call(cmd)
        for (pkg, reason) in not_affected:
            cmd = ['./scripts/mass-cve-edit', '-p', pkg, '-r', 'upstream', '-s', 'not-affected', '-v', reason, cve]
            subprocess.call(cmd)
        self.num_added += 1
        return f'./active/{cve}'

    def unembargo_cve(self, cve):
        # unembargo a cve now public
        shutil.move(os.path.join('embargoed', cve), 'active/')
        self.num_added += 1
        return f'./active/{cve}'

    def ignore_cve(self, cve, reason):
        # Append to ignore list unless is already in cve_ignore_list and then
        # append to the ignored/ignore-mistriaged.txt
        txtfile = 'ignore-mistriaged.txt' if cve in CVE_IGNORE_NFU_SET else 'not-for-us.txt'
        with open(f'{DEST_DIR}/ignored/{txtfile}', 'a') as f:
            f.write(f'{cve} # {reason}\n')

        self.num_ignored += 1

    def skip_cve(self):
        self.num_skipped += 1


IGNORED_NFU_PATH = 'ignored/not-for-us.txt'
if DEST_DIR != './' and DEST_DIR != '.':
    IGNORED_NFU_PATH = os.path.join(DEST_DIR, IGNORED_NFU_PATH)
# CVE_IGNORE_NFU_SET is a set of all CVEs that we have previously
# chosen to ignore since they don't apply to software in Ubuntu
CVE_IGNORE_NFU_SET = set(cve_lib.parse_CVEs_from_uri(IGNORED_NFU_PATH))

IGNORED_MISTRIAGED_PATH = 'ignored/ignore-mistriaged.txt'
if DEST_DIR != './' and DEST_DIR != '.':
    IGNORED_MISTRIAGED_PATH = os.path.join(DEST_DIR, IGNORED_MISTRIAGED_PATH)
# CVE_IGNORE_MISTRIAGED_LIST is a set of all CVEs that we want to definitely
# ignore when doing mistriaged CVE detection - they should exist in both
# CVEIgnoreNotForUsList and CVEIgnoreMistriagedList
CVE_IGNORE_MISTRIAGED_LIST = set(cve_lib.parse_CVEs_from_uri(IGNORED_MISTRIAGED_PATH))

# cve_ignore_list is a list of all CVEs we know about already.  These will be
# ignored when checking MITRE for new CVEs
cve_ignore_list = list(CVE_IGNORE_NFU_SET)

cve_known_list = []
cve_known_list += [cve for cve in os.listdir(DEST_DIR + "/ignored/") if cve.startswith('CVE-')]
cve_known_list += [cve for cve in os.listdir(DEST_DIR + "/retired/") if cve.startswith('CVE-')]
(CVE_ACTIVE_LIST, CVE_EMBARGO_LIST) = cve_lib.get_cve_list()
cve_known_list += [cve for cve in CVE_ACTIVE_LIST if cve not in CVE_EMBARGO_LIST]

if not args.refresh and not args.mistriaged and not args.score_refresh:
    cve_ignore_list += cve_known_list

if args.known:
    cvelist = cve_ignore_list
    if args.skip_nfu:
        cvelist = cve_known_list
    for cve in sorted(cvelist):
        print(cve)
    sys.exit(0)

parser = xml.sax.make_parser()
handler = CVEHandler(cve_ignore_list)
parser.setContentHandler(handler)

# if has specified to triage only specific CVEs, check these are not
# ignored
SPECIFIC_CVES = None
if args.cve:
    SPECIFIC_CVES = set()
    for cve in args.cve.split(","):
        # ignore empty CVE
        if cve.strip() == "":
            continue
        # error out if is ignored
        if cve in cve_ignore_list:
            print(f"{cve} already exists in UCT - please remove it then retriage.")
            sys.exit(1)
        SPECIFIC_CVES.add(cve)

UNTRIAGED_JSON = ""
if args.untriaged:
    UNTRIAGED_JSON = read_locate_cves_output(args.untriaged)
    args.uris.append(UNTRIAGED_JSON)

if args.mbox:
    UNTRIAGED_JSON = read_mbox_file(args.mbox)
    args.uris.append(UNTRIAGED_JSON)

rhel8oval_import_json = ""
if args.rhel8oval:
    UNTRIAGED_JSON = read_rhel8oval_file(args.rhel8oval)
    args.uris.append(UNTRIAGED_JSON)

debian_import_json = ""
if (args.import_missing_debian or args.mistriaged or args.only_mistriaged) and handler.debian is not None:
    debian_import_json = import_debian(handler)
    args.uris.append(debian_import_json)

if len(args.uris) == 0:
    args.uris.append("https://cve.mitre.org/cve/downloads/allitems.xml")

for uri in args.uris:
    print(f'Loading {uri} ...', file=sys.stderr)
    if '://' in uri:
        readable = urllib.request.urlopen(uri)
    else:
        readable = PercentageFile(uri)
    try:
        if uri.endswith("json"):
            handler.parse_json(readable)
        else:
            parser.parse(readable)
    except xml.sax.SAXParseException as e:
        print(f"\n\nWARNING: {uri} is malformed:\n{e}")
        print("Aborting", file=sys.stderr)
        sys.exit(1)
    print('')

# Leaving our fake json around is icky
if os.path.exists(UNTRIAGED_JSON):
    os.unlink(UNTRIAGED_JSON)
if os.path.exists(debian_import_json):
    os.unlink(debian_import_json)


def refresh_cves(cve_refresh_list, full_refresh=True):
    for cve in sorted(cve_refresh_list):

        # Get new information from the XML
        desc = None
        public = None
        cvsss = []
        try:
            if full_refresh:
                desc = _wrap_desc(handler.cve_data[cve]['desc'].strip())
                public = handler.cve_data[cve]['public']
            cvsss = handler.cve_data[cve]['cvss']
        except Exception:
            if args.verbose:
                print(f'{cve} not listed in XML', file=sys.stderr)

        # Find the on-disk CVE file
        cvefile = ""
        for status in ['active', 'retired', 'ignored']:
            check = f'{DEST_DIR}/{status}/{cve}'
            if os.path.exists(check):
                cvefile = check
                break
        if cvefile == "":
            print(f'local dirs missing {cve}?!', file=sys.stderr)
            continue

        # Load CVE
        try:
            data = cve_lib.load_cve(cvefile)
        except ValueError as e:
            print(e, file=sys.stderr)
            continue

        updated = False

        # Only when running full-refresh is that we update every CVE metadata
        # that needs update, otherwise we only update the CVSS score
        if full_refresh:
            # Set defaults for required fields if no XML value exists
            if 'PublicDate' not in data and not public:
                public = "unknown"

            # Update description if it needs it
            if desc:
                if data['Description'].strip() != desc:
                    cve_lib.update_multiline_field(cvefile, 'Description', desc)
                    updated = True
                    debug(f"updated description for {cvefile}")

            # Update Publication Date if it needs it
            if public:
                if 'PublicDate' not in data or ('PublicDate' in data and data['PublicDate'] != public):
                    cve_lib.update_field(cvefile, 'PublicDate', public)
                    updated = True
                    debug(f"updated pubdate for {cvefile}")

            # Add CVE Reference, if it's missing
            if 'References' in data and re.match(r'^CVE-\d+-\d+$', cve):
                # remove deprecated CVE reference source
                mitre_ref = "https://cve.mitre.org/cgi-bin/cvename.cgi?name=" + cve
                if mitre_ref in data['References']:
                    cve_lib.remove_reference(cvefile, mitre_ref)
                    updated = True
                    debug(f"update removed deprecated MITRE ref for {cvefile}")
                # add upstream CVE reference source
                cve_program_ref = "https://www.cve.org/CVERecord?id=" + cve
                if cve_program_ref not in data['References']:
                    cve_lib.add_reference(cvefile, cve_program_ref)
                    updated = True
                    debug(f"update added CVE Program ref for {cvefile}")

        # Update CVSS if needs it
        for entry in cvsss:
            try:
                updated |= cve_lib.add_cvss(cvefile, entry['source'], entry['vector'])
                debug(f"updated cvss for {cvefile}")
            except KeyError:
                # we might not have a vector, in this case continue
                pass

        if updated:
            print(f"Refreshed {cvefile}", file=sys.stderr)

if args.refresh or args.score_refresh:
    if args.cve and SPECIFIC_CVES is not set():
        cve_refresh_list = SPECIFIC_CVES
    else:
        cve_refresh_list = cve_known_list

    # with OptParse args.refresh and args.score_refresh will each
    # either be True or None. We want full_refresh to be False when
    # args.score_refresh is True. If both are true, then we'll do a full
    # refresh since it's a superset of the score only refresh.
    full_refresh = args.refresh or not args.score_refresh
    refresh_cves(cve_refresh_list, full_refresh=full_refresh)
    sys.exit(0)

new_cves = handler.cves()
total = len(new_cves)
count = 0
fout = sys.stdout
if experimental:
    fout = tempfile.NamedTemporaryFile(prefix='check-cves.', mode='w+')
    handler.display_command_file_usage(fout, '# ')

for cve in new_cves:
    if args.cve and cve not in SPECIFIC_CVES:
        # ignore this cve
        continue
    # if this got marked as mistriaged, probablistically choose it for
    # processing
    if MISTRIAGED_HINT in handler.cve_data[cve]['desc']:
        if not args.only_mistriaged and args.mistriaged == 0:
            # ignore this one
            continue
        else:
            # choose CVEs at random but pick most recent first - if year is
            # now then we want to pick it, if year is 1 year ago we want to
            # pick half as often, if year is 2 years ago we want to pick
            # 1/4 as often etc - so do 1/2^(diff)
            year = int(re.split('-', cve)[1])
            now = datetime.now(timezone.utc).year
            prob = 1.0 / math.pow(2, now - year)
            rand = random.random()
            if rand > prob:
                continue
            # selected!
            args.mistriaged = args.mistriaged - 1
    elif args.only_mistriaged:
        continue

    count += 1

    if args.report:
        print(cve)
        continue

    if not experimental:
        print('\n***********************************************************************')
        print(f" {cve}    ({count}/{total}: {int(count * 100 / total)}%)")
        print(f" https://www.cve.org/CVERecord?id={cve}")
        print('***********************************************************************')
        handler.display_cve(cve, file=fout)
        (action, reason, packages) = handler.get_cve_suggestions(cve)
        if action == 'unembargo':
            action = 'skip'  # safer default for human_process_cve()
        handler.human_process_cve(cve, action, reason, packages)
    else:
        line_prefix = '# '

        fout.write(f'{line_prefix}{cve}\n#\n')
        handler.display_cve(cve, file=fout, line_prefix=line_prefix, wrap_desc=True)

        (action, reason, packages) = handler.get_cve_suggestions(cve)
        suggestion = f'{cve} {action}'
        if reason:
            suggestion += f' {reason}'
        elif action == 'add':
            suggestion += f' untriaged {packages}'
        fout.write(f'{suggestion}\n\n')

if experimental:
    fout.flush()
    while True:
        assert((total == 0 and count == 0) or (total > 0 and count >= 0))
        # no need to spawn editor if no CVEs listed
        if count > 0:
            prompt_user(f'Asking user to handle {count} CVEs...')
            _spawn_editor(fout.name)
        else:
            prompt_user('Not spawning editor as no CVEs to process')
        fout.seek(0)
        try:
            handler.process_command_file(fout, preprocess=True)
            break
        except Exception as e:
            print(f'Error encountered while processing the command file!\n{e}', file=sys.stderr)
            print('Enter "quit" to lose all work or anything else to re-edit and try again: ', end='', file=sys.stderr)
            sys.stderr.flush()
            response = sys.stdin.readline().strip().lower()
            if response == 'quit':
                sys.exit(1)
    fout.seek(0)
    handler.process_command_file(fout)

if not args.report:
    handler.updateTimestamp()
handler.printReport()
