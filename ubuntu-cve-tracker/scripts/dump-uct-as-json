#!/usr/bin/env python3
#  -*- mode: python; python-indent-offset: 4; -*-
#
# This file is part of ubuntu-cve-tracker
#
# Copyright (C) 2024 Canonical Ltd.
# Author: Evan Caville <evan.caville@canonical.com>
#
# This program is free software: you can redistribute it and/or modify it under
# the terms of the GNU General Public License version 3, as published by the
# Free Software Foundation.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranties of MERCHANTABILITY,
# SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License along with
# this program.  If not, see <http://www.gnu.org/licenses/>.

# Dump all CVEs in the UCT database as JSON

import argparse
import cve_lib
import kernel_lib
import json
import sys
from collections import defaultdict
from datalib import ReleaseStorage, UCTCVEStorage, UCTPackageStorage

REVISION = 1


def load():
    """Load cve and package data into memory using datalib"""
    release_storage = ReleaseStorage()
    cve_storage = UCTCVEStorage()
    cve_storage.link_release_storage(release_storage)
    cve_storage.load()

    package_storage = UCTPackageStorage()
    package_storage.link_release_storage(release_storage)
    package_storage.load()

    cve_storage.link_pkg_storage(package_storage)
    return release_storage, cve_storage, package_storage


def get_release_id(release):
    """
    Return the ID of a release.

    Args:
        release (Release): Ubuntu release object

    Returns:
        A str representing the release version.
    """
    release_id = release.canon
    if not release.is_esm and not release.is_subproject:
        release_id = release.series
    return release_id


def reverse_map_kernel_meta_packages(releases):
    """
    Generate a mapping of linux kernel meta and signed packages to their parent
    linux kernel package.

    Args:
        releases (list): ubuntu releases to create mapping for

    Returns:
        A dict mapping linux kernel meta and signed package sources to their
        parent linux kernel package.
    """
    meta_kernel_reverse_map = defaultdict(dict)
    for release in releases:
        release_id = get_release_id(release)

        if not kernel_lib.meta_kernels.table.get(release_id, False):
            continue
        kernel_packages = kernel_lib.meta_kernels.table[release_id]
        for kernel_package in kernel_packages:
            meta = kernel_packages[kernel_package]["meta"]
            signed = kernel_packages[kernel_package]["signed"]
            meta_kernel_reverse_map[release_id][meta] = kernel_package
            if signed:
                meta_kernel_reverse_map[release_id][signed] = kernel_package
    return meta_kernel_reverse_map


def populate_pkg_map(packages, releases):
    """
    Generate a mapping of package source names to their binaries for each
    given release.

    Args:
        packages (dict): map of packages in ubuntu releases to their metadata.
        releases (list): ubuntu releases to create mapping for

    Returns:
        A dict mapping package sources and releases to binary names and
        versions.
    """
    pkg_map = defaultdict(dict)
    for package_name in packages:
        package = packages[package_name]
        for release in releases:
            release_id = get_release_id(release)

            pkg_map[package.name][release_id] = {}
            source_version = package.get_latest_version(release)
            binaries = [
                {"name": binary.name, "version": binary.version.version}
                for binary in package.get_binaries(release, source_version)
            ]
            pkg_map[package.name][release_id]["binaries"] = binaries

            ver = ""
            if source_version is not None:
                ver = source_version.version
            pkg_map[package.name][release_id]["source_version"] = ver

    return pkg_map


def format_cvss(cvss, cve_id):
    """
    Attempt to format CVSS3 from a CVE.

    Args:
        cvss (list): CVSS metadata from potentially mutliple cvss entities

    Returns:
        A tuple containg an int representing the CVSS3 score and a dict
        containing other CVSS3 impact metadata.
    """
    cvss3 = None
    impact = None

    if len(cvss) >= 1:
        for score in cvss:
            if "3." not in score.vector:
                continue

            try:
                impact = cve_lib.parse_cvss(score.vector)
                cvss3 = impact["baseMetricV3"]["cvssV3"]["baseScore"]
            except ValueError as e:
                print(
                    "bad CVSS data %s, skipping: %s" % (score.vector, e),
                    file=sys.stderr,
                )
                continue

            # prefer nvd score if present
            if score.entity == "nvd":
                break

    return (cvss3, impact)


def format_packages(cve, releases):
    """
    Partition and format packages metadata for a particular cve for each
    release and return in valid json format.

    Args:
        cve (UbuntuCVE): CVE to format package and status metadata from.
        releases (list): Releases to perform formatting for.

    Returns:
        A list containing mappings of package source names to their releases
        and CVE statuses.
    """
    status = defaultdict(list)
    for release in releases:
        pocket = "security"

        if release.is_esm and release.series == "trusty":
            pocket = "esm-infra"
        elif release.is_esm or release.is_subproject:
            pocket = release.canon.split("/")[0]

        for entry in cve.get_entries_affecting_release(release):
            status[entry.pkg].append(
                {
                    "release_codename": release.series,
                    "status": entry.status,
                    "description": entry.note,
                    "pocket": pocket,
                }
            )

    packages = [
        {"name": package.name, "statuses": status[package]} for package in status
    ]
    return packages


def format_cve_as_json(cve, releases):
    """
    Format a CVE from UCT as a json object that can easily be consumed
    downstream.

    Args:
        cve (UbuntuCVE): CVE to format as json.
        releases (list): Releases used to filter formatting CVE for.

    Returns:
        A dict representing a CVE and it's metadata.
    """
    packages = format_packages(cve, releases)
    cvss3, impact = format_cvss(cve.cvss, cve.id)

    status = "active"
    if "** REJECT **" in cve.description:
        status = "rejected"

    formatted_cve = {
        "id": cve.id,
        "published": cve.public_date,
        "description": cve.description,
        "notes": cve.notes,
        "priority": cve.priority,
        "cvss": cvss3,
        "references": cve.references,
        "packages": packages,
        "status": status,
    }

    if impact:
        formatted_cve["impact"] = impact

    return formatted_cve


def main():
    parser = argparse.ArgumentParser(
        prog="dump-uct-as-json",
        description="Dump all CVEs in the UCT database as JSON",
    )
    parser.add_argument(
        "--output",
        help="output filename for JSON data, default is '-' for stdout",
        default="-",
    )
    parser.add_argument(
        "-r",
        "--releases",
        dest="releases",
        default=None,
        metavar="REL,REL,...",
        help="comma separated list of releases to download (Default: All)",
    )
    args = parser.parse_args()

    release_storage, cve_storage, package_storage = load()
    releases = []
    cves = set()
    if args.releases is None:
        cves = cve_storage.get_all_cves()
        releases = release_storage.get_all_releases()
    else:
        for rel in args.releases.split(","):
            release = release_storage.get_release(rel)
            releases.append(release)
            cves.update(cve_storage.get_all_rel_cves(release))
        cves = list(cves)

    kernel_meta_pkg_map = reverse_map_kernel_meta_packages(releases)
    pkg_map = populate_pkg_map(package_storage.packages, releases)
    data = {
        "revision": REVISION,
        "results": [],
        "pkg_map": pkg_map,
        "kernel_meta_pkg_map": kernel_meta_pkg_map,
    }

    for cve in cves:
        data["results"].append(format_cve_as_json(cve, releases))

    json_data = json.dumps(data, indent=2)
    fp = open(args.output, "w") if args.output != "-" else sys.stdout
    fp.write(json_data)
    fp.close()


if __name__ == "__main__":
    main()
