#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# suggestions module
#
# Author: Martin Pitt <martin.pitt@ubuntu.com>
# Author: Kees Cook <kees@ubuntu.com>
# Author: Jamie Strandboge <jamie@ubuntu.com>
# Author: Marc Deslauriers <marc.deslauriers@ubuntu.com>
# Author: Steve Beattie <sbeattie@ubuntu.com>
# Copyright (C) 2005-2024 Canonical Ltd.
#
# This script is distributed under the terms and conditions of the GNU General
# Public License, Version 2 or later. See http://www.gnu.org/copyleft/gpl.html
# for details.

import re

class IgnoreSuggestions:

    def get_ignore_suggestion(self, text):
        '''Try to find a reasonable suggestion for the user.'''
        suggestion = ""

        # remove any whitespace
        rev_text = text.strip()
        # strip out the added mailing list stuff (locate_cves.py importing)
        rev_text = re.sub(r'^ML-Date: .* ML-Subject: ', '', rev_text)
        rev_text = re.sub(r'^(|Re: )CVE (r|R)equest: ', '', rev_text)

        first_sentence = re.split(r'\. ', rev_text)[0]

        # hunt for module/component
        nouns = ["library", "templates?", "components?", "modules?", "[Pp]lug-?ins?", "extension", "application", "[Tt]hemes?"]
        products = ["Joomla!", "Drupal", "WordPress", "TYPO3", "Mambo", "Android", "jQuery"]
        match = re.search(r'(?: in t|^T)he (.*) (%s) (?:.* )?for (%s)' % ("|".join(nouns), "|".join(products)),
                          first_sentence)
        preposition = "for"
        if not match:
            # try swapping order of product and noun in which case there is no preposition
            match = re.search(r'(?: in t|^T)he (.*) (%s) (%s) (?:.* )' % ("|".join(products), "|".join(nouns)),
                              first_sentence)
            preposition = ""
        if match:
            module = match.group(1)
            noun = match.group(2)
            product = match.group(3)
            for marker in [" module", " ("]:
                if marker in module:
                    module = module.split(marker)[0]
            return " ".join(filter(lambda x: len(x) > 0, [module, noun, preposition, product]))

        # hunt for a description of a thing written in a language or for creating something else
        match = re.search(r'(.*) is a (?:.*) (written in|for creating) (?:.*)', first_sentence)
        if match:
            return match.group(1)

        # hunt for a product on a platform
        match = re.search(r'.* for (Windows|Linux|Mac OS|iOS|Android|iPhone|iPad|BlackBerry|Symbian)', first_sentence)
        if match:
            return match.group(0)

        # look for common pattern
        match = re.search(r'A vulnerability(?:, which was)? classified as (?:.*),? was found in (.*)', first_sentence)
        if match:
            return match.group(1)

        # drop commas-extensions
        if ',' in first_sentence:
            first_sentence = re.split(r',', first_sentence)[0]
        phrases = re.split(r' [io]n ', first_sentence)

        # default to the last phrase
        suggestion = phrases[-1]
        # move to earlier phrase if suggestion starts with "a"
        if suggestion.startswith('a ') and len(phrases) > 1:
            suggestion = phrases[-2]

        version_preps = r'(\s+(before|through|prior to|versions?|[<>]=?))+\s*'
        version_regex = r'\s+([a-zA-Z\._\-]*[0-9]+[a-zA-Z\._\-]*)+'
        # prefer 'Apple iOS before <version>' or 'Apple Mac OS X through
        # <version' in the last phrase over other suggestions
        if not re.search(r'' + version_preps + version_regex, suggestion):
            # grab the first phrase with something that may be a version number
            for p in phrases:
                if re.search(r'' + version_regex, p):
                    suggestion = p
                    break
                if re.search(r'^[^,]+\s+for\s+', p):
                    suggestion = p
                    break

        # try to find a good suggestion from the phrase (ie suggest 'Linux
        # kernel' from 'the Linux kernel before 2.6.27')
        suggestion = re.split(r'\s+([a-zA-Z\._\-]*[0-9]+[a-zA-Z\._\-]*)+', suggestion)[0]
        # "blah in component for some? Software"
        if re.search(r'^[^,]+\s+for(?: some)?\s+', suggestion):
            suggestion = re.split(r'[^,]+\s+for(?: some)?\s+', suggestion)[1]

        # Chop off action verbs
        cleanup_regexes = [
            # clean up leading "in" or "the"
            r'^\s*([tT]he|[iI]n)\s+',
            # clean up trailing version prepositions like "before" or "through"
            # from version details
            r'' + version_preps + '$',
            # clean up trailing parens
            r'\s+\([^\)]+\)\s*$',
            # action verbs
            r'\s+(has|creates|allows|could|contains)($|\s+.*)',
            # "vulnerbale installations of"
            r'(^|\s+)vulnerable\sinstallations?\sof($|\s+)',
            # This affects all versions of package
            r'^This affects all versions of package\s+',
            # This affects the package
            r'^This affects the package\s+',
        ]

        for regex in cleanup_regexes:
            if re.search(regex, suggestion):
                suggestion = re.sub(regex, '', suggestion)

        # if the phrase is too long, truncate it to max_length, but make
        # sure we don't have a partial word at the end
        max_length = 64
        if len(suggestion) > max_length:
            suggestion = suggestion[:max_length]
            suggestion = re.sub(r'\s+\w+$', '', suggestion)

        return suggestion

    def get_ignore_suggestion_from_cpe(self, cpe):
        # TODO: use the CPE dictionary from
        # https://nvd.nist.gov/products/cpe to do this lookup properly
        parts = cpe.split(':')
        if len(parts) < 5:
            raise ValueError("Invalid CPE: %s" % cpe)
        vendor = parts[3]
        product = parts[4]
        suggestion = product.split("_")
        # include vendor if it is helpful
        if vendor != '*' and vendor != product:
            suggestion = [vendor] + suggestion
        return " ".join(suggestion).title()


