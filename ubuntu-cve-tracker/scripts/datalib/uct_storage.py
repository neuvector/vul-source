#!/usr/bin/python3
# -*- coding: utf-8 -*-
# Module containing classes that represent CVE and Package data
#
# Author: David Fernandez Gonzalez <david.fernandezgonzalez@canonical.com>
# Copyright (C) 2024 Canonical Ltd.
#
# This script is distributed under the terms and conditions of the GNU General
# Public License, Version 2 or later. See http://www.gnu.org/copyleft/gpl.html
# for details.
#
import cve_lib
from collections import defaultdict
import datetime
import glob
import json
import logging
import os
import re

from kernel_lib import KERNEL_FLAVOR_SRCPKG_MAPPING
from .config import PKG_CACHE_DIR, USN_DATABASE, LSN_REPO, THREAD_COUNT
from .storage import PackageStorage, CVEStorage, SNStorage
from .uct_models import (
    CVE, UbuntuCVE,
    SN, USN, LSN,
    UbuntuSourcePackage, UbuntuBinaryPackage, UbuntuCVEPkgEntry,
    UbuntuVersion, Release, CVSS
)

from multiprocessing import Pool


logger = logging.getLogger(__name__)

class ReleaseStorage():
    releases: list
    all_active_releases: list
    active_ubuntu_releases: list
    esm_apps_releases: list
    esm_infra_releases: list
    legacy_apps_releases: list
    legacy_infra_releases: list
    gen_data_releases: list

    def __init__(self) -> None:
        self.releases = {}
        self.all_active_releases = []
        self.active_ubuntu_releases = []
        self.esm_apps_releases = []
        self.esm_infra_releases = []
        self.legacy_apps_releases = []
        self.legacy_infra_releases = []
        self.gen_data_releases = {
            'osv': [],
            'oval': [],
            'vex': [],
            'json-pkg': []
        }

        for release in cve_lib.all_releases:
            rel_obj = Release(release)
            self.releases[str(rel_obj)] = rel_obj

        # Link parents
        for release in self.releases.values():
            if release.parent:
                release.parent = self.get_release(release.parent)

        for release in cve_lib.all_active_releases:
            if release == cve_lib.devel_release or release == 'snap' or 'ros-esm' in release:
                continue

            rel = self.get_release(release)
            self.all_active_releases.append(rel)
            for k, v in cve_lib.get_data_formats(release).items():
                if v:
                    self.gen_data_releases[k].append(rel)
                    for r in rel.get_all_parents():
                        if r not in self.gen_data_releases[k]:
                            self.gen_data_releases[k].append(r)
        for release in cve_lib.active_ubuntu_releases:
            self.active_ubuntu_releases.append(self.get_release(release))
        for release in cve_lib.active_esm_releases:
            rel_obj = self.get_release(release)
            if release == 'trusty/esm' or 'esm-infra/' in release:
                self.esm_infra_releases.append(rel_obj)
                rel_obj.get_oldest_parent().esm_infra_release = rel_obj
            elif 'esm-apps/' in release:
                self.esm_apps_releases.append(rel_obj)
                rel_obj.get_oldest_parent().esm_apps_release = rel_obj
            elif 'esm-infra-legacy' in release:
                self.legacy_infra_releases.append(rel_obj)
                rel_obj.get_oldest_parent().legacy_infra_release = rel_obj
            elif 'esm-apps-legacy' in release:
                self.legacy_apps_releases.append(rel_obj)
                rel_obj.get_oldest_parent().legacy_apps_release = rel_obj

    def get_all_releases(self) -> list:
        return list(self.releases.values())

    def get_release(self, release_name: str) -> Release:
        if release_name == 'devel':
            return self.get_devel_release()

        for release in self.releases.values():
            if release.canon == release_name or \
                release.alias == release_name:
                return release

        return None

    def get_releases(self, releases_names: list) -> list:
        return list(map(lambda release_name: self.get_release(release_name), releases_names))

    def get_product_releases(self, product: str, supported_only: bool = False) -> list:
        """Get all releases that belong to a product"""
        if supported_only:
            releases = list(filter(lambda release: release.product == product, self.all_active_releases))
        else:
            releases = list(filter(lambda release: release.product == product, self.releases.values()))
        return releases

    def get_devel_release(self) -> Release:
        for release in self.releases.values():
            if release.is_devel:
                return release

        return None

class UCTPackageStorage(PackageStorage):
    """
    Storage class for handling UCT packages.
    """
    packages: dict
    latest_date_created: dict
    loaded_releases: set
    release_storage: ReleaseStorage

    def __init__(self) -> None:
        self.loaded_releases = set()
        self.latest_date_created = {}
        self.release_storage = None
        super().__init__()

    def load(self, filter_releases: list = [], multithreading: bool = False) -> None:
        """
        Note that link_release_storage function need to be called
        before.
        """
        self.dirty_cache.increment_last_updated()
        releases = self.release_storage.all_active_releases if not filter_releases else filter_releases
        final_releases = set()

        for release in releases:
            final_releases.add(release)
            while release.parent:
                release = release.parent
                if release not in final_releases:
                    final_releases.add(release)

        logger.debug(f'Loading {len(final_releases)} releases')
        if multithreading:
            with Pool(processes=THREAD_COUNT) as pool:
                package_data = pool.map(self._load_release_from_cache, final_releases)
        else:
            package_data = []
            for release in final_releases:
                package_data.append(self._load_release_from_cache(release))

        for release, release_data, last_date_created in package_data:
            self._init_release(release, release_data, last_date_created)

        self._order_packages()

    def _load_release_from_cache(self, release: Release)  -> dict:
        data = {}
        pkg_cache_filename = []
        if release.canon == 'esm/trusty':
            pkg_cache_filename = 'trusty_esm'
        elif release.product == 'ubuntu':
            pkg_cache_filename = release.series
        else:
            pkg_cache_filename = release.canon.replace('/', '_')

        try:
            with open(os.path.join(os.path.expanduser(PKG_CACHE_DIR), pkg_cache_filename + '-pkg-cache.json')) as f:
                data = json.load(f)
        except FileNotFoundError:
            logger.debug(f'Couldn\'t find package cache for release {release.canon} with filename {pkg_cache_filename}')
            return (release, None, None)

        release_data = {}
        latest_date_created = None
        for src_pkg_name, src_pkg_versions in data.items():
            if src_pkg_name == 'latest_date_created':
                latest_date_created = datetime.datetime.fromtimestamp(src_pkg_versions)
                continue
            source_package = UbuntuSourcePackage(src_pkg_name)

            release_data[src_pkg_name] = source_package
            for src_pkg_version, src_pkg_version_data in src_pkg_versions.items():
                src_pkg_version_obj = UbuntuVersion(src_pkg_version)
                source_package.add_source_version(release, src_pkg_version_obj,
                                                  src_pkg_version_data['component'],
                                                  src_pkg_version_data['pocket'])

                for binary_name, binary_data in src_pkg_version_data['binaries'].items():
                    source_package.add_binary(release, src_pkg_version_obj, UbuntuBinaryPackage(binary_name,
                                                                  UbuntuVersion(binary_data['version']),
                                                                  binary_data['arch'],
                                                                  source_package,
                                                                  binary_data['component']))

            source_package.source_versions = dict(sorted(source_package.source_versions.items()))
            source_package.binaries = dict(sorted(source_package.binaries.items()))
            source_package.source_info = dict(sorted(source_package.source_info.items()))

        return (release, release_data, latest_date_created)

    def _init_release(self, release: Release, release_data: dict, latest_date_created: str) -> None:
        if not release_data: return
        for package_name in release_data:
            if package_name in self.packages:
                self.packages[package_name].expand_versions(release_data[package_name])
            else:
                self.packages[package_name] = release_data[package_name]

        self.latest_date_created[release] = latest_date_created
        self.loaded_releases.add(release)

    def get_package(self, pkg_name: str) -> UbuntuSourcePackage:
        return super().get_package(pkg_name)

    def load_release(self, release: Release) -> None:
        if self.release_storage.get_release(release) in self.loaded_releases: return
        release_obj, data, date = self._load_release_from_cache(release)
        self._init_release(release_obj, data, date)

    def unload_release(self, release: Release) -> None:
        release = self.release_storage.get_release(release)
        if release not in self.loaded_releases: return
        self.loaded_releases.remove(release)

        for package_name, package in self.packages.items():
            original_source_versions = package.source_versions.copy()
            for version in original_source_versions:
                ver_rel = package.get_version_release(version)
                if ver_rel == release: package.remove_version(version)

    def link_release_storage(self, release_storage: ReleaseStorage) -> None:
        self.release_storage = release_storage

class UCTCVEStorage(CVEStorage):
    """
    Storage class for handling UCT CVE packages.
    """
    cves: dict
    package_storage: UCTPackageStorage
    release_storage: ReleaseStorage

    # TODO: add a changed cache so we can cache CVEs and only update when something got loaded
    def __init__(self) -> None:
        self.release_storage = None
        super().__init__()

    def link_release_storage(self, release_storage: ReleaseStorage) -> None:
        self.release_storage = release_storage

    def load(self, cves_filter: list = [], ignored: bool = False, embargoed: bool = False) -> None:
        """
        Note that link_release_storage function need to be called
        before.
        """
        self.dirty_cache.increment_last_updated()
        final_cves = []
        cves_ids = self.get_uct_cve_ids(ignored=ignored, embargoed=embargoed)
        for cve_id in cves_ids:
            if cves_filter and cve_id not in cves_filter: continue
            final_cves.append(cve_id)

        with Pool(processes=THREAD_COUNT) as pool:
            logger.debug(f'Loading {len(final_cves)} CVEs')
            cves = pool.map(self._uct_cve_loader, final_cves)

        for cve, cve_pkg_data in cves:
            if not cve: continue
            self._init_cve(cve, cve_pkg_data)

        self._order_cves()

    def _uct_cve_loader(self, cve_id: str) -> UbuntuCVE:
        """Internal function to load CVE from UCT"""
        data = {}
        try:
            data = cve_lib.load_cve(cve_lib.find_cve(cve_id))
        except:
            logging.warning(f'Could not find {cve_id}')
            return (None, None)

        cvss = []
        for cvss_entry in data['CVSS']:
            if not cvss_entry: continue

            cvss.append(CVSS(
                cvss_entry['source'],
                float(cvss_entry['baseScore']),
                cvss_entry['vector']
            ))

        try:
            cve = UbuntuCVE(data['Candidate'], data['Description'].strip().replace('\n', ' '), data['PublicDate'], cvss,
                            data['Assigned-to'], data['Notes'], data['References'].strip().split('\n'), data['Priority'][0], data['Priority'][1])
        except Exception as ex:
            logger.debug(ex)
            return (None, None)

        return (cve, data['pkgs'])

    def get_uct_cve_ids(self, ignored: bool = False, embargoed: bool = False) -> list:
        """Return all CVE IDs identified from UCT"""

        cve_ids = []
        cve_dirs = [cve_lib.active_dir, cve_lib.retired_dir]
        if ignored:
            cve_dirs.append(cve_lib.ignored_dir)
        if embargoed:
            cve_dirs.append(cve_lib.embargoed_dir)

        for dir in cve_dirs:
            for (_, _, filenames) in os.walk(dir):
                for filename in filenames:
                    if not re.search(CVE.ID_REGEX, filename): continue
                    cve_ids.append(filename)
                break

        return cve_ids

    def load_cve(self, cve_id: str) -> None:
        """Load a CVE into the storage"""
        cve, cve_data = self._uct_cve_loader(cve_id)
        if cve and cve_data:
            self._init_cve(cve, cve_data)

    def get_all_cves(self) -> list:
        """Get all CVEs from the storage"""
        cves = []
        for cve_id in self.cves:
            cves.append(self.get_cve(cve_id))
        return cves

    def get_all_rel_cves(self, release: Release) -> list:
        """Get all CVEs from the storage affecting a release"""
        cves = []
        for cve_id in self.cves:
            cve = self.get_cve(cve_id)
            if cve.is_rel_present(release):
                cves.append(cve)
        return cves

    def populate_cve_entries(self, cve_id: str) -> None:
        cve, cve_pkg_data = self.cves[cve_id]
        cve.pkg_entries = list()
        for package_name, package_entries in cve_pkg_data.items():
            package = self.package_storage.get_package(package_name)
            if not package: continue
            for release, status in package_entries.items():
                release = self.release_storage.get_release(release)
                if not release: continue
                if not package.release_exists(release, include_parents=True): continue
                cve.add_cve_entry(UbuntuCVEPkgEntry(package, cve, status[0], status[1], release))

    def get_cve(self, cve_id: str, with_pkg_links: bool = True) -> UbuntuCVE:
        """
        Get a CVE from the storage.
        The package links will be computed when the
        CVE is requested, extracting them from the internal
        UCTPackageStorage.

        If with_pkg_links is disabled, links won't be computed

        Note that link_release_storage and link_package_storage functions
        need to be called before if you want Release and Package objects
        to be linked to the CVE.
        """
        if cve_id not in self.cves: return None

        cve, _ = self.cves[cve_id]
        if not self.dirty_cache.is_dirty(cve_id, [self.package_storage.dirty_cache.last_updated]):
            return cve

        cve.pkg_entries = list()
        if not with_pkg_links: return cve
        self.populate_cve_entries(cve_id)

        self.dirty_cache.make_clean(cve_id)
        return cve

class USNStorage(SNStorage):
    sns: dict
    package_storage: UCTPackageStorage
    cve_storage: UCTCVEStorage
    release_storage: ReleaseStorage

    def __init__(self) -> None:
        self.release_storage = None
        super().__init__()

    def link_release_storage(self, release_storage: ReleaseStorage) -> None:
        self.release_storage = release_storage

    def load(self) -> None:
        self.dirty_cache.increment_last_updated()
        usns_data = self._get_usn_database_data()
        logger.debug(f'Loading {len(usns_data)} USNs')
        for usn_id, usn_data in usns_data.items():
            _, _, cves, lp_bugs, pkgs = self.process_usn_data((usn_id, usn_data))
            self._init_usn(USN(usn_id, usn_data, set(), dict(), lp_bugs), cves, pkgs)

        self._order_sns()

    def _init_usn(self, sn_object: SN, cves: set, pkgs: dict):
        self.sns[sn_object.id] = (sn_object, cves, pkgs)
        self.dirty_cache.add(sn_object.id)

    def _get_usn_database_data(self) -> dict:
        data = {}
        with open(os.path.expanduser(USN_DATABASE), 'r') as f:
            data.update(json.load(f))
        return data

    def process_usn_data(self, usn_raw: dict) -> tuple:
        pkgs = {}
        lp_bugs = set()
        cves = set()
        usn_id = usn_raw[0]
        usn_data = usn_raw[1]
        # Package - fixed version loading
        for rel, info in usn_data['releases'].items():
            # Get package
            if 'sources' in info:
                for pkg, pkg_info in info['sources'].items():
                    pkgs.setdefault(pkg, [])
                    pocket = None
                    # Best effort, there are too many corner cases
                    # since the format is not always the same for all
                    # USNs
                    if 'allbinaries' in info:
                        for binary_data in info['allbinaries'].values():
                            if 'source' in binary_data:
                                source_name = binary_data["source"]

                                # consider kernel signed and meta packages
                                if source_name.startswith("linux-meta-"):
                                    source_name = source_name.replace(
                                        "linux-meta-", "linux-", 1
                                    )

                                if source_name.startswith("linux-signed-"):
                                    source_name = source_name.replace(
                                        "linux-signed-", "linux-", 1
                                    )

                                if source_name != pkg: continue
                            if 'pocket' not in binary_data: continue
                            if pocket and binary_data['pocket'] != pocket:
                                # Different pocket in binaries, default to parent
                                pocket = None
                                break
                            elif not pocket:
                                pocket = binary_data['pocket']
                    pkgs[pkg].append((pkg_info['version'], pocket, rel))

        # CVE loading
        if 'cves' in usn_data:
            for cve_text in usn_data['cves']:
                if 'launchpad.net' in cve_text:
                    lp_bugs.add(cve_text)
                    continue
                elif re.search(r'CVE-\d{4}-\d{4,7}', cve_text):
                    cves.add(cve_text)

        return usn_id, usn_data, cves, lp_bugs, pkgs

    def get_usns_by_cve(self, cve_id: str) -> list:
        target_usns = []
        for usn_id, usn_data in self.sns.items():
            if cve_id in usn_data[1]:
                target_usns.append(self.get_usn(usn_id))

        return target_usns

    def get_usn(self, usn_id: str) -> USN:
        """
        Note that link_X_storage functions need to be called
        before if you want Package, CVE and Release objects to be linked
        to the USN.
        """
        if usn_id not in self.sns: return None
        usn, cves, pkgs = self.sns[usn_id]
        if not self.dirty_cache.is_dirty(usn_id,
                                         [self.cve_storage.dirty_cache.last_updated,
                                          self.package_storage.dirty_cache.last_updated]):
            return usn

        cve_mapping = set()
        pkg_mapping = dict()
        release_mapping = set()

        for cve_id in cves:
            cve = self.cve_storage.get_cve(cve_id)
            if not cve: continue
            cve_mapping.add(cve)

        for pkg_name in pkgs:
            pkg = self.package_storage.get_package(pkg_name)
            if not pkg: continue
            for version, pocket, release in pkgs[pkg_name]:
                release = self.release_storage.get_release(release)
                if not release: continue
                if not pkg.release_exists(release, include_parents=True): continue
                pkg_mapping.setdefault(pkg, [])
                version = UbuntuVersion(version)
                esm_rel = None
                if pocket == 'esm-apps':
                    esm_rel = release.esm_apps_release
                    if esm_rel is None:
                        esm_rel = release.legacy_apps_release.parent
                elif pocket == 'esm-infra':
                    esm_rel = release.esm_infra_release
                    if esm_rel is None:
                        esm_rel = release.legacy_infra_release.parent
                elif pocket == 'esm-infra-legacy':
                    esm_rel = release.legacy_infra_release
                elif pocket == 'esm-apps-legacy':
                    esm_rel = release.legacy_apps_release

                if esm_rel is not None:
                    release = esm_rel
                release_mapping.add(release)
                pkg_mapping[pkg].append((version, release))


        usn.cves = cve_mapping
        usn.package_fixed_versions = pkg_mapping
        usn.releases = list(sorted(release_mapping))
        usn.raw_binaries = dict()

        for release in usn.raw_data['releases']:
            release_obj = self.release_storage.get_release(release)
            if 'allbinaries' in usn.raw_data['releases'][release]:
                if 'sources' not in usn.raw_data['releases'][release]: continue

                # In case sources are not listed with binaries
                sources_info = {}
                for source_name, source_data in usn.raw_data['releases'][release]['sources'].items():
                    sources_info[source_name] = source_data['version']

                for binary, binary_data in usn.raw_data['releases'][release]['allbinaries'].items():
                    if 'source' not in binary_data:
                        for source_name, source_version in sources_info.items():
                            if source_version == binary_data['version']:
                                usn.raw_binaries.setdefault(release_obj, dict())
                                usn.raw_binaries[release_obj].setdefault(source_name, dict())
                                usn.raw_binaries[release_obj][source_name][binary] = binary_data
                                break
                    else:
                        usn.raw_binaries.setdefault(release_obj, dict())
                        usn.raw_binaries[release_obj].setdefault(binary_data['source'], dict())
                        usn.raw_binaries[release_obj][binary_data['source']][binary] = binary_data

        self.dirty_cache.make_clean(usn_id)
        return usn

class LSNStorage(SNStorage):
    sns: dict
    package_storage: UCTPackageStorage
    cve_storage: UCTCVEStorage
    release_storage: ReleaseStorage
    kernel_flavor_srcpkg_mapping: dict

    def __init__(self) -> None:
        self.release_storage = None
        self.kernel_flavor_srcpkg_mapping = KERNEL_FLAVOR_SRCPKG_MAPPING
        super().__init__()

    def link_release_storage(self, release_storage: ReleaseStorage) -> None:
        self.release_storage = release_storage

    def _order_sns(self):
        # LSN id has an LSN- prefix
        self.sns = dict(sorted(self.sns.items(),
                               key=lambda v: int(v[0].split('-')[1]) * 10 ** 8 + int(v[0].split('-')[2])))

    def load(self) -> None:
        # load from LSN JSON files in the security notices repo
        p = os.path.join(
            os.path.expanduser(LSN_REPO),
            'lsn',
            'LSN-' + '[0-9]' * 4 + '-[0-9].json'
        )
        lsn_json_files = glob.glob(p)
        logger.debug(f'Loading {len(lsn_json_files)} LSNs')
        for lsn_json_file in lsn_json_files:
            with open(lsn_json_file, 'r') as f:
                lsn_data = json.load(f)
                cves = set(lsn_data['cves'])
                self._init_sn(LSN(lsn_data), cves, dict())

        self._order_sns()

    def get_lsn(self, lsn_id: str) -> LSN:
        if lsn_id not in self.sns:
            return None
        lsn, cves, _ = self.sns[lsn_id]
        if not self.dirty_cache.is_dirty(lsn_id,
                                         [self.cve_storage.dirty_cache.last_updated,
                                          self.package_storage.dirty_cache.last_updated]):
            return lsn

        cve_mapping = set()
        for cve_id in cves:
            cve = self.cve_storage.get_cve(cve_id)
            if not cve:
                logger.warning(f'{lsn_id}: {cve_id} not found in cve_storage, skipping.')
                continue
            cve_mapping.add(cve)
        lsn.cves = cve_mapping

        # {Release: [ (fixed_release, source_pkg, fixed_version, module_name_regex) ] }
        rel_fixed_info_mapping = defaultdict(list)
        for release_name, rel_data in lsn.releases.items():
            parent_release = self.release_storage.get_release(release_name)
            for flavor in rel_data['sources'].keys():
                source_pkg = self.package_storage.get_package(self.kernel_flavor_srcpkg_mapping[release_name][flavor])

                child_releases = [r for r in source_pkg.get_releases() if r == parent_release or r.get_oldest_parent() == parent_release]
                fixed_version = None
                fixed_release = None
                for rel in child_releases:
                    for cve in lsn.cves:
                        for e in cve.get_entries_affecting_release(rel):
                            if e.pkg == source_pkg and e.status == 'released':
                                cur_fixed_version = e.pkg.get_version(rel, e.note)
                                # handle the cases that some versions cannot
                                # be found e.g. when pkg_cache is out-of-sync.
                                if not cur_fixed_version:
                                    logger.warning(
                                        f'{source_pkg} has an entry marked as '
                                        f'"released" in {cve}, but the version '
                                        f'{e.note} cannot be found!'
                                    )
                                    continue
                                if not fixed_version or cur_fixed_version > fixed_version:
                                    fixed_version = cur_fixed_version
                                    fixed_release = rel
                module_name_regex = rel_data['allbinaries'][flavor]['module']
                if not fixed_version or not fixed_release:
                    # assume all published versions are vulnerable.
                    # leave fixed_version None as-is, Affected() will list
                    # all available versions from the latest release.
                    fixed_release = sorted(child_releases)[-1]
                    logger.warning(f'{lsn.id}: '
                                   f'No fixed versions found in flavor "{flavor}" '
                                   f'(source package: {source_pkg}) in all these '
                                   f'releases {child_releases} from those CVEs '
                                   f'{lsn.cves}. Assuming all versions from '
                                   f'{fixed_release} are affected.')

                if parent_release in rel_fixed_info_mapping.keys():
                    for entry in rel_fixed_info_mapping[parent_release]:
                        # if the incoming triplet
                        # (fixed_release, source_pkg, fixed_version) exists
                        # in the dictionary, group module_name_regex
                        if entry[0:3] == (fixed_release, source_pkg, fixed_version):
                            module_parts = entry[3].split('_')
                            prev_flavour = module_parts[-2]
                            # if it's already grouped, extract the flavours
                            m = re.match(r'\(\?\:(.*?)\)', prev_flavour)
                            if m:
                                prev_flavour = m[1]
                            new_flavour = module_name_regex.split('_')[-2]
                            flavours = set(prev_flavour.split('|'))
                            flavours.add(new_flavour)
                            module_parts[-2] = f"(?:{'|'.join(sorted(flavours))})"
                            result = (entry[0], entry[1], entry[2], "_".join(module_parts))
                            index = rel_fixed_info_mapping[parent_release].index(entry)
                            rel_fixed_info_mapping[parent_release][index] = result
                else:
                    rel_fixed_info_mapping[parent_release].append(
                        (fixed_release, source_pkg, fixed_version, module_name_regex)
                    )

        lsn.releases = sorted(list(rel_fixed_info_mapping.keys()))
        lsn.release_fixed_info = rel_fixed_info_mapping

        self.dirty_cache.make_clean(lsn_id)
        return lsn
