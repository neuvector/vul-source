#!/usr/bin/python3
# -*- coding: utf-8 -*-
# Module containing classes that represent CVE and Package data
#
# Author: David Fernandez Gonzalez <david.fernandezgonzalez@canonical.com>
# Copyright (C) 2024 Canonical Ltd.
#
# This script is distributed under the terms and conditions of the GNU General
# Public License, "Version" 2 or later. See http://www.gnu.org/copyleft/gpl.html
# for details.
#

import re
import datetime
import apt_pkg
apt_pkg.init_system()

class Version:
    version: str

    def __init__(self, version) -> None:
        self.version = version

    def compare_version(self, other: '"Version"') -> int:
        return apt_pkg.version_compare(self.version, other.version)

    def __eq__(self, other: '"Version"') -> bool:
        return self.compare_version(other) == 0

    def __lt__(self, other: '"Version"') -> bool:
        return self.compare_version(other) < 0

    def __le__(self, other: '"Version"') -> bool:
        return self.compare_version(other) <= 0

    def __hash__(self) -> int:
        return hash(self.version)

    def __repr__(self) -> str:
        return self.version

class BinaryPackage:
    name: str
    version: "Version"
    arches: list
    source: "SourcePackage"

    def __init__(self, name: str, version: "Version", arches: list, source: "SourcePackage") -> None:
        self.name = name
        self.version = version
        self.arches = arches
        self.source = source

    def __eq__(self, other: object) -> bool:
        return self.name == other.name and \
            self.version == other.version and \
            self.source == other.source

class SourcePackage:
    name: str
    source_versions: set
    binaries: dict

    def __init__(self, name: str, binaries: dict) -> None:
        self.name = name
        self.binaries = binaries
        self.source_versions = set()

    def __lt__(self, other: object) -> bool:
        return self.name < other.name

    def __eq__(self, other: object) -> bool:
        return self.name == other.name and \
            self.source_versions == other.source_versions and \
            self.binaries == other.binaries

    def is_same_package(self, other: object) -> bool:
        """Is same package but different version"""
        return self.name == other.name

    def get_source_versions(self) -> set:
        return self.source_versions.copy()

    def get_binaries(self, version: "Version") -> list:
        if version not in self.binaries: return []
        return self.binaries[version].copy()

    def add_source_version(self, version: "Version") -> None:
        if version in self.source_versions: return
        self.source_versions.add(version)
        self.binaries[version] = []

    def add_binary(self, src_version: "Version", binary: "BinaryPackage") -> None:
        if src_version not in self.binaries: return
        if binary not in self.binaries[src_version]:
            self.binaries[src_version].append(binary)

    def is_binary_present(self, src_version: "Version", binary: "BinaryPackage") -> bool:
        if src_version not in self.binaries: return False
        return binary in self.binaries[src_version]

class CVSS:
    entity: str
    score: float
    severity: str
    vector: str

    def __init__(self, entity: str, score: float, vector: str) -> None:
        self.entity = entity
        self.score = score
        self.vector = vector
        if self.score == 0.0:
            self.severity = 'None'
        elif self.score < 4.0:
            self.severity = 'Low'
        elif self.score < 7.0:
            self.severity = 'Medium'
        elif self.score < 9.0:
            self.severity = 'High'
        elif self.score <= 10.0:
            self.severity = 'Critical'
        else:
            Exception(f'{self.score} is not a valid CVSS score.')

    def __lt__(self, other):
        return self.score < other.score

    def __repr__(self) -> str:
        return f'[{self.severity}] {self.vector} ({self.score}) -- {self.entity}'

class CVE:
    id: str
    ID_REGEX = r'CVE-\d{4}-\d{4,7}'
    description: str
    public_date: str
    cvss: list
    assigned_to: str
    notes: list
    references: list
    priority: str
    priority_reason: str
    pkg_entries: list

    def __init__(self, id: str, description: str, public_date: str, cvss: list,
                 assigned_to: str, notes: list, references: list,
                 priority: str, priority_reason: str, mitigation: str) -> None:

        if not re.search(self.ID_REGEX, id):
            raise Exception(f'{id} is not a valid CVE ID')

        self.id = id
        self.description = description.strip()
        self.public_date = public_date
        self.cvss = cvss
        self.assigned_to = assigned_to
        self.notes = notes
        self.references = references
        self.priority = priority
        self.priority_reason = priority_reason
        self.mitigation = mitigation
        self.pkg_entries = []

    def __lt__(self, other):
        if not hasattr(other, 'id'): raise Exception("Cannot compare")
        _, our_year, our_number = self.id.split('-')
        _, other_year, other_number = other.id.split('-')

        return int(our_year) < int(other_year) or \
             int(our_year) == int(other_year) and int(our_number) < int(other_number)

    def add_reference(self, ref: str) -> None:
        if ref not in self.references:
            self.references.append(ref)

    def add_note(self, author: str, note: str) -> None:
        self.notes.append((author, note))

    def set_assigned_to(self, assigned_to: str) -> None:
        self.assigned_to = assigned_to

    def is_package_present(self, package: "SourcePackage") -> bool:
        for cve_entry in self.pkg_entries:
            if package == cve_entry.pkg:
                return True

        return False

    def get_package_entry(self, package: "SourcePackage") -> "CVEPkgEntry":
        for cve_entry in self.pkg_entries:
            if package == cve_entry.pkg:
                return cve_entry

        return None

    def add_cve_entry(self, entry: "CVEPkgEntry") -> bool:
        for self_entry in self.pkg_entries:
            if self_entry.pkg == entry.pkg:
                return False
        self.pkg_entries.append(entry)
        return True

    def needs_triage(self) -> bool:
        if self.priority == 'needs-triage': return True
        for cve_entry in self.pkg_entries:
            if cve_entry.status == 'needs-triage':
                return True

        return False

    def __eq__(self, other: object) -> bool:
        return self.id == other.id

    def __repr__(self) -> str:
        return str(vars(self))


class CVEPkgEntry:
    pkg: "SourcePackage"
    cve: CVE
    status: str
    note: str

    STATUSES = ['needs-triage', 'needed', 'not-affected', 'released', 'ignored', 'deferred', 'DNE', 'pending']
    def __init__(self, pkg: "SourcePackage", cve: "CVE", status: str, note: str) -> None:
        self.pkg = pkg
        self.cve = cve

        if status not in self.STATUSES:
            raise Exception(f'{status} is not a valid status')

        self.status = status
        self.note = note

class SN:
    id: str
    cves: set
    packages: set
    package_fixed_versions: dict
    lp_bugs: set
    description: str
    date: datetime.date

    def __init__(self, description: str, date: datetime.date, pkg_fixed_info: dict) -> None:
        self.cves = set()
        self.packages = set()
        self.lp_bugs = set()
        self.description = description
        self.date = date
        self.package_fixed_versions = pkg_fixed_info
