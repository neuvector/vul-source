#!/usr/bin/python3
# -*- coding: utf-8 -*-
# Module containing classes that represent CVE and Package data
#
# Author: David Fernandez Gonzalez <david.fernandezgonzalez@canonical.com>
# Copyright (C) 2024 Canonical Ltd.
#
# This script is distributed under the terms and conditions of the GNU General
# Public License, Version 2 or later. See http://www.gnu.org/copyleft/gpl.html
# for details.
#

from .models import CVE, SN, SourcePackage, BinaryPackage, CVEPkgEntry, Version, CVSS
from cve_lib import get_subproject_details, is_active_release, external_releases, PRODUCT_ESM, PRODUCT_FIPS
from datetime import datetime

class UbuntuVersion(Version):
    def is_esm(self) -> bool:
        return 'esm' in self.version

class Release:
    name: str
    canon: str
    alias: str
    version: "UbuntuVersion"
    codename: str
    product: str
    series: str
    ppas: list
    description: str
    stamp: datetime
    components: list
    is_active: bool
    is_devel: bool
    is_esm: bool
    is_fips: bool
    is_subproject: bool
    requires_oval: bool
    requires_osv: bool
    requires_vex: bool
    parent: "Release"
    esm_infra_release: "Release"
    esm_apps_release: "Release"
    legacy_infra_release: "Release"
    legacy_apps_release: "Release"

    def __init__(self, name: str) -> None:
        canon, product, series, details = get_subproject_details(name)
        self.parent = None
        self.version = None
        self.codename = None
        self.esm_infra_release = None
        self.esm_apps_release = None
        self.legacy_infra_release = None
        self.legacy_apps_release = None
        self.alias = None
        self.is_devel = False
        self.is_subproject = False

        if not canon:
            self.canon = name
            self.name = name
            self.parent = None
            return

        self.canon = canon
        self.name = canon
        self.product = product
        self.series = series
        self.ppas = list()
        self.components = list()
        self.description = ''
        self.stamp = None
        if not details: return
        if 'data_formats' in details:
            if 'oval' in details['data_formats']:
                self.requires_oval = details['data_formats']['oval']
            else:
                self.requires_oval = False
            if 'osv' in details['data_formats']:
                self.requires_osv = details['data_formats']['osv']
            else:
                self.requires_osv = False
            if 'vex' in details['data_formats']:
                self.requires_vex = details['data_formats']['vex']
            else:
                self.requires_vex = False
        if 'name' in details:
            self.name = details['name']
        if 'ppas' in details:
            self.ppas = details['ppas']
        if 'description' in details:
            self.description = details['description']
        if 'components' in details:
            self.components = details['components']
        if 'stamp' in details and details['stamp']:
            self.stamp = datetime.fromtimestamp(details['stamp'])
        if 'parent' in details:
            self.parent = details['parent']
        if 'version' in details:
            self.version = Version(str(details['version']))
        else:
            self.version = Release(self.series).version
        if 'codename' in details:
            self.codename = details['codename']
        if 'codename' in details:
            self.codename = details['codename']
        if 'devel' in details:
            self.is_devel = details['devel']
        if 'alias' in details:
            self.alias = details['alias']
        if self.canon in external_releases:
            self.is_subproject = True
        self.is_active = is_active_release(self.canon if not self.alias else self.alias)
        self.is_esm = self.product in PRODUCT_ESM
        self.is_fips = self.product in PRODUCT_FIPS

    def __eq__(self, value: object) -> bool:
        if not hasattr(value, 'canon'): return False
        return self.canon == value.canon

    def __repr__(self) -> str:
        return self.canon if not self.alias else self.alias

    def __hash__(self):
        return hash(self.canon)

    def __lt__(self, other: "Release") -> bool:
        if not hasattr(other, 'version'): return False
        if self.get_version() == other.get_version():
            if not self.parent:
                # Base release vs other
                return True
            elif not other.parent:
                # Other vs base release
                return False
            elif self.is_esm and other.is_esm:
                # ESM vs ESM - Infra first
                return self == other.parent
            elif self.is_esm and other.parent:
                # ESM vs External
                return True
            elif not self.is_esm and not other.is_esm:
                # External vs external - alphabetical order
                return self.canon < other.canon
            else:
                return False
        else:
            return self.get_version() < other.get_version()

    def get_version(self) -> "UbuntuVersion":
        target_rel_version = self.version

        return target_rel_version

    def is_parent_release(self, release: "Release") -> bool:
        return release in self.get_all_parents()

    def get_direct_parent(self) -> "Release":
        return self.parent

    def get_all_parents(self) -> list:
        release = self
        all_parents = []
        while release.parent:
            release = release.parent
            all_parents.append(release)
        return all_parents

    def get_oldest_parent(self) -> "Release":
        if not self.parent: return None
        return  self.get_all_parents()[-1]


class UbuntuBinaryPackage(BinaryPackage):
    component: str

    def __init__(self, name: str, version: "UbuntuVersion", arches: list, source: "UbuntuSourcePackage", component: str) -> None:
        self.component = component
        super().__init__(name, version, arches, source)

class UbuntuSourcePackage(SourcePackage):
    source_info: dict
    binaries: dict
    source_versions: dict

    def __init__(self, name) -> None:
        self.name = name
        self.source_info = {}
        self.binaries = {}
        self.source_versions = {}

    def get_binaries(self, release: "Release", version: "Version") -> list:
        if release not in self.get_releases(): return []
        if version not in self.binaries[release]: return []
        return self.binaries[release][version].copy()

    def add_binary(self, release: "Release", src_version: "Version", binary: "BinaryPackage") -> None:
        if release not in self.get_releases(): return
        if src_version not in self.binaries[release]: return
        if binary not in self.binaries[release][src_version]:
            self.binaries[release][src_version].append(binary)

    def is_binary_present(self, release: "Release", src_version: "Version", binary: "BinaryPackage") -> bool:
        if release not in self.get_releases(): return
        if src_version not in self.binaries[release]: return False
        return binary in self.binaries[release][src_version]

    def add_source_version(self, release: "Release", version: "UbuntuVersion", component: str, pocket: str):
        self.source_info.setdefault(release, dict())
        self.binaries.setdefault(release, dict())
        self.source_versions.setdefault(release, set())
        if version in self.source_versions[release]: return
        self.source_info[release][version] = {
            'pocket': pocket,
            'component': component
        }

        self.source_versions[release].add(version)
        self.binaries[release][version] = []

    def get_version_component(self, release: "Release", version: "UbuntuVersion") -> str:
        if release not in self.get_releases(): return None
        if version not in self.source_versions[release]: return None
        return self.source_info[release][version]['component']

    def get_version_pocket(self, release: "Release", version: "UbuntuVersion") -> str:
        if release not in self.get_releases(): return None
        if version not in self.source_versions[release]: return None
        return self.source_info[release][version]['pocket']

    def get_release_source_versions(self, release: "Release") -> set:
        if release not in self.source_versions: return set()
        return self.source_versions[release].copy()

    def get_releases(self) -> list:
        return list(sorted(self.source_versions.keys()))

    def get_latest_version(self, release: "Release") -> "UbuntuVersion":
        source_versions = self.get_release_source_versions(release)
        if not source_versions: return None

        latest = None
        for source_version in source_versions:
            if not latest or source_version > latest:
                latest = source_version

        return latest

    def get_earliest_version(self, release: "Release") -> "UbuntuVersion":
        source_versions = self.get_release_source_versions(release)
        if not source_versions: return None

        earliest = None
        for source_version in source_versions:
            if not earliest or source_version < earliest:
                earliest = source_version

        return earliest

    def get_version(self, release: "Release", version_str: str) -> "UbuntuVersion":
        source_versions = self.get_release_source_versions(release)
        if not source_versions: return None

        version = Version(version_str)
        output = None
        for source_version in source_versions:
            if source_version == version:
                output = source_version
                break

        return output

    def expand_versions(self, other: "UbuntuSourcePackage") -> None:
        for release in other.get_releases():
            self.source_info.setdefault(release, dict())
            self.binaries.setdefault(release, dict())
            self.source_versions.setdefault(release, set())
            self.source_versions[release].update(other.source_versions[release])
            self.source_info[release].update(other.source_info[release])
            self.binaries[release].update(other.binaries[release])

    def remove_version(self, release: "Release", version: "UbuntuVersion") -> None:
        if release not in self.source_versions: return
        self.source_versions[release].remove(version)
        del self.source_info[release][version]
        del self.binaries[release][version]

    def release_exists(self, release: "Release", include_parents: bool) -> bool:
        """
        Check if release exists in the package.

        If include_parents, it will also check if any of the release
        parents are listed.
        """
        all_releases = self.get_releases()
        releases_to_check = set([release])
        if include_parents:
            releases_to_check.update(release.get_all_parents())

        for release in releases_to_check:
            if release in all_releases: return True

        return False

    def __repr__(self) -> str:
        return f'{self.name}'

    def __hash__(self) -> int:
        return hash(self.name)

class UbuntuCVEPkgEntry(CVEPkgEntry):
    release: Release

    def __init__(self, pkg: "UbuntuSourcePackage", cve: 'UbuntuCVE', status: str, note: str, release: "Release") -> None:
        self.release = release
        super().__init__(pkg, cve, status, note)

class UbuntuCVE(CVE):
    pkg_entries: list

    def __init__(self, id: str, description: str, public_date: str, cvss: list, assigned_to: str, notes: list, references: list, priority: str, priority_reason: str, mitigation: str) -> None:
        super().__init__(id, description, public_date, cvss, assigned_to, notes, references, priority, priority_reason, mitigation)

    def is_rel_present(self, release: "Release") -> bool:
        for entry in self.pkg_entries:
            if entry.release == release: return True
        return False

    def add_cve_entry(self, entry: "UbuntuCVEPkgEntry") -> bool:
        for self_entry in self.pkg_entries:
            if self_entry.pkg == entry.pkg and \
                self_entry.release == entry.release:
                return False
        self.pkg_entries.append(entry)
        return True

    def get_public_date(self) -> datetime:
        for format in ['%Y-%m-%d %H:%M:%S %Z', '%Y-%m-%d']:
            try:
                return datetime.strptime(self.public_date, format).isoformat(timespec="seconds")
            except ValueError:
                pass
        return None

    def get_releases(self) -> list:
        releases = set()
        for pkg_entry in self.pkg_entries:
            releases.add(pkg_entry.release)

        return list(sorted(releases))

    def get_entries_affecting_release(self, release: "Release") -> list:
        entries = []
        for entry in self.pkg_entries:
            if entry.release == release:
                entries.append(entry)

        return list(sorted(entries, key=lambda entry: entry.pkg.name))

    def __repr__(self) -> str:
        return self.id

    def __hash__(self) -> int:
        return hash(self.id)


class USN(SN):
    package_fixed_versions: dict
    raw_data: dict
    releases: list
    raw_binaries: dict

    def __init__(self, id: str, data: dict, cve_objs: set, package_fixed_versions: dict, lp_bugs: set):
        for item in ['description', 'title', 'timestamp', 'summary', 'action', 'id', 'isummary']:
            if item in data:
                setattr(self, item, data[item])
            else:
                setattr(self, item, None)

        self.id = id
        self.lp_bugs = lp_bugs
        self.cves = cve_objs
        self.package_fixed_versions = package_fixed_versions
        self.raw_data = data

    def is_rel_present(self, release: "Release") -> bool:
        return release in self.releases

    def get_releases(self) -> list:
        return self.releases

    def get_public_date(self) -> datetime:
        return datetime.fromtimestamp(self.timestamp).isoformat(timespec="seconds")

    def get_cves_affecting_release(self, release: "Release") -> list:
        release_cves = []
        for cve in self.cves:
            for pkg_entry in cve.pkg_entries:
                if pkg_entry.release == release and \
                    pkg_entry.status == 'released' and \
                    pkg_entry.pkg in self.package_fixed_versions:
                        release_cves.append(cve)
                        break
                elif 'regresion' in self.title:
                    release_cves.append(cve)

        return list(sorted(release_cves))

    def get_package_info_affecting_release(self, release: "Release") -> list:
        """For a given release, get the list of affected package and the fixed version."""
        pkgs_info = []
        for package in self.package_fixed_versions:
            for version,pkg_rel in self.package_fixed_versions[package]:
                if pkg_rel == release:
                    pkgs_info.append((package, version))

        return list(sorted(pkgs_info))

    def get_raw_binaries(self, release: "Release", package_name: str) -> list:
        """
        This function allows to retrieve the raw binary data from the
        USN for a specific release-package. This should only be used
        if the version doesn't exist in the package storage.
        """
        if release.parent:
            release = release.get_oldest_parent()

        if release not in self.raw_binaries: return list()
        if package_name not in self.raw_binaries[release]: return list()
        return self.raw_binaries[release][package_name].copy()

# TODO(allenpthuang): use datalib
class LSN(SN):
    release_fixed_info: dict
    raw_data: dict
    releases: list

    def __init__(self, data: dict):
        items = ['action', 'cves', 'description', 'id', 'isummary', 'releases',
                 'summary', 'timestamp', 'title']
        for item in items:
            if item in data:
                setattr(self, item, data[item])
            else:
                setattr(self, item, None)

        self.raw_data = data

    def get_fixed_info_affecting_release(self, release: "Release") -> list:
        return self.release_fixed_info.get(release)
