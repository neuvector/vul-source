#!/usr/bin/env python3

# Author: Jamie Strandboge <jamie@ubuntu.com>
#         Diogo Sousa <diogo.sousa@canonical.com>
# Copyright (C) 2005-2019 Canonical Ltd.
#
# This script is distributed under the terms and conditions of the GNU General
# Public License, Version 2 or later. See http://www.gnu.org/copyleft/gpl.html
# for details.

import datetime
import os
import re
import sys
import optparse
from collections import defaultdict

import cve_lib
import time
import json

import source_map

NANOSECONDS_PER_SECOND = 1_000_000_000
SECONDS_PER_YEAR = 31556926
SECONDS_PER_DAY = 86400
POPULARITY_WINDOW = SECONDS_PER_YEAR * 1
NOW = time.time()
TODAY = datetime.date.today()


def which_source(pkg):
    for r in releases:
        if pkg in srcmap[r]:
            try:
                source = srcmap[r][pkg]['source']
                return source
            except KeyError:
                # package was in list for the release but there was no source
                # so most likely the source name is the same as the package name
                return pkg
    # this package wasn't in any source map most likely because it is 
    # packaged only for an EOL'd release such as precise
    if opt.debug:
        print("Not present in active release but being downloaded: ", pkg)
    return 'unknown'

def load_popularity_boost(popfile):
    with open(popfile) as json_data:
        d = json.load(json_data)
        length = len(d["results"][0]["series"][0]["values"])
        for x in range(0, length):
            timestamp = d["results"][0]["series"][0]["values"][x][0] / NANOSECONDS_PER_SECOND
            source = which_source(d["results"][0]["series"][0]["values"][x][1])
            downloads = d["results"][0]["series"][0]["values"][x][2]

            # Only look at universe packages and data in the last 1 years
            if (NOW - timestamp) > POPULARITY_WINDOW:
                continue;

            if source in popularity:
                    popularity[source] += downloads
            else:
                popularity[source] = downloads

    # Average downloads per package per day
    for source in popularity.keys():
        popularity[source] = popularity[source] / (POPULARITY_WINDOW /  SECONDS_PER_DAY)

    if opt.debug:
        print(popularity)

def invert_table(table):
    pkgs_to_cves = defaultdict(list)
    for cve, packages in table.items():
        for package in packages:
            pkgs_to_cves[package].append(cve)

    return dict(pkgs_to_cves)


package_priorities = defaultdict(lambda: defaultdict(int))
package_count = defaultdict(int)
assignees = defaultdict(lambda: defaultdict(list))
pkg_assignees = defaultdict(set)
too_old_packages = defaultdict(lambda: defaultdict(int))
pockets = defaultdict(lambda: defaultdict(int))

embargoed_packages = dict()
popularity = dict()
deferred_packages = set()

points = {'negligible': 0,
          'untriaged': 5,
          'low': 10,
          'medium': 50,
          'high': 100,
          'critical': 200}

incomplete_states = {'needed',
                     'deferred',
                     'pending',
                     'needs-triage',
                     'in-progress'}

ubuntu_priorities = ['untriaged'] + cve_lib.priorities

# medium and higher get a point bump if older than too_old
too_old = 30		# days
too_old_bump = 200  # bump for medium, high is this * 2, critical this * 4, low this / 20

# TODO: replace with argparse
parser = optparse.OptionParser()
parser.add_option("-S", "--skip-devel", help="Show only those CVEs *not* in the current devel release", action="store_true")
parser.add_option("-D", "--only-devel", help="Show only those CVEs in the current devel release", action="store_true")
parser.add_option("-m", "--only-supported", help="Show only those CVEs that are supported", action="store_true")
parser.add_option("-u", "--not-supported", help="Show only those CVEs that aren't supported", action="store_true")
parser.add_option("-t", "--totals", help="Display totals", action="store_true")
parser.add_option("-p", "--packages", help="Report only on the given packages", action="append", type="string")
parser.add_option("-P", "--pkgfamily", help="Perform pkg family renamings (use argument multiple times for 'linux' and/or 'xen')", action="append", default=[])
parser.add_option("-X", "--exclude", help="Ignore specified packages", action="append", type="string")
parser.add_option("-r", "--release", help="Report only for the given releases", action="append", type="string")
parser.add_option("-d", "--debug", help="Report debug information while loading", action="store_true")
parser.add_option("-a", "--show-assigned", help="Show CVE assignments", action="store_true")
parser.add_option("--by-assignee", help="Show CVE assignments organized by assignee", action="store_true")
parser.add_option("--assignee", help="Show CVE assignments for assignee", action="append", type="string")
parser.add_option("--deferred-days", help="Don't show deferred items within NUM days", metavar="NUM", action="store", type="string")
parser.add_option("--skip-pending-overlay", help="Don't show items from the overlay ppa in the pending state", action="store_true")
parser.add_option("--skip-overlays", help="Don't show items from overlay ppas", action="store_true")
parser.add_option("--skip-snaps", help="Don't show snap items", action="store_true")
parser.add_option("--only-pending", help="Only show items in the pending state", action="store_true")
parser.add_option("--skip-pending", help="Don't show items in the pending state", action="store_true")
parser.add_option("-b", "--boost-popularity", help="Take package popularity into account when calculating priority score", action="store_true")
parser.add_option("--pbf", help="Popularity boost file", metavar="FILE")
parser.add_option("-j", "--json", help="Show more verbose output in JSON format", action="store_true")
parser.add_option("--nvd", help="List using the NVD priority instead the Ubuntu Security priority", action="store_true")
(opt, args) = parser.parse_args()

src_map = source_map.load()
releases = cve_lib.all_active_releases

if opt.skip_devel and cve_lib.devel_release != '':
    releases.remove(cve_lib.devel_release)

if opt.only_devel:
    releases = [cve_lib.devel_release]

if opt.release:
    releases = opt.release

if opt.boost_popularity:
    if opt.pbf:
        popularity_file = opt.pbf
    else:
        popularity_file = "package-popularity.json"
    srcmap = source_map.load('packages')
    load_popularity_boost(popularity_file)

active_cves, embargo_cves = cve_lib.get_cve_list()
table, priority, cve_list, name_mapping, cve_data = cve_lib.load_table(active_cves, embargo_cves, opt)

date_pattern = re.compile(r'^20[0-9][0-9]-[01][0-9]-[0-3][0-9]$')
deferred_delta = None
deferred_today = datetime.datetime(TODAY.year, TODAY.month, TODAY.day)

if opt.deferred_days is not None:
    deferred_delta = datetime.timedelta(days=int(opt.deferred_days))

for cve in sorted(active_cves):
    for pkg in sorted(table[cve]):
        if opt.exclude and pkg in opt.exclude:
            continue

        supported = False
        universe = False
        found = False
        overlay = False
        archive = False

        for release in releases:
            if opt.skip_overlays and '/' in release:
                continue

            if opt.skip_snaps and release == 'snap':
                continue

            if release in table[cve][pkg]:
                if table[cve][pkg][release] in incomplete_states:
                    supported_package = cve_lib.is_supported(src_map, name_mapping[pkg][release], release, cve_data[cve])
                    if supported_package:
                        if '/' in release:
                            overlay = True
                        else:
                            archive = True

                    # Exclusion criteria
                    if opt.only_pending and 'pending' not in table[cve][pkg][release]:
                        continue
                    elif opt.skip_pending_overlay and '/' in release and 'pending' in table[cve][pkg][release]:
                        continue
                    elif opt.skip_pending and 'pending' in table[cve][pkg][release]:
                        continue
                    elif deferred_delta is not None and table[cve][pkg][release] == 'deferred':
                        if ("%s_comment" % release) in table[cve][pkg] and date_pattern.search(table[cve][pkg]["%s_comment" % release]):
                            t = table[cve][pkg]["%s_comment" % release].split('-')
                            deferred_date = datetime.datetime(int(t[0]), int(t[1]), int(t[2]))
                            if (deferred_today - deferred_delta) > deferred_date:
                                deferred_packages.add(pkg)
                            else:
                                continue
                        else:
                            continue

                    found = True
                    supported |= supported_package
                    if not supported_package:
                        universe = True

        if not found:
            continue

        if opt.only_supported and not supported:
            continue

        if opt.not_supported and supported:
            continue

        if supported:
            pockets['supported'][pkg] += 1

            if overlay and not archive:
                pockets['only_in_supported_overlay'][pkg] += 1

        if universe:
            pockets['universe'][pkg] += 1

        # lists packages using the NVD baseSeverity priority if it has one
        # if not uses the Ubuntu one instead.
        if opt.nvd:
            if cve_data[cve]['CVSS']:
                ubuntu_priority = cve_data[cve]['CVSS'][0]['baseSeverity'].lower()
            else:
                ubuntu_priority = priority[cve]['default']
        else:
            ubuntu_priority = priority[cve]['default']

        package_count[pkg] += 1

        if pkg in priority[cve]:
            ubuntu_priority = priority[cve][pkg]

        package_priorities[ubuntu_priority][pkg] += 1

        if os.path.islink('embargoed') and os.path.exists(os.path.join("embargoed", cve)):
            embargoed_packages[pkg] = "Undetermined"
            # CRD trumps PublicDate
            for tag in ['PublicDate', 'CRD']:
                crd = cve_data[cve].get(tag, '')
                if crd != '':
                    embargoed_packages[pkg] = crd

        if ubuntu_priority in {'low', 'medium', 'high', 'critical'}:
            try:
                if cve_lib.cve_age(cve, cve_data[cve]['PublicDate'], NOW) > too_old:
                    too_old_packages[pkg][ubuntu_priority] += 1
            except ValueError:
                continue

        if 'Assigned-to' in cve_data[cve] and cve_data[cve]['Assigned-to'] != "":
            if opt.show_assigned:
                pkg_assignees[pkg].add(cve_data[cve]['Assigned-to'])
            if opt.by_assignee:
                assignees[cve_data[cve]['Assigned-to']][pkg].append(cve)


if opt.by_assignee:
    for assignee in sorted(assignees):
        if opt.assignee and assignee not in opt.assignee:
            continue
        sys.stdout.write("%s:\n" % assignee)
        for pkg in sorted(assignees[assignee]):
            sys.stdout.write("  %s:\n" % pkg)
            for c in sorted(assignees[assignee][pkg]):
                sys.stdout.write("    %s\n" % c)
        sys.stdout.write("\n")
    sys.exit(0)

score_map = dict()

for pkg in sorted(package_count):
    if opt.show_assigned and opt.assignee:
        if pkg not in pkg_assignees:
            continue
        found = False
        for user in opt.assignee:
            if user in pkg_assignees[pkg]:
                found = True
                break  # We can stop checking as found will be True for the remainder of the loop
        if not found:
            continue

    score = 0
    for ubuntu_priority in ubuntu_priorities:
        if pkg in package_priorities[ubuntu_priority]:
            score += package_priorities[ubuntu_priority][pkg] * points[ubuntu_priority]

    if pkg in too_old_packages:
        bump = 1
        for ubuntu_priority in ('low', 'medium', 'high', 'critical'):
            if ubuntu_priority not in too_old_packages[pkg]:
                continue
            if ubuntu_priority == 'high':
                bump += too_old_packages[pkg][ubuntu_priority] * too_old_bump * 2
            elif ubuntu_priority == 'critical':
                bump += too_old_packages[pkg][ubuntu_priority] * too_old_bump * 4
            elif ubuntu_priority == 'low':
                bump += too_old_packages[pkg][ubuntu_priority] * too_old_bump / 20
            else:
                bump += too_old_packages[pkg][ubuntu_priority] * too_old_bump
        score += bump

    if opt.boost_popularity:
        boost = 1
        if pkg in popularity and popularity[pkg] > 0:
            boost = popularity[pkg]
        score *= boost

    score_map[pkg] = int(score)

if opt.json:
    pkgs_to_cves = invert_table(table)
    output = []
    for pkg in sorted(package_count):
        if pkg not in score_map:
            continue
        package_entry = {
            "package": pkg,
            "score": score_map[pkg],
            "popularity": popularity.get(pkg, ""),
            "cves": list({"cve": cve, "priority": cve_data[cve]["Priority"]} for cve in pkgs_to_cves[pkg])
        }
        output.append(package_entry)

    print(json.dumps(output, indent=4, sort_keys=True))
else:
    sys.stdout.write("Weight\tPackage Counts\n")
    sys.stdout.write("---------------------------------------------------------------------\n")

    for pkg in sorted(package_count):
        if pkg not in score_map:
            continue

        if opt.totals:
            sys.stdout.write("%s: %s" % (pkg, package_count[pkg]))
        else:
            sys.stdout.write("%s\t%s: %s total" % (str(score_map[pkg]), pkg, str(package_count[pkg])))
            for p in ubuntu_priorities:
                if pkg in package_priorities[p]:
                    sys.stdout.write(", %s %s" % (str(package_priorities[p][pkg]), p))

        extra_info = []
        if pkg in pockets['supported']:
            if pkg in pockets['only_in_supported_overlay']:
                extra_info.append('SUPPORTED-ONLY-OVERLAY')
            else:
                extra_info.append('SUPPORTED')
        if pkg in embargoed_packages:
            extra_info.append('EMBARGOED:%s' % embargoed_packages[pkg])
        if pkg in deferred_packages:
            extra_info.append('CHECKDEFERRED')

        if len(extra_info) > 0:
            sys.stdout.write(" (%s)" % ",".join(extra_info))

        if opt.show_assigned and pkg in pkg_assignees:
            sys.stdout.write(" (%s)" % ",".join(sorted(pkg_assignees[pkg])))

        sys.stdout.write("\n")
