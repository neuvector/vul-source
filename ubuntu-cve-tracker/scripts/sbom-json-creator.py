#!/usr/bin/env python3
# Script to generate a JOSN file to be fed into the SBOM Factory so SBOMs
# for the required releases / subprojects are being distributed.
#
# Author: Nick Galanis <nick.galanis@canonical.com>
# Copyright (C) 2024 Canonical, Ltd.
#
# This script is distributed under the terms and conditions of the GNU General
# Public License, Version 3 or later. See http://www.gnu.org/copyleft/gpl.html
# for details.
#

import argparse
import requests
import json

from datalib import ReleaseStorage, UCTPackageStorage

# boilerplate fiels required in the SBOM intake JSON file
boilerplate_fields = {
    'maintainer': 'Canonical',
    'email': 'test_email@canonical.com',
    'department': 'excellence_engineering',
    'team': 'security_engineering',
    'artifact_type': 'ubuntu',
    'old_artifact_type': 'binary',
    'sharing_method': 'upload',
    'artifact_stored': True,
    'success_email_sent': False
}

def check_link_exists(url):
    """
    Helper function to check if the provided links for LP resolve successfully.
    """
    try:
        response = requests.head(url, allow_redirects=True)
        if response.status_code == 200:
            return True
        else:
            return False
    except requests.RequestException:
        return False

def load_data(release_name):
    """
    Function to load the desired releases from datalib
    """
    release_storage = ReleaseStorage()

    if release_name == "ubuntu":
        releases = release_storage.active_ubuntu_releases
    elif release_name == "subprojects":
        # TODO: add sbom config in subprojects yaml files and replace oval
        all_gen_data_releases = release_storage.gen_data_releases['oval']
        releases = list(set(all_gen_data_releases) - set(release_storage.active_ubuntu_releases))
    elif release_name == "all":
        releases = release_storage.all_active_releases
    else:
        releases = [release_storage.get_release(release_name)]

    package_storage = UCTPackageStorage()
    package_storage.link_release_storage(release_storage)
    package_storage.load(filter_releases=releases)

    return release_storage, package_storage, releases

if __name__ == '__main__':

    parser = argparse.ArgumentParser(prog='SBOM metadata generation')
    parser.add_argument('--releases', help='Comma separated list of PPAs to scan (default is all active Ubuntu releases plus subprojects)', default="all")
    parser.add_argument('-o', '--output-dir', help='Directory to output results to', default='.')
    parser.add_argument('-c', '--check-urls', help='Check if the generated URL of the package actually exists in LP', action="store_true")
    parser.add_argument('-d', '--debug', help='Print debug messages', action="store_true")
    parser.add_argument('--component', type=str, help='Component to generate SBOMs for (main, universe, all)', default="all")
    parser.add_argument('-s', '--source', help='Generate SBOMs for source debs', action="store_true")

    args = parser.parse_args()

    release_storage, package_storage, releases = load_data(args.releases)
    artifact_tests = []
    # Iterate through the specified releases
    for release in releases:
        # iterate through the packages of those releases
        for package_name in package_storage.packages:
            package = package_storage.get_package(package_name)
            # add this package only if it is present in this specific release
            if (release in package.get_releases()):
                # we want to generate an SBOM entry for the latest version of the package in this PPA
                source_version = package.get_latest_version(release)
                if args.debug:
                    print(f'Now processing source package {package_name} in {release} with source version: {source_version}')
                if args.source:
                    filename = f"{package_name}_{source_version}"
                    variant = ""
                    ppa = ""
                    # a release has PPAs assigned only when it is a subproject.
                    if release.is_subproject:
                        # in this case, we want the variant to be the name of this PPA
                        variant = release.ppas[0]['ppa']
                        ppa = variant
                    else:
                        ppa = package.get_version_component(release, source_version)
                        if args.component != "all":
                            if args.component == "main" and ppa != "main":
                                continue
                            if args.component == "universe" and ppa != "universe":
                                continue
                        if ("+esm" in source_version.version) or ("~esm" in source_version.version):
                            if "esm-apps" in release.canon:
                                variant = "universe esm"
                            elif "esm-infra" in release.canon:
                                variant = "main esm"
                            elif "esm-infra-legacy" in release.canon:
                                variant = "main esm"
                        else:
                            variant = ppa

                    # create the package entry metadata
                    package = {
                        'metadata': {
                            'artifact_id': filename,
                            'filename': filename,
                            'artifact_type': 'ubuntu',
                            'artifact_format': 'deb',
                            'variant': variant,
                            'release': release.version.version,
                            'project': f"ubuntu-{release.version}-{variant}-{filename}",
                            'version': source_version.version,
                            'compression_format': '',
                            'sharing_method': 'upload'
                        }
                    }
                    artifact_tests.append(package)

                else: 
                    for binary in package.get_binaries(release, source_version):
                        # skip non-essential binaries
                        if (('-doc' in binary.name) or ('-dev' in binary.name) or ('-dbgsym' in binary.name)):
                            continue
                        for arch in binary.arches:
                            if args.debug:
                                print('    - ', 'binary found: ', binary.name, binary.version, arch)
                            filename = f"{binary.name}_{binary.version}_{arch}.deb"
                            # a release has PPAs assigned only when it is a subproject.
                            if len(release.ppas) > 0:
                                # in this case, we want to split the PPA owner and the actual PPA name
                                ppa = release.ppas[0]['ppa']
                                owner = ppa.split("/")[0]
                                actual_ppa = ppa.split("/")[1]
                            else:
                                # otherwise, the release is a pure Ubuntu one
                                ppa = binary.component
                                owner = "ubuntu"
                                actual_ppa = ppa

                            if 'soss' in release.canon:
                                origin = "soss"
                            else:
                                origin = "ubuntu"
                            # construct the LP link to download and variant of the package
                            if release.is_subproject:
                                url = f"https://launchpad.net/~{owner}/+archive/{origin}/{actual_ppa}/+files/{filename}"
                                variant = ppa
                            else:
                                if args.component != "all":
                                    if args.component == "main" and binary.component != "main":
                                        continue
                                    if args.component == "universe" and binary.component != "universe":
                                        continue

                                if ("+esm" in binary.version.version) or ("~esm" in binary.version.version):
                                    if "esm-apps" in release.canon:
                                        url = f"https://launchpad.net/~ubuntu-esm/+archive/ubuntu/esm-apps-security/+files/{filename}"
                                        variant = "universe esm"
                                    elif "esm-infra" in release.canon:
                                        url = f"https://launchpad.net/~ubuntu-esm/+archive/ubuntu/esm-infra-security/+files/{filename}"
                                        variant = "main esm"
                                    elif "esm-infra-legacy" in release.canon:
                                        url = f"https://launchpad.net/~ubuntu-esm/+archive/ubuntu/esm-infra-legacy-security/+files/{filename}"
                                        variant = "main esm"
                                    else:
                                        print(f"ERROR in package {package_name}, {binary.version} for {release}. Not included in final SBOM.")
                                        continue
                                else:
                                    if arch == 'amd64' or arch == 'i386':
                                        url = f"https://archive.ubuntu.com/ubuntu/pool/{binary.component}/{package_name[0]}/{package_name}/{filename}"
                                        variant = binary.component
                                    else:
                                        url = f"https://ports.ubuntu.com/pool/{binary.component}/{package_name[0]}/{package_name}/{filename}"
                                        variant = binary.component

                            # Extra check to make sure the requested url exists. This is suggested if generating SBOMs for a subproject
                            if args.check_urls and (not check_link_exists(url)):
                                filename = f"{binary.name}_{binary.version}_all.deb"
                                url = f"https://launchpad.net/~{owner}/+archive/ubuntu/{actual_ppa}/+files/{filename}"
                                if not check_link_exists(url):
                                    print(f"ERROR: url for {package_name} not found: {url} in LP. Package cache might be outdated or LP might be unresponsive. Package WILL NOT be downloaded for SBOM analysis.")

                            # create the package entry metadata
                            package = {
                                'obtain_url': url,
                                'metadata': {
                                    'artifact_id': filename,
                                    'filename': filename,
                                    'artifact_type': 'ubuntu',
                                    'artifact_format': 'deb',
                                    'variant': variant,
                                    'release': release.version.version,
                                    'project': f"ubuntu-{release.version}-{ppa}-{filename}",
                                    'version': binary.version.version,
                                    'compression_format': '',
                                    'architecture': arch,
                                    'sharing_method': 'upload'
                                }
                            }
                            artifact_tests.append(package)

        output = {'boilerplate_fields': boilerplate_fields, 'artifact_tests': artifact_tests}
        filename = f"{args.output_dir}/{release.canon.replace('/', '_')}.json"
        with open(filename, 'w') as f:
            json.dump(output, f, indent=2)
        if args.debug:
            print(f'Metadata stored in {filename}')