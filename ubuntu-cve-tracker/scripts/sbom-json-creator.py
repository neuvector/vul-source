#!/usr/bin/env python3
# Script to generate a JOSN file to be fed into the SBOM Factory so SBOMs
# for the required releases / subprojects are being distributed.
#
# Author: Nick Galanis <nick.galanis@canonical.com>
# Copyright (C) 2024 Canonical, Ltd.
#
# This script is distributed under the terms and conditions of the GNU General
# Public License, Version 3 or later. See http://www.gnu.org/copyleft/gpl.html
# for details.
#

import argparse
import requests
import json

from datalib import ReleaseStorage, UCTPackageStorage

# boilerplate fiels required in the SBOM intake JSON file
boilerplate_fields = {
    'maintainer': 'Canonical',
    'email': 'test_email@canonical.com',
    'department': 'excellence_engineering',
    'team': 'security_engineering',
    'artifact_type': 'ubuntu',
    'old_artifact_type': 'binary',
    'sharing_method': 'upload',
    'artifact_stored': True,
    'success_email_sent': False
}

def check_link_exists(url):
    """
    Helper function to check if the provided links for LP resolve successfully.
    """
    try:
        response = requests.head(url, allow_redirects=True)
        if response.status_code == 200:
            return True
        else:
            return False
    except requests.RequestException:
        return False

def load_data(release_name):
    """
    Function to load the desired releases from datalib
    """
    release_storage = ReleaseStorage()

    if release_name == "ubuntu":
        releases = release_storage.active_ubuntu_releases
    elif release_name == "subprojects":
        # TODO: add sbom config in subprojects yaml files and replace oval
        all_gen_data_releases = release_storage.gen_data_releases['oval']
        releases = list(set(all_gen_data_releases) - set(release_storage.active_ubuntu_releases))
    elif release_name == "all":
        releases = release_storage.all_active_releases
    else:
        releases = [release_storage.get_release(release_name)]

    package_storage = UCTPackageStorage()
    package_storage.link_release_storage(release_storage)
    package_storage.load(filter_releases=releases)

    return release_storage, package_storage, releases

if __name__ == '__main__':

    parser = argparse.ArgumentParser(prog='SBOM metadata generation')
    parser.add_argument('--releases', help='Comma separated list of PPAs to scan (default is all active Ubuntu releases plus subprojects)', default="all")
    parser.add_argument('-o', '--output-dir', help='Directory to output results to', default='.')
    parser.add_argument('-c', '--check-urls', help='Check if the generated URL of the package actually exists in LP', action="store_true")
    parser.add_argument('-d', '--debug', help='Print debug messages', action="store_true")

    args = parser.parse_args()

    release_storage, package_storage, releases = load_data(args.releases)
    artifact_tests = []
    # Iterate throught the specified releases
    for release in releases:
        # iterate through the packages of those releases
        for package_name in package_storage.packages:
            package = package_storage.get_package(package_name)
            # add this package only if it is present in this specific release
            if (release in package.get_releases()):
                # we want to generate an SBOM entry for the latest version of the package in this PPA
                source_version = package.get_latest_version(release)
                if args.debug:
                    print(f'Now processing source package {package_name} in {release} with source version: {source_version}')
                for binary in package.get_binaries(release, source_version):
                    # skip non-essential binaries
                    if (('-doc' in binary.name) or ('-dev' in binary.name) or ('-dbgsym' in binary.name)):
                        continue
                    for arch in binary.arches:
                        if args.debug:
                            print('    - ', 'binary found: ', binary.name, binary.version, arch)
                        filename = f"{binary.name}_{binary.version}_{arch}.deb"
                        # a release has PPAs assigned only when it is a subproject.
                        if len(release.ppas) > 0:
                            # in this case, we want to split the PPA owner and the actual PPA name
                            ppa = release.ppas[0]['ppa']
                            owner = ppa.split("/")[0]
                            actual_ppa = ppa.split("/")[1]
                        else:
                            # otherwise, the release is a pure Ubuntu one
                            ppa = binary.component
                            owner = "ubuntu"
                            actual_ppa = ppa

                        if 'soss' in release.canon:
                            origin = "soss"
                        else:
                            origin = "ubuntu"
                        # construct the LP link to download and variant of the package
                        if release.is_subproject:
                            url = f"https://launchpad.net/~{owner}/+archive/{origin}/{actual_ppa}/+files/{filename}"
                            variant = ppa
                        else:
                            if ("+esm" in binary.version.version) or ("~esm" in binary.version.version):
                                if "esm-apps" in release.canon:
                                    url = f"https://launchpad.net/~ubuntu-esm/+archive/ubuntu/esm-apps-security/+files/{filename}"
                                    variant = "universe esm"
                                elif "esm-infra" in release.canon:
                                    url = f"https://launchpad.net/~ubuntu-esm/+archive/ubuntu/esm-infra-security/+files/{filename}"
                                    variant = "main esm"
                                elif "esm-infra-legacy" in release.canon:
                                    url = f"https://launchpad.net/~ubuntu-esm/+archive/ubuntu/esm-infra-legacy-security/+files/{filename}"
                                    variant = "main esm"
                                else:
                                    print(f"ERROR in package {package_name}, {binary.version} for {release}. Not included in final SBOM.")
                                    continue
                            else:
                                if arch == 'amd64' or arch == 'i386':
                                    url = f"https://archive.ubuntu.com/ubuntu/pool/{binary.component}/{package_name[0]}/{package_name}/{filename}"
                                    variant = binary.component
                                else:
                                    url = f"https://ports.ubuntu.com/pool/{binary.component}/{package_name[0]}/{package_name}/{filename}"
                                    variant = binary.component

                        # Extra check to make sure the requested url exists. This is suggested if generating SBOMs for a subproject
                        if args.check_urls and (not check_link_exists(url)):
                            filename = f"{binary.name}_{binary.version}_all.deb"
                            url = f"https://launchpad.net/~{owner}/+archive/ubuntu/{actual_ppa}/+files/{filename}"
                            if not check_link_exists(url):
                                print(f"ERROR: url for {package_name} not found: {url} in LP. Package cache might be outdated or LP might be unresponsive. Package WILL NOT be downloaded for SBOM analysis.")

                        # create the package entry metadata
                        package = {
                            'obtain_url': url,
                            'metadata': {
                                'artifact_id': filename,
                                'filename': filename,
                                'artifact_type': 'ubuntu',
                                'artifact_format': 'deb',
                                'variant': variant,
                                'release': release.version.version,
                                'project': f"ubuntu-{release.version}-{ppa}-{filename}",
                                'version': binary.version.version,
                                'compression_format': '',
                                'architecture': arch,
                                'sharing_method': 'upload'
                            }
                        }
                        artifact_tests.append(package)

        output = {'boilerplate_fields': boilerplate_fields, 'artifact_tests': artifact_tests}
        filename = f"{args.output_dir}/{release.canon.replace('/', '_')}.json"
        with open(filename, 'w') as f:
            json.dump(output, f, indent=2)
        if args.debug:
            print(f'Metadata stored in {filename}')