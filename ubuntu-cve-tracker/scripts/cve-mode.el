;;; cve-mode.el --- Major mode for editing CVE files         -*- lexical-binding: t; -*-

;; Copyright (c) 2018 Alex Murray

;; Author: Alex Murray <alex.murray@canonical.com>
;; Maintainer: Alex Murray <alex.murray@canonical.com>
;; URL: https://launchpad.net/ubuntu-cve-tracker
;; Version: 0.1
;; Package-Requires: ((emacs "26.1"))

;; This file is not part of GNU Emacs.

;; This program is free software: you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.

;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see <http://www.gnu.org/licenses/>.

;;; Commentary:

;;;; Setup

;; (require 'cve-mode)

;;; Code:
(require 'bug-reference)
(require 'seq)
(require 'cl-lib)
(require 'cvss-mode)

(defconst cve-mode-base-path
  (file-name-directory
   (file-truename
    (expand-file-name
     (or load-file-name buffer-file-name))))
  "The directory where cve-mode.el resides (should be $UCT/scripts/).")

(defgroup cve nil
  "Major mode for editing Ubuntu CVE Tracker CVE files."
  :group 'languages)

(defcustom cve-mode-fill-column 76
  "`fill-column' for `cve-mode'."
  :group 'cve-mode
  :type 'integer)

(defcustom cve-mode-default-user user-login-name
  "The default user to use for Assignee: and new Notes: entries."
  :group 'cve-mode
  :type '(choice (const nil) string))

(defvar cve-mode-keywords '("Candidate" "PublicDate" "PublicDateAtUSN" "CRD" "References" "Description" "Ubuntu-Description" "Notes" "Bugs" "Priority" "Discovered-by" "Assigned-to" "Tags" "Mitigation" "CVSS"))

(defvar cve-mode-all-releases '("devel" "upstream" "product" "snap" "warty" "hoary" "breezy" "dapper" "edgy" "feisty" "gutsy" "hardy" "intrepid" "jaunty" "karmic" "lucid" "maverick" "natty" "oneiric" "precise" "precise/esm" "quantal" "raring" "saucy" "trusty" "trusty/esm" "esm-infra-legacy/trusty" "utopic" "vivid" "vivid/stable-phone-overlay" "vivid/ubuntu-core" "wily" "xenial" "esm-apps/xenial" "esm-infra/xenial" "fips/xenial" "fips-updates/xenial" "yakkety" "zesty" "artful" "bionic" "esm-apps/bionic" "esm-infra/bionic" "fips/bionic" "fips-updates/bionic" "cosmic" "disco" "eoan" "focal" "esm-apps/focal" "fips/focal" "fips-updates/focal" "groovy" "hirsute" "impish" "jammy" "esm-apps/jammy" "fips-preview/jammy" "fips-updates/jammy" "kinetic" "lunar" "mantic" "noble" "esm-apps/noble" "oracular" "plucky" "esm-infra/focal"))

(defvar cve-mode-releases '("trusty/esm" "esm-infra-legacy/trusty" "esm-infra/xenial" "esm-apps/xenial" "esm-infra/bionic" "esm-apps/bionic" "focal" "esm-apps/focal" "jammy" "esm-apps/jammy" "noble" "esm-apps/noble" "oracular" "plucky" "esm-infra/focal" "devel"))

(defvar cve-mode-statuses '("needs-triage" "needed" "deferred" "pending" "released" "ignored" "not-affected" "DNE"))

(defvar cve-mode-statuses-requiring-comment '("deferred" "pending" "released" "ignored" "not-affected"))

(defvar cve-mode-priorities '("untriaged" "negligible" "low" "medium" "high" "critical"))

(defvar cve-mode-cve-tags '("cisa-kev"))

(defvar cve-mode-package-tags '("apparmor" "fortify-source" "hardlink-restriction" "heap-protector" "not-ue" "pie" "stack-protector" "symlink-restriction" "universe-binary"))

(defvar cve-mode-cve-id-regexp "\\(CVE-[[:digit:]Y]\\{4\\}-[[:digit:]N]\\{4,\\}\\)")

(defvar cve-mode-date-time-regexp (concat
                                   "\\(\\([[:digit:]]\\{4\\}-[[:digit:]]\\{2\\}-[[:digit:]]\\{2\\}\\)"
                                   "\\( \\([[:digit:]]\\{2\\}:[[:digit:]]\\{2\\}:[[:digit:]]\\{2\\}"
                                   "\\( [A-Z]+\\)?\\)\\)?\\|unknown\\)\\s-*$"))

(defvar cve-mode-note-regexp "^\\s-+\\([^<]+\\)\\([>|]\\)\\(.*\\)")

(defvar cve-mode-package-name-regexp "[a-z0-9][a-z0-9+.-]+")

(defvar cve-mode-patch-types '("upstream" "backport" "vendor" "other" "break-fix"))

(defvar cve-mode-patch-types-regexp (concat "^ \\(" (regexp-opt cve-mode-patch-types) "\\):"))

(defvar cve-mode-patches-regexp (concat "^\\(\\(Patches\\)_\\(" cve-mode-package-name-regexp "\\)\\):"))

(defvar cve-mode-cve-tags-regexp (concat "\\(Tags\\):"))

(defvar cve-mode-package-tags-regexp (concat "\\(\\(Tags\\)_\\(" cve-mode-package-name-regexp "\\)\\):"))

(defvar cve-mode-keywords-regexp (concat "^\\(" (regexp-opt cve-mode-keywords) "\\):"))

(defvar cve-mode-releases-regexp (concat "^\\(" (regexp-opt cve-mode-all-releases) "\\)" "_"
                                         "\\(" cve-mode-package-name-regexp "\\):"))

(defvar cve-mode-priority-regexp (concat "^Priority: \\(" (regexp-opt cve-mode-priorities) "\\)\\s-*$"))

(defvar cve-mode-assigned-to-regexp (concat "^Assigned-to: \\([A-Za-z0-9 ,-]+\\)"))

(defvar cve-mode-priority-package-regexp
  (concat "^\\(\\(Priority\\)_\\(" cve-mode-package-name-regexp "\\)\\): "
          "\\(" (regexp-opt cve-mode-priorities) "\\)"))

(defvar cve-mode-priority-package-release-regexp
  (concat "^\\(Priority\\)_\\(" cve-mode-package-name-regexp "\\)"
          "\\(_\\(" (regexp-opt cve-mode-all-releases) "\\)\\)?: "
          "\\(" (regexp-opt cve-mode-priorities) "\\)"))

(defvar cve-mode-description-regexp (concat "^ \\(.*\\)$"))

(defvar cve-mode-cvss-sources '("nvd" "rhel" "ubuntu" "unknown"))

(defvar cve-mode-cvss-sources-regexp (concat "^ \\(" (regexp-opt cve-mode-cvss-sources) "\\):"))

(defvar cve-mode-font-lock-defaults
  `(((,cve-mode-keywords-regexp
      (1 font-lock-keyword-face))
     (,cve-mode-patch-types-regexp
      (1 font-lock-keyword-face))
     (,cve-mode-cvss-sources-regexp
      (1 font-lock-keyword-face))
     ;; CVSS base score and severity following a CVSS vector
     ,(append (car cvss-mode-font-lock-keywords)
              '(("\\[" nil nil (0 font-lock-builtin-face))
                ("[0-9.]+\\s-+NONE" nil nil (0 font-lock-comment-face t))
                ("[0-9.]+\\s-+LOW" nil nil (0 font-lock-comment-face t))
                ("[0-9.]+\\s-+MEDIUM" nil nil (0 font-lock-variable-name-face t))
                ("[0-9.]+\\s-+HIGH" nil nil (0 font-lock-warning-face t))
                ("[0-9.]+\\s-+CRITICAL" nil nil (0 font-lock-warning-face t))
                ("\\]" nil nil (0 font-lock-builtin-face t))))
     (,(concat "^Candidate:\\s-*\\(" cve-mode-cve-id-regexp "\\)")
      (1 font-lock-function-name-face))
     ,`(,cve-mode-releases-regexp
        (1 font-lock-constant-face)
        (2 font-lock-variable-name-face)
        ;; match first but then reset position back to end of releases so
        ;; we can continue to match status keywords
        ("(.*)"
         nil (re-search-backward cve-mode-releases-regexp)
         (0 font-lock-doc-face t))
        ("\\<DNE\\>" nil nil (0 font-lock-comment-face t))
        ("\\<not-affected\\>" nil nil (0 font-lock-comment-face t))
        ("\\<ignored\\>" nil nil (0 font-lock-comment-face t))
        ("\\<needed\\>" nil nil (0 font-lock-warning-face t))
        ("\\<needs-triage\\>" nil nil (0 font-lock-warning-face t))
        ("\\<deferred\\>" nil nil (0 font-lock-builtin-face t))
        ("\\<pending\\>" nil nil (0 font-lock-constant-face t))
        ("\\<released\\>" nil nil (0 font-lock-keyword-face t)))
     ("^Priority: "
      ("\\<negligible\\>" nil nil (0 font-lock-comment-face t))
      ("\\<low\\>" nil nil (0 font-lock-comment-face t))
      ("\\<medium\\>" nil nil (0 font-lock-variable-name-face t))
      ("\\<high\\>" nil nil (0 font-lock-warning-face t))
      ("\\<critical\\>" nil nil (0 font-lock-warning-face t)))
     (,cve-mode-assigned-to-regexp
      (1 font-lock-type-face))
     (,cve-mode-note-regexp
      (1 font-lock-type-face)
      (2 font-lock-builtin-face))
     (,cve-mode-patches-regexp
      (2 font-lock-constant-face)
      (3 font-lock-variable-name-face))
     (,cve-mode-priority-package-regexp
      (2 font-lock-keyword-face)
      (3 font-lock-variable-name-face)
      (4 font-lock-type-face))
     (,cve-mode-priority-package-release-regexp
      (1 font-lock-keyword-face)
      (2 font-lock-variable-name-face)
      (4 font-lock-constant-face)
      (5 font-lock-type-face))
     (,cve-mode-cve-tags-regexp
      (1 font-lock-keyword-face)
      (,(regexp-opt cve-mode-cve-tags) nil nil (0 font-lock-keyword-face)))
     (,cve-mode-package-tags-regexp
      (2 font-lock-constant-face)
      (3 font-lock-variable-name-face)
      (,(regexp-opt cve-mode-package-tags) nil nil (0 font-lock-keyword-face)))
     (":>|" . 'font-lock-builtin-face)
     ;; CVE Ids
     (,cve-mode-cve-id-regexp
      (1 font-lock-variable-name-face))
     (,cve-mode-date-time-regexp
      (0 font-lock-variable-name-face)))))

(defvar cve-mode-syntax-table
  (let ((table (make-syntax-table)))
    ;; add / and _ as symbol characters
    (modify-syntax-entry ?/ "/" table)
    (modify-syntax-entry ?_ "/" table)
    ;; # is comment start
    (modify-syntax-entry ?# "<" table)
    ;; newline finishes comment line
    (modify-syntax-entry ?\n ">" table)
    table))

(defun cve-mode-completion-at-point ()
  "`completion-at-point' function for `cve-mode'."
  (when (eq major-mode 'cve-mode)
    (let ((bounds (bounds-of-thing-at-point 'symbol)))
      (list (car bounds)                  ; start
            (cdr bounds)                  ; end
            (append cve-mode-keywords cve-mode-releases cve-mode-statuses cve-mode-priorities cve-mode-tags)
            :company-docsig #'identity))))

(defun cve-mode-indent-line ()
  "Indent current line in `cve-mode'."
  (interactive)
  (if (bolp)
      (cve-mode--indent-line)
    (save-excursion
      (cve-mode--indent-line))))

(defun cve-mode--note-user ()
  "Get the user who authored the current note."
  (unless (string= (cve-mode--current-block) "Notes")
    (error "This is not a Notes block"))
  (save-excursion
    (let ((user nil))
      (beginning-of-line)
      (while (not (or (and (looking-at cve-mode-note-regexp)
                           (re-search-forward cve-mode-note-regexp)
                           (setq user (match-string 1)))
                      (looking-at "^[A-Z].*")))
        (forward-line -1))
      user)))

(defun cve-mode--indent-line ()
  "Indent current line in `cve-mode'."
  (let ((block (cve-mode--current-block)))
    (beginning-of-line)
    (cond
     ((or (looking-at cve-mode-keywords-regexp)
          (looking-at cve-mode-releases-regexp)
          (looking-at cve-mode-patches-regexp))
      ;; headings etc indent to 0
      (indent-line-to 0))
     ((or (looking-at cve-mode-patch-types-regexp))
      (indent-line-to 1))
     ((and (string= block "Notes")
           (not (looking-at cve-mode-note-regexp))
           (cve-mode--note-user))
      (indent-line-to 2))
     ;; indent bracketed / parenthesised descriptions
     ((and (string= block "Description")
           (> (car (syntax-ppss)) 0))
      (indent-line-to 2))
     (t
      (indent-line-to 1)))))

(defun cve-mode-set-priority (&optional priority)
  "Set the current CVE's PRIORITY (prompt if none specified)."
  (interactive
   (list (completing-read "Priority: " cve-mode-priorities)))
  (save-excursion
    (save-restriction
      (goto-char (point-min))
      (if (re-search-forward cve-mode-priority-regexp nil t)
          (replace-match priority t t nil 1)
        (error "Unable to find Priority field in CVE")))))

(defun cve-mode-set-status-for-current-line-or-region (&optional status comment)
  "Set the STATUS with optional COMMENT for the current line or region.

If none is specified will prompt - and will only prompt when
STATUS is one of `cve-mode-statuses-requiring-comment'."
  (interactive
   (let ((status (completing-read "Status: " cve-mode-statuses))
         (comment nil))
     (when (seq-contains-p cve-mode-statuses-requiring-comment status)
       (setq comment (read-string "Comment: ")))
     (list status comment)))
  (save-excursion
    (save-restriction
      (if (region-active-p)
          (narrow-to-region (region-beginning) (region-end))
        (narrow-to-region (line-beginning-position) (line-end-position)))
      (goto-char (point-min))
      (while (re-search-forward
              (concat cve-mode-releases-regexp "\\s-+"
                      "\\(" (regexp-opt cve-mode-statuses) "\\)"
                      "\\(.*\\)?") nil t)
        (replace-match status t t nil 3)
        (when (length> comment 0)
          ;; replace existing comment if one exists otherwise add one to the end
          ;; of the line
          (if (match-string 4)
              (replace-match (concat " (" comment ")") t t nil 4)
            (goto-char (line-end-position))
            (insert (concat " (" comment ")"))))))))

(defun cve-mode-set-assigned-to (&optional assignee)
  "Assign the current CVE to ASSIGNEE (prompt if none specified)."
  (interactive (list (read-string "Assignee: "
                                  cve-mode-default-user)))
  (save-excursion
    (save-restriction
      (goto-char (point-min))
      (if (re-search-forward "^Assigned-to:\\(.*\\)\\s-*$" nil t)
          ;; ensure a space after the colon
          (replace-match (concat " " assignee) t t nil 1)
        (error "Unable to find Assigned-to field in CVE")))))

(defun cve-mode-add-note (&optional user note)
  "Add a NOTE by USER to the current CVE (prompt if none specified)."
  (interactive (list (read-string "User: " cve-mode-default-user)
                     (read-string "Note: ")))
  (save-excursion
    (save-restriction
      (goto-char (point-min))
      (if (null (re-search-forward "^Notes:" nil t))
          (error "Unable to find Notes field of CVE")
        ;; now go to the next heading in the CVE so we append to the
        ;; existing Notes
        (re-search-forward "^[A-Z]")
        (beginning-of-line)
        ;; format note across lines
        (let ((beg (point)))
          ;; add a newline so we can push the next heading down one line so
          ;; it doesn't inadvertently get appended to the new note
          (insert "\n")
          (cve-mode--replace-note-in-region beg beg user note)
          (goto-char beg))))))

(defun cve-mode-add-tag (&optional package tag)
  "Add a TAG to to PACKAGE in CVE (prompt if none specified)."
  (interactive (list (completing-read "Package: " (cve-mode--cve-packages))
                     (completing-read "Tag: " cve-mode-tags)))
  (save-excursion
    (save-restriction
      (goto-char (point-min))
      (if (null (re-search-forward (concat "^Tags_" package ":") nil t))
          ;; no existing Tags_ section - add one after the Patches_ secion
          (progn
            (re-search-forward cve-mode-patches-regexp)
            ;; go to next line that doesn't start with whitespace
            (re-search-forward "^[^[:space:]]")
            (beginning-of-line)
            (insert (concat "Tags_" package ": " tag "\n")))
        ;; append to existing Tags_ section
        (end-of-line)
        (insert (concat " " tag))))))

(defvar cve-mode--source-packages
  (split-string
   (shell-command-to-string "umt grep '.*'")))

(defvar cve-mode--packages-releases nil)

(defun cve-mode--package-releases (package)
  "Get the list of releases where PACKAGE exists.
Queries umt for PACKAGE as well as looking in overlay files."
  (let ((status (assoc-string package cve-mode--packages-releases)))
    (if (not (null status))
        (cdr status)
      (let ((releases nil))
        (with-temp-buffer
          (shell-command (format "umt search \"%s\"" package) (current-buffer))
          (goto-char (point-min))
          (while (re-search-forward (concat "^\\([a-z]+\\): .*, Pocket:.*, Component: .*$") nil t)
            (let ((release (match-string 1)))
              (push release releases))))
        ;; look for overlay files for specific overlay releases
        (dolist (release cve-mode-releases)
          (when (string-match-p "/" release)
            (let ((overlay-filename (concat
                                     (replace-regexp-in-string "/" "-" release)
                                     "-supported.txt")))
              ;; also get for precise-esm specifically
              (with-temp-buffer
                (insert-file-contents
                 (expand-file-name overlay-filename
                                   (file-name-directory
                                    (directory-file-name
                                     cve-mode-base-path))))
                (when (re-search-forward (concat "^" package "$") nil t)
                  (push release releases))))))
        (add-to-list 'cve-mode--packages-releases `(,package . ,releases))
        (cve-mode--package-releases package)))))

(defun cve-mode-insert-package (package)
  "Add PACKAGE as affected to this CVE.
Calls out to active_edit to do the heavy lifting so that
boilerplates entries are handled automatically."
  (interactive
   (list (completing-read "Package: " cve-mode--source-packages)))
  (let ((args (list "-c" (file-name-base (buffer-file-name))
                    "-p" package "-y"))
        (output (get-buffer-create "*active_edit*")))
    ;; need to tell active_edit is embargoed if file is already in
    ;; embargoed tree
    (when (string-match-p "embargoed/" (buffer-file-name))
      (push "-e" args))
    (when (buffer-modified-p)
      (if (y-or-n-p "Buffer is modified.  Do you want to save it first? ")
          (save-buffer)
        (user-error "Unable to proceed with modified buffer")))
    ;; call call-process via apply so we can pass the list of arguments for
    ;; active_edit as a list itself rather than as individual arguments
    (apply #'call-process
           (expand-file-name
            "active_edit"
            cve-mode-base-path)
           nil output t args)
    (let ((revert-without-query t))
      (revert-buffer))))

(defun cve-mode--cve-packages ()
  "Return the list of packages for the current CVE."
  (let ((packages))
    (save-excursion
      (goto-char (point-min))
      (while (re-search-forward cve-mode-patches-regexp nil t)
        (push (substring-no-properties (match-string 3)) packages)))
    (nreverse packages)))

(defun cve-mode--download-patch (type url filename)
  "Download patch of TYPE from URL to FILENAME."
  (cond ((string= type "upstream")
         ;; handle forges that we can just append .patch to the URL to get
         ;; the patch file
         (cond ((string-match-p "^https://\\(git\\(hub\\|lab\\).com\\|salsa.debian.org\\|gitlab.gnome.org\\)/.*/\\(commits?\\|merge_requests\\)/[0-9a-f]+\\(/diffs\\)?\\s-*$" url)
                (url-copy-file (concat url ".patch") filename))
               ;; cgit provides a patch via the /patch URL
               ((string-match-p "^https://.*cgit.*\\.git/commit/.*$" url)
                (url-copy-file (replace-regexp-in-string "/commit/" "/patch/" url) filename))
               (t (error "Unable to download %s patches like %s" type url))))
        (t (error "Unable to download %s patches from %s" type url))))

(defun cve-mode-download-patches (directory package)
  "Download the current CVEs patches for PACKAGE to DIRECTORY."
  (interactive (list (read-directory-name "Target: ")
                     (completing-read "Package: " (cve-mode--cve-packages))))
  (let ((beg nil)
        (end nil)
        (patches nil))
    (save-excursion
      (goto-char (point-min))
      (while (and (null beg) (null end)
                  (re-search-forward cve-mode-patches-regexp nil t))
        (when (string= (substring-no-properties (match-string 3)) package)
          (setq beg (point))
          (re-search-forward cve-mode-releases-regexp)
          (forward-line -1)
          (setq end (line-end-position))
          (goto-char beg)
          (while (re-search-forward cve-mode-patch-types-regexp end t)
            (push (append (list (match-string-no-properties 1))
                          ;; add any notes which come after the patch URL itself
                          (string-split
                           (buffer-substring-no-properties
                            (point) (line-end-position)) nil t))
                  patches)))))
    (if (eq (length patches) 1)
        (let* ((note (caddar patches))
               ;; remove any () in note and prefix with a -
               (suffix (if note (concat "-" (replace-regexp-in-string "[()]" "" note)) "")))
          (apply #'cve-mode--download-patch
                 (list (caar patches)
                       (cadar patches)
                       ;; generate filename without -N suffix since there
                       ;; is only 1 patch
                       (expand-file-name
                        (concat (file-name-base (buffer-file-name)) suffix ".patch")
                         directory))))
      (let ((i 1))
        (dolist (patch (reverse patches))
          (let* ((note (caddr patch))
                  ;; remove any () in note and prefix with a -
                 (suffix (if note (concat "-" (replace-regexp-in-string "[()]" "" note)) "")))
            (apply #'cve-mode--download-patch
                   (list (car patch)
                         (cadr patch)
                         (expand-file-name
                          (concat (file-name-base (buffer-file-name))
                                  suffix
                                  "-" (format "%d" i) ".patch")
                                directory))))
          (cl-incf i))))))

(defun cve-mode--cve-urls ()
  "Return the list of URLs listed in the current CVE."
  (save-excursion
    (save-restriction
      (goto-char (point-min))
      (let ((urls))
        (while (re-search-forward "\\(https?://[^[:space:]\n]+\\)" nil t)
          (message (match-string 1))
          (push (match-string 1) urls))
        (nreverse urls)))))

(defun cve-mode-browse-url (&optional url)
  "Prompt user to browse for one of the URLs referenced in the CVE."
  (interactive (list (completing-read "URL: " (cve-mode--cve-urls))))
  (browse-url url))

(defvar cve-mode--inactive-statuses '("released" "ignored" "not-affected" "DNE"))

(defun cve-mode--action (action)
  "ACTION the current CVE by moving it to the associated directory.

Also check that there are no outstanding statuses for any package in the CVE.
ACTION is either ignore or retire."
  (unless (or (string= action "ignore")
              (string= action "retire"))
    (error "Unknown action %s" action))
  (let ((filename (buffer-file-name)))
    (when (not (string-match-p "active/" filename))
      (error "This is not an active CVE so it cannot be %sd" action))
    ;; validate that all release statuses are either released, not-affected or
    ;; ignored except for upstream
    (save-excursion
      (save-restriction
        (goto-char (point-min))
        (while (re-search-forward
                (concat cve-mode-releases-regexp "\\s-+"
                        "\\(" (regexp-opt cve-mode-statuses) "\\)") nil t)
          (let ((release (match-string 1))
                (pkg (match-string 2))
                (status (match-string 3)))
            (if (and (not (string= release "upstream"))
                     (not (string-match (regexp-opt cve-mode--inactive-statuses) status nil t)))
                (error "Release %s for pkg %s is %s - so this CVE cannot be retired" release pkg status))))))
    (let ((new-filename (replace-regexp-in-string "active/" (concat action "d/") filename)))
      (rename-file filename new-filename)
      (kill-buffer)
      (find-file new-filename))))

(defun cve-mode-ignore ()
  "Ignore the current CVE file by moving it from active/ to ignored/."
  (interactive)
  (cve-mode--action "ignore"))

(defun cve-mode-retire ()
  "Retire the current CVE file by moving it from active/ to retired/."
  (interactive)
  (cve-mode--action "retire"))

(defun cve-mode--current-block ()
  "Get the name of the current block."
  (save-excursion
    (let ((block-regexp "^\\([A-Za-z0-9_-]+\\):\\s-*$"))
      (beginning-of-line)
      ;; if not already at a block heading, find the one we are in
      (unless (looking-at block-regexp)
        (re-search-backward block-regexp))
      (substring-no-properties (match-string 1)))))

(defun cve-mode--narrow-to-block ()
  "Narrow to the current block."
  ;; find current block heading - blocks are delimited by starting at start
  ;; of line
  (save-excursion
    (let ((block-regexp "^\\([A-Za-z0-9/_-]+\\):"))
      (beginning-of-line)
      ;; if not already at a block heading, find the one we are in
      (unless (looking-at block-regexp)
        (re-search-backward block-regexp))
      ;; get the line after this as the start of the current block
      (let* ((beg (progn (forward-line) (line-beginning-position)))
             (end beg))
        (when (re-search-forward block-regexp nil t)
          ;; use line end of line above next heading as end of region
          (forward-line -1)
          (setq end (line-end-position)))
        ;; always narrow to something so we don't overfill
        (narrow-to-region beg end)))))

(defun cve-mode--replace-note-in-region (beg end user note &optional justify region)
  "Replace region from BEG to END with NOTE from USER.

Optionally fill for JUSTIFY and REGION when specified."
  (save-excursion
    (save-restriction
      ;; fill previous note - erase it then insert it
      ;; and fill it
      (narrow-to-region beg end)
      (delete-region beg end)
      (goto-char beg)
      (insert (concat " " user "> "))
      (insert note)
      (let ((fill-paragraph-function nil)
            (fill-column cve-mode-fill-column)
            (fill-prefix nil)
            (adaptive-fill-function #'(lambda () "  ")))
        (indent-region beg (point))
        (fill-paragraph justify region)))))

(defun cve-mode--fill-notes (&optional justify region)
  "Fill the current visible buffer as Notes with JUSTIFY and REGION."
  ;; notes should always have user> as a prefix somewhere and could have
  ;; multiple ones - process one-line at a time
  (save-excursion
    (save-restriction
      (goto-char (point-min))
      (let ((beg nil)
            (end nil)
            (user nil)
            (note nil))
        (while (< (point) (point-max))
          ;; user> foo
          (cond ((looking-at cve-mode-note-regexp)
                 (re-search-forward cve-mode-note-regexp)
                 ;; if no user yet, this is the first line so use it
                 (if (not user)
                     (setq beg (match-beginning 0)
                           end (match-end 0)
                           user (string-trim (substring-no-properties (match-string 1)))
                           note (string-trim (substring-no-properties (match-string 3))))
                   (if (string= user (string-trim
                                      (substring-no-properties (match-string 1))))
                       ;; is same user - concatenate note
                       (setq note (concat note " " (string-trim
                                                    (substring-no-properties
                                                     (match-string 3))))
                             end (match-end 0))
                     (save-match-data
                       (cve-mode--replace-note-in-region beg end user note
                                                         justify region))
                     (setq beg (match-beginning 0)
                           end (match-end 0)
                           user (string-trim (substring-no-properties (match-string 1)))
                           note (string-trim (substring-no-properties (match-string 3)))))))
                (t
                 (setq note (concat note " "
                                    (string-trim
                                     (buffer-substring-no-properties
                                      (point) (line-end-position))))
                       end (line-end-position))))
          ;; always try and advance to next line
          (forward-line))
        ;; have to now fill the last note
        (when (and beg end user note)
          (cve-mode--replace-note-in-region beg end user note justify region))))))

(defun cve-mode-fill-paragraph (&optional justify region)
  "Fill paragraph and JUSTIFY with REGION.
This behaves as `fill-paragraph' except that filling does not
cross boundaries of block literals."
  (interactive "*P")
  (save-excursion
    (save-restriction
      (let ((block (cve-mode--current-block)))
        (cve-mode--narrow-to-block)
        (cond ((string= block "Notes")
               (cve-mode--fill-notes justify region))
              (t
               ;; TODO - special case break-fix / patches etc so we don't
               ;; break too many lines
               (let ((fill-paragraph-function nil)
                     (fill-column cve-mode-fill-column)
                     (fill-prefix " "))
                 (indent-region (point-min) (point-max))
                 (fill-paragraph justify region))))))))

(defun cve-mode-auto-fill-function ()
  "Auto fill for `cve-mode'."
  (save-excursion
    (beginning-of-line)
    (if (re-search-forward cve-mode-note-regexp (line-end-position) t)
        (let ((fill-prefix (if (eq cve-mode-prefix-notes-lines 'all)
                               (concat " " (substring-no-properties (match-string 1))
                                       "> ")
                             "  ")))
          (do-auto-fill))
      (let ((fill-prefix " "))
        (do-auto-fill)))))

(defvar cve-mode-map
  (let ((map (make-sparse-keymap)))
    ;; prefix actions with C-c C-mnemonic
    (define-key map (kbd "C-c C-a") #'cve-mode-set-assigned-to)
    (define-key map (kbd "C-c C-i") #'cve-mode-insert-package)
    (define-key map (kbd "C-c C-n") #'cve-mode-add-note)
    (define-key map (kbd "C-c C-p") #'cve-mode-set-priority)
    (define-key map (kbd "C-c C-s") #'cve-mode-set-status-for-current-line-or-region)
    (define-key map (kbd "C-c C-t") #'cve-mode-add-tag)
    (define-key map (kbd "C-c C-d") #'cve-mode-download-patches)
    (define-key map (kbd "C-c C-b") #'cve-mode-browse-url)
    map)
  "Keymap for `cve-mode'.")

(defun cve-mode--beginning-of-defun ()
  "Move to the beginning of the current block/field."
  (let ((case-fold-search nil)
        (block-regexp "^[A-Z][A-Za-z0-9_\\/-]+:"))
    (re-search-backward block-regexp nil t)
    (beginning-of-line)))

(defun cve-mode--end-of-defun ()
  "Move to the end of the current block/field."
  (let ((case-fold-search nil)
        (block-regexp "^[A-Z][A-Za-z0-9_\\/-]+:"))
    ;; if not already at a block heading, find the one we are in
    (end-of-line)
    (unless (re-search-forward block-regexp nil t)
      (goto-char (point-max)))
    (beginning-of-line)))

;;;###autoload
(define-derived-mode cve-mode text-mode "CVE"
  "A major mode for editing CVE files."
  :syntax-table cve-mode-syntax-table
  (setq-local font-lock-defaults cve-mode-font-lock-defaults)
  (setq-local beginning-of-defun-function #'cve-mode--beginning-of-defun)
  (setq-local end-of-defun-function #'cve-mode--end-of-defun)
  (setq-local imenu-generic-expression `(("Headings" ,cve-mode-keywords-regexp 0)
                                         ("Packages" ,cve-mode-patches-regexp 3)))
  (add-to-list 'completion-at-point-functions #'cve-mode-completion-at-point)
  (set (make-local-variable 'comment-start) "#")
  (set (make-local-variable 'comment-end) "")
  ;; only # at start of line should be a comment - so any # which has
  ;; anything before it should be considered a punctuation character ("."
  ;; character class)
  (set (make-local-variable 'syntax-propertize-function)
       (syntax-propertize-rules (".\\(#+\\)" (1 "."))))
  (set (make-local-variable 'indent-tabs-mode) nil)
  (set (make-local-variable 'indent-line-function) #'cve-mode-indent-line)
  (set (make-local-variable 'fill-paragraph-function) #'cve-mode-fill-paragraph)
  (set (make-local-variable 'normal-auto-fill-function) #'cve-mode-auto-fill-function)
  (set (make-local-variable 'compile-command)
       (concat (file-name-as-directory cve-mode-base-path) "check-syntax "
               (if buffer-file-name
                   (shell-quote-argument buffer-file-name))))
  ;; linkify CVEs via bug-reference-mode
  (set (make-local-variable 'bug-reference-url-format) "https://ubuntu.com/security/%s")
  (set (make-local-variable 'bug-reference-bug-regexp) "\\(\\(CVE-[[:digit:]]\\{4\\}-[[:digit:]N]\\{4,\\}\\)\\)")
  (cvss-mode 1)
  (bug-reference-mode 1)
  ;; linkify URLs
  (goto-address-mode 1))

(defconst cve-mode--check-syntax-executable
  (concat (file-name-as-directory cve-mode-base-path) "check-syntax"))

;; flymake integration in place of flycheck
(defvar-local cve-mode--flymake-proc nil)

(defun cve-mode-flymake (report-fn &rest _args)
  "`flymake' backend function for `cve-mode' to report errors via REPORT-FN."
  ;; disable if check-syntax is not available
  (unless (executable-find cve-mode--check-syntax-executable)
    (error "Cannot find check-syntax"))

  ;; kill any existing running instance
  (when (process-live-p cve-mode--flymake-proc)
    (kill-process cve-mode--flymake-proc))

  (let ((source (current-buffer)))
    (save-restriction
      (widen)
      ;; Reset the `cve-mode--flymake-proc' process to a new process
      ;; calling check-syntax.
      (setq
       cve-mode--flymake-proc
       (make-process
        :name "cve-mode-flymake" :noquery t :connection-type 'pipe
        ;; Make output go to a temporary buffer.
        :buffer (generate-new-buffer " *cve-mode-flymake*")
        :command `(,cve-mode--check-syntax-executable "--stdin")
        :sentinel
        (lambda (proc _event)
          (when (memq (process-status proc) '(exit signal))
            (unwind-protect
                ;; Only proceed if `proc' is the same as
                ;; `cve-mode--flymake-proc', which indicates that
                ;; `proc' is not an obsolete process.
                ;;
                (if (with-current-buffer source (eq proc cve-mode--flymake-proc))
                    (with-current-buffer (process-buffer proc)
                      (goto-char (point-min))
                      ;; Parse the output buffer for diagnostic's
                      ;; messages and locations, collect them in a list
                      ;; of objects, and call `report-fn'.
                      ;;
                      (cl-loop
                       while (search-forward-regexp
                              "^\\(WARNING: \\)?\\(?:.*\\): \\([0-9]+\\): \\(.*\\)$"
                              nil t)
                       for msg = (match-string 3)
                       for (beg . end) = (flymake-diag-region
                                          source
                                          (string-to-number (match-string 2)))
                       for type = (if (and (match-string 1)
                                           (string= "WARNING: " (match-string 1)))
                                      :warning
                                    :error)
                       collect (flymake-make-diagnostic source beg end type msg)
                       into diags
                       finally (funcall report-fn diags)))
                  (flymake-log :warning "Canceling obsolete check %s" proc))
              ;; Cleanup the temporary buffer used to hold the
              ;; check's output.
              (kill-buffer (process-buffer proc)))))))
      (process-send-region cve-mode--flymake-proc (point-min) (point-max))
      (process-send-eof cve-mode--flymake-proc))))

;;;###autoload
(defun cve-mode-setup-flymake-backend ()
  "Setup the `flymake' backend for `cve-mode'."
  (add-hook 'flymake-diagnostic-functions 'cve-mode-flymake nil t))

;;;###autoload
(add-hook 'cve-mode-hook 'cve-mode-setup-flymake-backend)

;;;###autoload
(add-to-list 'auto-mode-alist '("CVE-[[:digit:]Y]\\{4\\}-[[:digit:]N]\\{4,\\}\\'" . cve-mode))

(provide 'cve-mode)
;;; cve-mode.el ends here
