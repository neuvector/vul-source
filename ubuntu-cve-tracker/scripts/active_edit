#!/usr/bin/env python3

# Author: Jamie Strandboge <jamie@ubuntu.com>
# Author: Kees Cook <kees@ubuntu.com>
# Copyright (C) 2005-2016 Canonical Ltd.
#
# This script is distributed under the terms and conditions of the GNU General
# Public License, Version 2 or later. See http://www.gnu.org/copyleft/gpl.html
# for details.

from datetime import datetime, timezone
import optparse
import os
import pathlib
import re
import sys

import cve_lib
import source_map

releases = ['upstream'] + cve_lib.all_releases

max_file_size = 10 * 1024 * 1024  # 10MB
cvedir = cve_lib.active_dir

parser = optparse.OptionParser()
parser.add_option("-p", "--package", dest="pkgs", help="Package name and optional version where package is fixed (with optional Ubuntu release and version in that release)", metavar="NAME[,VERSION[,RELEASE,RELEASE_VERSION]]", action="append")
parser.add_option("-b", "--bug-url", dest="bug_urls", help="Bug references", metavar="URL", action="append")
parser.add_option("-r", "--reference-url", dest="ref_urls", help="URL references", metavar="URL", action="append")
parser.add_option("-k", "--kernel-break-fix", dest="breakfix", help="Automatically fetch kernel break-fix data", action="store_true")
parser.add_option("-c", "--cve", dest="cve", help="CVE entry", metavar="CVE-YYYY-NNNN")
parser.add_option("-e", "--embargoed", dest="embargoed", help="This is an embargoed entry", action="store_true")
parser.add_option("-y", "--yes", dest="autoconfirm", help="Do not ask for confirmation", action="store_true")
parser.add_option("-P", "--public", dest="public_date", help="Record date the CVE went public (default to today in UTC)", metavar="YYYY-MM-DD")
parser.add_option("--priority", help="Record a priority for the CVE", default=None)
parser.add_option("-R", "--priority-reason", help="Record a priority reason for the CVE", default=None)
parser.add_option("-C", "--cvss", help="Assigner and CVSS3.1 rating, separated by a comma", metavar="assigner,CVSS:3.1/AV:_/AC:_/PR:_/UI:_/S:_/C:_/I:_/A:_", action="append")
parser.add_option("-d", "--description", help="Description", default=None)
(options, args) = parser.parse_args()

source = source_map.load(detailed=False)
all_aliases = source_map.get_all_aliases(source, None)

added_rel_pkg = []

def pkg_in_rel(pkg,rel):
    if rel in ['upstream']:
        return True
    if rel not in source:
        return False
    return (pkg in source[rel])

def get_releases(pkgname):
    # deep copy
    tmp = []
    for r in releases:
        tmp.append(r)

    # Handle when devel isn't open yet
    if cve_lib.devel_release == '':
        tmp.append('')

    return tmp

def release_wants_dne(release):
    '''Return true if the release wants to have DNE entries in CVE files.'''
    # for now only UBUNTU products should have DNE entries
    _, product, _, _ = cve_lib.get_subproject_details(release)
    return product != None and product == cve_lib.PRODUCT_UBUNTU

def _add_pkg(p, fp, fixed, parent, embargoed, break_fixes):
    print('', file=fp)
    print('Patches_%s:' % p, file=fp)
    if p == "linux":
        for [break_hash,fix_hash] in break_fixes:
            print(" break-fix: %s %s" % (break_hash, fix_hash), file=fp)
        if break_fixes:
            print('Tags_%s: review-break-fix' % p, file=fp)
    if p in cve_lib.package_db \
       and "tags" in cve_lib.package_db[p] \
       and p in cve_lib.package_db[p]["tags"] \
       and len(cve_lib.package_db[p]["tags"][p]) > 0:
        print('Tags_%s: %s' % (p, " ".join(cve_lib.package_db[p]["tags"][p])), file=fp)
    # find which releases p exists in
    higher_not_affected = False
    fixed_in = None
    fixed_in_release = None
    fixed_in_release_version = None
    if p in fixed and len(fixed[p]) > 0:
        fixed_in = fixed[p][0]
        if len(fixed[p]) > 1:
            fixed_in_release = fixed[p][1]
        if len(fixed[p]) > 2:
            fixed_in_release_version = fixed[p][2]
    for rel in ['upstream'] + cve_lib.release_sort(list(source.keys())):
        # get_aliases_of_ubuntu_package is an expensive operation, check
        # if we know there's an alias before attempting to get it
        aliases = []
        if p in all_aliases:
            aliases = source_map.get_aliases_of_ubuntu_package(source, p, rel)
        # determine default state but override this if pkg_db has a
        # better one
        state = "needs-triage"
        if not pkg_in_rel(p, rel) and not aliases:
            # package doesn't exist in this release - see if it wants a
            # DNE entry
            if release_wants_dne(rel):
                state = "DNE"
            else:
                continue
        if rel == cve_lib.devel_release:
            # devel is present in source.keys() so continue so we use that
            # instead of the codename
            continue
        elif rel in cve_lib.eol_releases and not cve_lib.is_active_esm_release(rel):
            continue
        elif state != "DNE" and cve_lib.is_active_esm_release(rel):
            state = cve_lib.EOL_ESM_STATUS.split(',')[0] + ')'
        elif rel == 'upstream' and fixed_in is not None:
            state = "released (%s)" % fixed_in
        elif fixed_in_release_version and rel == fixed_in_release:
            state = "not-affected (%s)" % fixed_in_release_version
            higher_not_affected = True
        elif higher_not_affected:
            state = "not-affected"

        # use pkg_db state if one exists
        state_tuple = None
        if p in pkg_db and p in pkg_db[p]["pkgs"] and rel in pkg_db[p]["pkgs"][p]:
            state_tuple = pkg_db[p]["pkgs"][p][rel]
        elif parent is not None and rel in pkg_db[parent]["pkgs"][p]:
            state_tuple = pkg_db[parent]["pkgs"][p][rel]
        if state_tuple:
            state = state_tuple[0]
            if len(state_tuple[1]) > 0:
                state = state + " (%s)" % state_tuple[1]
        if rel not in cve_lib.external_releases:
            print('%s_%s: %s' % (rel, p, state), file=fp)
        # TODO: figure out how to store subproject details for embargoed CVEs
        elif not embargoed:
            pkgs_to_add = [p]
            if aliases:
                pkgs_to_add = aliases

            # If the subproject doesn't require cve triage,
            # we shouldn't add any entries to the CVE
            if not cve_lib.is_cve_triage_required(rel): continue

            for pkg in pkgs_to_add:
                rel_pkgname = rel + '/' + pkg
                if not rel_pkgname in added_rel_pkg:
                    with open(os.path.join(cve_lib.get_external_subproject_cve_dir(rel), cve), "a") as f:
                        print('%s_%s: %s' % (rel, pkg, state), file=f)
                    added_rel_pkg.append(rel_pkgname)

def add_pkg(p, fp, fixed, parent, embargoed, break_fixes):
    # skip packages which don't actually exist in any release
    add = p in all_aliases
    if not add:
        for r in source.keys():
            add |= p in source[r]
    if add:
        _add_pkg(p, fp, fixed, parent, embargoed, break_fixes)

    # add pkgs from pkgdb but only if we are not already a subpackage
    if parent is None and p in pkg_db:
        for pkg in pkg_db[p]["pkgs"]:
            # don't add the same package twice
            if pkg != p:
                # we don't have fixed data for these subpackages
                add_pkg(pkg, fp, fixed={}, parent=p, embargoed=embargoed, break_fixes=break_fixes)

def create_or_update_cve(cve, packages, priority=None, bug_urls=None,
                         ref_urls=None, public_date=None, desc=None,
                         cvss=None, embargoed=False, breakfix=False,
                         priority_reason=None):
    pkgs = []
    break_fixes = []
    fixed = {}
    # parse optional fixed_in release and version from package name
    if packages:
        for p in packages:
            tmp_p = p.split(',')
            pkg = tmp_p[0]
            pkgs.append(pkg)
            fixed[pkg] = tmp_p[1:]

    update = False
    try:
        dst = cve_lib.find_cve(cve)
        update = True
    except ValueError:
        dst = os.path.join(pathlib.Path().parent.resolve(),
                           cve_lib.active_dir if not embargoed else cve_lib.embargoed_dir,
                           cve)

    # Download kernel break-fixes
    if breakfix and ref_urls:
        for url in ref_urls:
            if (url.startswith('https://git.kernel.org/linus/') or
                url.startswith('https://git.kernel.org/stable/c/') or
                url.startswith('https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=') or
                url.startswith('https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=')):
                break_fixes += cve_lib.fetch_kernel_fixes(url)
        break_fixes = cve_lib.validate_kernel_fixes(break_fixes)

    # collect notes from pkg_db and add any extra pkgs from pkg_db as well
    notes = []
    for p in pkgs:
        if p in pkg_db:
            notes = notes + pkg_db[p]["notes"]

    # ensure we only add each package once - say if there is openjdk,
    # openjdk-11, openjdk-13 in packages, then they should all reference the
    # same openjdk entry in package-db and so we only need to add this once
    names = set()
    for p in pkgs:
        if p in pkg_db:
            names.add(pkg_db[p]["name"])
        else:
            names.add(p)

    # normalise the list of packages
    pkgs = sorted(list(set(names)))

    # Set a default public date only when the CVE isn't being added to the
    # embargoed tree
    if not embargoed and not public_date:
        public_date = datetime.now(timezone.utc).strftime("%Y-%m-%d")

    if update:
        mode = "r+"
    else:
        mode = "x"
    with open(dst, mode, encoding="utf-8") as fp:
        if not update:
            print('Candidate: %s' % (cve), file=fp)
            print('PublicDate: %s' % (public_date if public_date else "unknown"), file=fp)
            if embargoed:
                print('CRD: %s' % (public_date if public_date else "unknown"), file=fp)
            print('References:\n https://www.cve.org/CVERecord?id=%s' % (cve), file=fp)
            for url in (ref_urls if ref_urls else []):
                print(" %s" % url, file=fp)
            print('Description:', file=fp)
            for desc_line in (cve_lib.wrap_text(desc).split('\n') if desc else []):
                print(" %s" % (desc_line), file=fp)
            print('Ubuntu-Description:', file=fp)
            print('Notes:', file=fp)
            for note in notes:
                for note_line in cve_lib.wrap_text(note[1], 75 - len(note[0]) - 2).split('\n'):
                    print(" %s> %s" % (note[0], note_line), file=fp)
            print('Mitigation:', file=fp)
            print('Bugs:', file=fp)
            for url in (bug_urls if bug_urls else []):
                print(" %s" % url, file=fp)
            priority_text = priority if priority else "untriaged"
            if priority in cve_lib.PRIORITY_REASON_REQUIRED and not priority_reason:
                priority_text += "\n XXX-Reason-XXX"
            elif priority and priority_reason:
                priority_text += f"\n {priority_reason}"
            print('Priority: %s' % priority_text, file=fp)
            print('Discovered-by:', file=fp)
            print('Assigned-to:', file=fp)
            print('CVSS:', file=fp)
            for entry in (cvss if cvss else []):
                src, cvss = entry
                print(' %s: %s [%.1f %s]' %
                      (src,
                       cvss["baseMetricV3"]["cvssV3"]["vectorString"],
                       cvss["baseMetricV3"]["cvssV3"]["baseScore"],
                       cvss["baseMetricV3"]["cvssV3"]["baseSeverity"]), file=fp)

        for p in pkgs:
            add_pkg(p, fp, fixed, None, embargoed, break_fixes)

        # Update the Priority field if a new priority was provided
        if priority is not None:
            metadata_to_update = "Priority:"
            priority_text = priority if priority else "untriaged"
            if priority in cve_lib.PRIORITY_REASON_REQUIRED and not priority_reason:
                raise ValueError(f'priority "{priority}" requires a priority reason')
            elif priority and priority_reason:
                priority_text += f"\n {priority_reason}"
            update_file_metadata(metadata_to_update, priority_text, fp)

def update_file_metadata(metadata, value, cve_fp):
    cve_fp.seek(0)
    cve_content = cve_fp.readlines()
    for line_index, line in enumerate(cve_content):
        if line.startswith(metadata):
            cve_content[line_index] = f"{metadata} {value}\n"
    cve_fp.seek(0)
    cve_fp.truncate()
    cve_fp.writelines(cve_content)

def parse_cvss_options(cvsses):
    parsed = []
    for cvss in cvsses:
        parts = cvss.split(",")
        if len(parts) != 2:
            raise ValueError("specified CVSS '%s' does not contain a source" % cvss)
        source = parts[0]
        vector = parts[1]
        parsed.append((source, cve_lib.parse_cvss(vector)))
    return parsed

pkg_db = cve_lib.load_package_db()

if not options.cve:
    parser.print_help()
    sys.exit(1)

cve = options.cve
pkgs = options.pkgs
pat = cve_lib.CVE_RE

if options.embargoed:
    cvedir = cve_lib.embargoed_dir
    pat = re.compile(r'^[\w-]*$')

    if not os.path.islink(cvedir):
        print("embargoed/ is not a symlink. Aborting!\n", file=sys.stderr)
        sys.exit(1)


if not pat.search(cve):
    if options.embargoed:
        print("Bad embargoed entry.  Should be alphanumerics and dashes\n", file=sys.stderr)
    else:
        print("Bad CVE entry.  Should be CVE-XXXX-XXXX\n", file=sys.stderr)
    sys.exit(1)

if options.cvss:
    try:
        options.cvss = parse_cvss_options(options.cvss)
    except Exception as e:
        print("Error parsing CVSS option: %s" % str(e), file=sys.stderr)
        sys.exit(1)

create_or_update_cve(cve, pkgs, priority=options.priority, bug_urls=options.bug_urls, ref_urls=options.ref_urls, public_date=options.public_date, desc=options.description, cvss=options.cvss, embargoed=options.embargoed, breakfix=options.breakfix, priority_reason=options.priority_reason)
sys.exit(0)
