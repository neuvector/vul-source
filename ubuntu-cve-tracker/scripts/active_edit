#!/usr/bin/env python3

# Author: Jamie Strandboge <jamie@ubuntu.com>
# Author: Kees Cook <kees@ubuntu.com>
# Copyright (C) 2005-2016 Canonical Ltd.
#
# This script is distributed under the terms and conditions of the GNU General
# Public License, Version 2 or later. See http://www.gnu.org/copyleft/gpl.html
# for details.

import datetime
import optparse
import os
import pathlib
import re
import sys

import cve_lib
import source_map

releases = ['upstream'] + cve_lib.all_releases

max_file_size = 10 * 1024 * 1024  # 10MB
cvedir = cve_lib.active_dir

parser = optparse.OptionParser()
parser.add_option("-p", "--package", dest="pkgs", help="Package name and optional version where package is fixed (with optional Ubuntu release and version in that release)", metavar="NAME[,VERSION[,RELEASE,RELEASE_VERSION]]", action="append")
parser.add_option("-b", "--bug-url", dest="bug_urls", help="Bug references", metavar="URL", action="append")
parser.add_option("-r", "--reference-url", dest="ref_urls", help="URL references", metavar="URL", action="append")
parser.add_option("-c", "--cve", dest="cve", help="CVE entry", metavar="CVE-YYYY-NNNN")
parser.add_option("-e", "--embargoed", dest="embargoed", help="This is an embargoed entry", action="store_true")
parser.add_option("-y", "--yes", dest="autoconfirm", help="Do not ask for confirmation", action="store_true")
parser.add_option("-P", "--public", dest="public_date", help="Record date the CVE went public (default to today in UTC)", metavar="YYYY-MM-DD")
parser.add_option("--priority", help="Record a priority for the CVE", default=None)
parser.add_option("-C", "--cvss", help="CVSS3.1 rating", metavar="CVSS:3.1/AV:_/AC:_/PR:_/UI:_/S:_/C:_/I:_/A:_")
parser.add_option("-d", "--description", help="Description", default=None)
(options, args) = parser.parse_args()


source_releases = []
for release in cve_lib.all_releases:
    if cve_lib.is_active_esm_release(release) or cve_lib.is_active_release(release):
        source_releases.append(release)
source = source_map.load(releases=source_releases, skip_eol_releases=False)

added_rel_pkg = []

def pkg_in_rel(pkg,rel):
    if rel in ['upstream']:
        return True
    if rel not in source:
        return False
    return (pkg in source[rel])

def get_releases(pkgname):
    # deep copy
    tmp = []
    for r in releases:
        tmp.append(r)

    # Handle when devel isn't open yet
    if cve_lib.devel_release == '':
        tmp.append('')

    return tmp

def release_wants_dne(release):
    '''Return true if the release wants to have DNE entries in CVE files.'''
    # for now only UBUNTU products should have DNE entries
    _, product, _, _ = cve_lib.get_subproject_details(release)
    return product != None and product == cve_lib.PRODUCT_UBUNTU

def _add_pkg(p, fp, fixed, parent, embargoed):
    print('', file=fp)
    print('Patches_%s:' % p, file=fp)
    if p in cve_lib.package_db \
       and "tags" in cve_lib.package_db[p] \
       and p in cve_lib.package_db[p]["tags"] \
       and len(cve_lib.package_db[p]["tags"][p]) > 0:
        print('Tags_%s: %s' % (p, " ".join(cve_lib.package_db[p]["tags"][p])), file=fp)
    # find which releases p exists in
    higher_not_affected = False
    fixed_in = None
    fixed_in_release = None
    fixed_in_release_version = None
    if p in fixed and len(fixed[p]) > 0:
        fixed_in = fixed[p][0]
        if len(fixed[p]) > 1:
            fixed_in_release = fixed[p][1]
        if len(fixed[p]) > 2:
            fixed_in_release_version = fixed[p][2]
    for rel in ['upstream'] + list(source.keys()):
        aliases = source_map.get_aliases_of_ubuntu_package(source, p, rel)
        pkgs_from_generic = source_map.get_packages_from_generic_name(source, p, rel)
        # determine default state but override this if pkg_db has a
        # better one
        state = "needs-triage"
        if not pkg_in_rel(p, rel) and not aliases and not pkgs_from_generic:
            # package doesn't exist in this release - see if it wants a
            # DNE entry
            if release_wants_dne(rel):
                state = "DNE"
            else:
                continue
        if rel == cve_lib.devel_release:
            # devel is present in source.keys() so continue so we use that
            # instead of the codename
            continue
        elif rel in cve_lib.eol_releases and not cve_lib.is_active_esm_release(rel):
            continue
        elif cve_lib.is_active_esm_release(rel):
            state = "ignored (out of standard support)"
        elif rel == 'upstream' and fixed_in is not None:
            state = "released (%s)" % fixed_in
        elif fixed_in_release_version and rel == fixed_in_release:
            state = "not-affected (%s)" % fixed_in_release_version
            higher_not_affected = True
        elif higher_not_affected:
            state = "not-affected"

        # use pkg_db state if one exists
        state_tuple = None
        if p in pkg_db and p in pkg_db[p]["pkgs"] and rel in pkg_db[p]["pkgs"][p]:
            state_tuple = pkg_db[p]["pkgs"][p][rel]
        elif parent is not None and rel in pkg_db[parent]["pkgs"][p]:
            state_tuple = pkg_db[parent]["pkgs"][p][rel]
        if state_tuple:
            state = state_tuple[0]
            if len(state_tuple[1]) > 0:
                state = state + " (%s)" % state_tuple[1]
        if rel not in cve_lib.external_releases:
            print('%s_%s: %s' % (rel, p, state), file=fp)
        # TODO: figure out how to store subproject details for embargoed CVEs
        elif not embargoed:
            pkgs_to_add = [p]
            if aliases:
                pkgs_to_add = aliases
            elif pkgs_from_generic:
                pkgs_to_add = pkgs_from_generic

            for pkg in pkgs_to_add:
                rel_pkgname = rel + '/' + pkg
                if not rel_pkgname in added_rel_pkg:
                    with open(os.path.join(cve_lib.get_external_subproject_cve_dir(rel), cve), "a") as f:
                        print('%s_%s: %s' % (rel, pkg, state), file=f)
                    added_rel_pkg.append(rel_pkgname)

def add_pkg(p, fp, fixed, parent, embargoed):
    # skip packages which don't actually exist in any release
    add = False
    for r in source.keys():
        aliases = source_map.get_all_aliases(source, r)
        pkgs_from_generic = source_map.get_packages_from_generic_name(source, p, r)
        add |= p in source[r] or p in aliases or len(pkgs_from_generic) > 0
    if add:
        _add_pkg(p, fp, fixed, parent, embargoed)

    # add pkgs from pkgdb but only if we are not already a subpackage
    if parent is None and p in pkg_db:
        for pkg in pkg_db[p]["pkgs"]:
            # don't add the same package twice
            if pkg != parent:
                # we don't have fixed data for these subpackages
                add_pkg(pkg, fp, fixed={}, parent=p, embargoed=embargoed)

def create_or_update_cve(cve, packages, priority=None, bug_urls=None, ref_urls=None, public_date=None, desc=None, cvss=None, embargoed=False):

    pkgs = []
    fixed = {}
    # parse optional fixed_in release and version from package name
    for p in packages:
        tmp_p = p.split(',')
        pkg = tmp_p[0]
        pkgs.append(pkg)
        fixed[pkg] = tmp_p[1:]

    update = False
    try:
        dst = cve_lib.find_cve(cve)
        update = True
    except ValueError:
        dst = os.path.join(pathlib.Path().parent.resolve(),
                           cve_lib.active_dir if not embargoed else cve_lib.embargoed_dir,
                           cve)

    # collect notes from pkg_db and add any extra pkgs from pkg_db as well
    notes = []
    for p in pkgs:
        if p in pkg_db:
            notes = notes + pkg_db[p]["notes"]

    # ensure we only add each package once - say if there is openjdk,
    # openjdk-11, openjdk-13 in packages, then they should all reference the
    # same openjdk entry in package-db and so we only need to add this once
    names = set()
    for p in pkgs:
        if p in pkg_db:
            names.add(pkg_db[p]["name"])
        else:
            names.add(p)

    # normalise the list of packages
    pkgs = sorted(list(set(names)))

    # Set a default public date only when the CVE isn't being added to the
    # embargoed tree
    if not embargoed and not public_date:
        public_date = datetime.datetime.utcnow().strftime("%Y-%m-%d")

    if update:
        mode = "a"
    else:
        mode = "x"
    with open(dst, mode, encoding="utf-8") as fp:
        if not update:
            print('Candidate: %s' % (cve), file=fp)
            print('PublicDate: %s' % (public_date if public_date else "unknown"), file=fp)
            if embargoed:
                print('CRD: %s' % (public_date if public_date else "<TBD>"), file=fp)
            print('References:\n https://cve.mitre.org/cgi-bin/cvename.cgi?name=%s' % (cve), file=fp)
            for url in (ref_urls if ref_urls else []):
                print(" %s" % url, file=fp)
            print('Description:', file=fp)
            for desc_line in (cve_lib.wrap_text(desc).split('\n') if desc else []):
                print(" %s" % (desc_line), file=fp)
            print('Ubuntu-Description:', file=fp)
            print('Notes:', file=fp)
            for note in notes:
                for note_line in cve_lib.wrap_text(note[1], 75 - len(note[0]) - 2).split('\n'):
                    print(" %s> %s" % (note[0], note_line), file=fp)
            print('Mitigation:', file=fp)
            print('Bugs:', file=fp)
            for url in (bug_urls if bug_urls else []):
                print(" %s" % url, file=fp)
            print('Priority: %s' % (priority if priority else "untriaged"), file=fp)
            print('Discovered-by:', file=fp)
            print('Assigned-to:', file=fp)
            print('CVSS:', file=fp)
            for entry in (cvss if cvss else []):
                src, cvss = entry
                print(' %s: %s' % (src, cvss), file=fp)

        for p in pkgs:
            add_pkg(p, fp, fixed, None, embargoed)



pkg_db = cve_lib.load_package_db()

if not options.pkgs:
    parser.print_help()
    sys.exit(1)

if not options.cve:
    parser.print_help()
    sys.exit(1)

cve = options.cve
pkgs = options.pkgs
pat = cve_lib.CVE_RE

if options.embargoed:
    cvedir = cve_lib.embargoed_dir
    pat = re.compile(r'^[\w-]*$')

    if not os.path.islink(cvedir):
        print("embargoed/ is not a symlink. Aborting!\n", file=sys.stderr)
        sys.exit(1)


if not pat.search(cve):
    if options.embargoed:
        print("Bad embargoed entry.  Should be alphanumerics and dashes\n", file=sys.stderr)
    else:
        print("Bad CVE entry.  Should be CVE-XXXX-XXXX\n", file=sys.stderr)
    sys.exit(1)

create_or_update_cve(cve, pkgs, priority=options.priority, bug_urls=options.bug_urls, ref_urls=options.ref_urls, public_date=options.public_date, desc=options.description, cvss=options.cvss, embargoed=options.embargoed)
sys.exit(0)
