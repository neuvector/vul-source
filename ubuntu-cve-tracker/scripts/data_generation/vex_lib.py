# -*- coding: utf-8 -*-
# Module containing classes that are used to generate OpenVEX data for CVEs and USNs
#
# Author: Nick Galanis <nick.galanis@canonical.com>
# Copyright (C) 2024 Canonical Ltd.
#
# This script is distributed under the terms and conditions of the GNU General
# Public License, "Version" 3 or later. See http://www.gnu.org/copyleft/gpl.html
# for details.
#

from datetime import datetime
import json
import logging
import os

logger = logging.getLogger(__name__)

class VexDocument:
    id: str
    timestamp: datetime
    version: int
    endpoint: str

    def __init__(self, output_dir, version):
        self.cve_storage = None
        self.package_storage = None
        self.output_dir = output_dir
        self.version = version
        self.id = self.init_id()

    def generate_metadata(self):
        metadata = {
            "@context": "https://openvex.dev/ns/v0.2.0",
            "@id": self.id,
            "author": "Canonical Ltd.",
            "timestamp": datetime.now().isoformat(),
            "version": self.version
        }

        return metadata

    def generate_binary_product(self, pkg, arch):
        # Prototype: pkg:deb/ubuntu/dpkg@1.19.0.4?arch=amd64
        _id = "pkg:deb/ubuntu/" + pkg.name + "@" + pkg.version.version + "?arch=" + arch
        product = {
            "@id": _id,
        }
        return product

    def generate_source_product(self, src_pkg, fixed_version, release):
        # Prototype: pkg:deb/ubuntu/dpkg@1.19.0.4?arch=src?distro=jammy
        _id = "pkg:deb/ubuntu/" + src_pkg.name + "@" + fixed_version.version + "?arch=src" + "?distro=" + str(release.canon)
        product = {
            "@id": _id,
        }
        return product


    def generate_document(self, output_file):
        if self.id is None:
            return None
        document = {}

        document["metadata"] = self.generate_metadata()
        document["statements"] = self.generate_statements()

        # we do not want to create empty VEX documents
        if document["statements"] == [{}]:
            logger.info(f"VEX Document for {self.id} has no statements and thus will not be generated.")
            return None

        if output_file is not None:
            # make sure the output directory exists
            output_path = os.path.join(self.output_dir, output_file)

            os.makedirs(os.path.dirname(output_path), exist_ok=True)
            with open(output_path, 'w') as fp:
                json.dump(document, fp, indent=4)
        else:
            logger.critical("VEX output file not provided.")

        return document

class CVE_VEXDocument(VexDocument):
    def __init__(self, cve, output_dir, version):
        self.cve = cve
        cve_year = self.cve.id[4:8]
        self.endpoint = "https://github.com/canonical/ubuntu-security-notices/blob/main/vex/cve/" + cve_year + "/"

        super().__init__(output_dir, version)

    def init_id(self):
        if not hasattr(self.cve, "id"):
            logger.warning("USN can not be loaded from cache")
            return None
        return self.endpoint + self.cve.id

    def create_status_dict(self):
        """
        Function to organize cve-pkg entries per their status, in order
        to be easy to parse from the VEX generator
        """
        status_dict = {}
        for release in self.cve.get_releases():
            for entry in self.cve.get_entries_affecting_release(release):
                if entry.status not in status_dict:
                    status_dict[entry.status] = []
                status_dict[entry.status].append(entry)

        return status_dict

    def generate_vulnerability(self):
        if not self.cve.id:
            logger.critical("CVE does not have an id. Exiting")
            exit(1)

        vulnerability = {
            "@id": "https://nvd.nist.gov/vuln/detail/" + self.cve.id,
            "name": self.cve.id,
            "description": self.cve.description.strip().replace('\n', ' '),
            "aliases": self.cve.references + ["https://ubuntu.com/security/" + self.cve.id]
        }

        return vulnerability

    def generate_status(self, entry):
        """
        Function to map each Ubuntu status in an OpenVEX status with its required fields,
        as per the OpenVEX spec v2
        """
        status_dict = {}
        release = entry.release
        status = entry.status
        if status == 'not-affected':
            status_dict['status'] = 'not_affected'
            status_dict['justification'] = 'vulnerable_code_not_present'
            status_dict['impact_statement'] = 'This package (for the given release), while related to the CVE in some way, is not affected by the issue. CVE notes should contain further information, if needed.'
        elif status == 'DNE':
            status_dict['status'] = 'not_affected'
            status_dict['justification'] = 'component_not_present'
            status_dict['impact_statement'] = 'This package (for the given release) does not exist in the archive.'
        elif status == 'needs-triage':
            status_dict['status'] = 'under_investigation'
            status_dict['status_notes'] = 'The vulnerability of this package (for the given release) is not known and needs to be evaluated.'
        elif status == 'deferred':
            status_dict['status'] = 'under_investigation'
            status_dict['status_notes'] = "This package (for the given release) is vulnerable to the CVE, the problem is understood, but it is currently deferred. Refer to the CVE notes on https://ubuntu.com/security/" + self.cve.id + " for more details."
        elif status == 'needed' or status == 'pending' or status == 'active':
            status_dict['status'] = 'affected'
            status_dict['action_statement'] = "This package (for the given release) is vulnerable to the CVE and needs fixing."
        elif status == 'pending':
            status_dict['status'] = 'affected'
            status_dict['action_statement'] = "This package (for the given release) is vulnerable to the CVE, needs fixing, and it is being actively worked on."
        elif status == 'ignored':
            status_dict['status'] = 'affected'
            if not release.is_active:
                # TODO: trusty supported
                status_dict['action_statement'] = "This package (for the given release) is no longer supported. Please upgrade your system."
            else:
                status_dict['action_statement'] = "This package (for the given release) is vulnerable to the CVE, the problem is understood, but the Ubuntu Security Team decided to not fix it. Refer to the CVE notes on https://ubuntu.com/security/" + self.cve.id + " for more details."
        elif status == 'released':
            status_dict['status'] = 'fixed'
            status_dict['status_notes'] = "This package (for the given release) was vulnerable, but an update has been uploaded and published."
            if "esm-infra" in release.name:
                status_dict['status_notes'] += " Available with Ubuntu Pro (infra only)."
            elif "esm-apps" in release.name:
                status_dict['status_notes'] += " Available with Ubuntu Pro."
        else:
            logger.critical("CVE statue not supported")
            status_dict['status'] = ''
        return status_dict

    def get_issue_date(self):
        return self.cve.public_date

    def generate_statements(self):
        """
        We want one statement per package entry
        Inside the statement, we have many products: the source package itself and the binaries for every arch
        """
        statements = []
        non_esm_released = []
        entries_status_dict = self.create_status_dict()
        # we want to grab the released entries first, so if something is released in a release, it doesn't
        # show up as 'not affected' in another component
        for status in reversed(sorted(entries_status_dict.keys())):
            products = []
            for entry in entries_status_dict[status]:
                logger.debug(f"Generating statement for {self.cve.id} {entry.release} {entry.pkg.name} {entry.status}")
                version = entry.pkg.get_latest_version(entry.release)
                # if the release has entered esm, and the package is in main, the only reason to print the status in the
                # non-esm release, is that it was already released there. Otherwise, we rely on the package status of the esm release
                if (entry.release.esm_infra_release is not None) and (entry.pkg.get_version_component(entry.release, version) in ['main', 'restricted'])\
                    and entry.pkg.release_exists(entry.release.esm_infra_release, False):
                    if status != 'released':
                        continue
                    else:
                        non_esm_released.append((entry.pkg, entry.release.esm_infra_release))
                # if the release has esm-apps, and the package is in unverse, the only reason to prin the status in the non-esm release
                # is that it was released there (possibly because the cve fix was synced from debian)
                if (entry.release.esm_apps_release is not None) and (entry.pkg.get_version_component(entry.release, version) in ['universe', 'multtiverse'])\
                    and entry.pkg.release_exists(entry.release.esm_apps_release, False):
                    if status != 'released':
                        continue
                    else:
                        non_esm_released.append((entry.pkg, entry.release.esm_apps_release))

                # if we are processing an esm entry, check if the package was already released in non-esm,
                # so the esm entry does not need to be reported
                if entry.release.is_esm:
                    if (entry.pkg, entry.release) in non_esm_released:
                        continue
                if version is not None:
                    product = self.generate_source_product(entry.pkg, version, entry.release)
                    products.append(product)

                    # for every binary and every one of its archs
                    for binary in entry.pkg.binaries[entry.release][version]:
                        for arch in binary.arches:
                            #output binary package
                            product = self.generate_binary_product(binary, arch)
                            products.append(product)
                else:
                    logger.info(f"No version found for package {entry.pkg.name}")
            # if we have at least one product in the specific status
            if products != []:
                # construct the statment and append it in the statements struct
                statement = {
                    "vulnerability": self.generate_vulnerability(),
                    "timestamp": self.get_issue_date(),
                    "products": products
                }
                statement.update(self.generate_status(entry))
                statements.append(statement)
            else:
                logger.debug(f"No products with {self.generate_status(entry)['status']} in package {entry.pkg.name}")
        return statements


class USN_VEXDocument(VexDocument):

    def __init__(self, usn, output_dir, version):
        self.usn = usn
        self.endpoint = "https://github.com/canonical/ubuntu-security-notices/blob/main/vex/usn/USN-"
        super().__init__(output_dir, version)

    def init_id(self):
        if not hasattr(self.usn, "id"):
            logger.warning("USN can not be loaded from cache")
            return None
        return self.endpoint + self.usn.id

    def generate_vulnerability(self, release):
        cves = self.usn.get_cves_affecting_release(release)
        if self.usn.id is None:
            logger.critical("USN does not have an id yet. USN database could be out of sync")
            exit(1)

        vulnerability = {
            "@id": "https://ubuntu.com/security/notices/USN-" + self.usn.id,
            "name": "USN-" + self.usn.id,
            "description": self.usn.description.strip().replace('\n', ' '),
            "aliases": [cve.id for cve in cves]
        }

        return vulnerability

    def generate_status(self, fixed_version):
        status_dict = {}
        status_dict['status'] = 'fixed'
        if self.usn is not None and self.usn.isummary is not None:
            status_dict['status_notes'] = self.usn.isummary.strip().replace('\n', ' ')
        else:
            status_dict['status_notes'] = " "

        if "esm" in fixed_version.version:
            status_dict['status_notes'] += " Available with Ubuntu Pro."
        return status_dict

    def get_issue_date(self):
        dt = datetime.fromtimestamp(self.usn.timestamp)
        return dt.strftime('%Y-%m-%d %H:%M:%S.%f')

    def generate_statements(self):
        # Since all the products mentioned in the USN will have the same status (fixed)
        # we are going to generate only one statement, with a fixed status
        products = []
        statement = {}
        for release in self.usn.get_releases():
            for source_pkg, fixed_version in self.usn.get_package_info_affecting_release(release):
                logger.debug(f"Generating statement for USN-{self.usn.id} {release} {source_pkg.name}")

                version = fixed_version

                #output source package
                product = self.generate_source_product(source_pkg, fixed_version, release)
                products.append(product)

                # for every binary and every one of its archs
                if version in source_pkg.binaries[release]:
                    for binary in source_pkg.binaries[release][version]:
                        for arch in binary.arches:
                            #output binary package
                            product = self.generate_binary_product(binary, arch)
                            products.append(product)
                # There is a case in which package cache does not have the correct binaries.
                # In that case, use them directly from the USN data
                else:
                    logger.info(f"Binaries in package {source_pkg.name} did not match version {version} in package cache. Using raw_binaries from the USN...")
                    for binary in self.usn.get_raw_binaries(release, source_pkg.name):
                        if hasattr(binary, 'arches'):
                            for arch in binary.arches:
                                #output binary package
                                product = self.generate_binary_product(binary, arch)
                                products.append(product)

                statement = {
                    "vulnerability": self.generate_vulnerability(release),
                    "timestamp": self.get_issue_date(),
                    "products": products
                }

                statement.update(self.generate_status(fixed_version))

        return [statement]

