#!/usr/bin/env python3
#
# SPDX-License-Identifier: GPL-3.0-only-only
#
# Author: Evan Caville <evan.caville@canonical.com>
# Copyright 2025 Canonical, Ltd.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License version 3,
# as published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranties of
# MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR
# PURPOSE. See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see http://www.gnu.org/licenses/.
#

from datetime import datetime, timezone
from typing import Optional

import logging
import json
from data_generation.utils import (
    filter_binary,
    parse_package_status,
    write_pkg_json_for_release,
)


FORMAT = "1"

logger = logging.getLogger(__name__)


class SN:
    """SN Structure"""

    title: str
    description: str
    published_at: str
    related_cves: list
    related_launchpad_bugs: list

    def __init__(
        self, id, title, description, published_at, related_cves, related_lp_bugs
    ):
        self.title = title
        self.description = description
        self.published_at = datetime.fromtimestamp(
            published_at, tz=timezone.utc
        ).isoformat(timespec="seconds").replace("+00:00", "Z")
        self.related_cves = [cve.id for cve in related_cves]
        self.related_launchpad_bugs = related_lp_bugs

    def update_cves(self, cves):
        for cve in cves:
            if cve not in self.related_cves:
                self.related_cves.append(cve)

    def update_lp_bugs(self, lp_bugs):
        for lp_bug in lp_bugs:
            if lp_bug not in self.related_launchpad_bugs:
                self.related_launchpad_bugs.append(lp_bug)

    def to_dict(self):
        return self.__dict__


class USN(SN):
    def __init__(
        self, id, title, description, published_at, related_cves, related_lp_bugs
    ):
        super().__init__(
            id, title, description, published_at, related_cves, related_lp_bugs
        )


class LSN(SN):
    def __init__(
        self, id, title, description, published_at, related_cves, related_lp_bugs
    ):
        super().__init__(
            id, title, description, published_at, related_cves, related_lp_bugs
        )


class Package:
    source_versions: dict
    ubuntu_security_notices: dict
    ubuntu_security_notices_regressions: dict
    cves: dict

    def __init__(
        self,
        source_versions=None,
        ubuntu_security_notices=None,
        ubuntu_security_notices_regressions=None,
        cves=None,
    ):
        self.source_versions = source_versions if source_versions is not None else {}
        self.ubuntu_security_notices = (
            ubuntu_security_notices if ubuntu_security_notices is not None else {}
        )
        self.ubuntu_security_notices_regressions = (
            ubuntu_security_notices_regressions
            if ubuntu_security_notices_regressions is not None
            else {}
        )
        self.cves = cves if cves is not None else {}

    def add_security_notice(self, sn_id, sn, version):
        entry = {"source_fixed_version": version.version}
        if "regression" in sn.title.lower():
            self.ubuntu_security_notices_regressions[sn_id] = entry
        else:
            self.ubuntu_security_notices[sn_id] = entry

    def add_cves(self, cve_id, status, fix_version):
        self.cves[cve_id] = {
            "source_fixed_version": fix_version,
            "status": status,
        }

    def _get_pocket(self, source_version, release):
        rel = release.canon
        if "esm-infra" in rel:
            return "esm-infra"
        elif "esm-apps" in rel:
            return "esm-apps"
        elif "fips/" in rel:
            return "fips"
        elif "fips-updates" in rel:
            return "fips-updates"
        elif "fips-preview" in rel:
            return "fips-preview"
        else:
            return source_version.get("pocket").lower()

    def add_source_versions(self, name, source_versions, binaries, release):
        for source_version in sorted(source_versions):
            self.source_versions.setdefault(source_version.version, {})
            self.source_versions[source_version.version].setdefault(
                "binary_packages", {}
            )
            pocket = self._get_pocket(source_versions[source_version], release)
            self.source_versions[source_version.version].setdefault("pocket", pocket)
            for binary in binaries[source_version]:

                # for kernel, we only want linux images
                if name.startswith("linux") and not binary.name.startswith(
                    "linux-image-"
                ):
                    continue

                if binary.name.startswith(("golang-go")) or not filter_binary(
                    binary.name
                ):
                    self.source_versions[source_version.version][
                        "binary_packages"
                    ].setdefault(binary.name, binary.version.version)

    def to_dict(self):
        return self.__dict__


class CVE:
    """CVE Structure"""

    description: str
    published_at: str
    notes: list
    cvss_severity: Optional[str]
    cvss_score: Optional[int]
    ubuntu_priority: str
    mitigation: str
    related_usns: list
    related_packages: list

    def __init__(
        self,
        description,
        published_at,
        notes,
        cvss,
        ubuntu_priority,
        mitigation,
        related_usns=None,
        related_packages=None,
    ):
        self.description = description
        self.published_at = published_at
        self.notes = []
        for note in notes:
            self.notes.append(f"{note[0]}> {note[1]}")
        self.cvss_severity = cvss[0].severity.lower() if cvss else None
        self.cvss_score = cvss[0].score if cvss else None
        self.ubuntu_priority = ubuntu_priority
        self.mitigation = mitigation
        self.related_usns = related_usns if related_usns is not None else []
        self.related_packages = related_packages if related_packages is not None else []

    def add_related_sn(self, sn_id):
        if sn_id not in self.related_usns:
            self.related_usns.append(sn_id)

    def add_related_package(self, pkg_id):
        if pkg_id not in self.related_packages:
            self.related_packages.append(pkg_id)

    def to_dict(self):
        return self.__dict__


class PkgJson:
    """PKG-JSON Structure"""

    format: str
    published_at: str
    release: str
    packages: dict
    security_issues: dict

    def __init__(
        self,
        release,
    ):
        self.format = FORMAT
        self.release = release.series
        self.published_at = datetime.now().isoformat(timespec="seconds")
        self.packages = {}
        self.security_issues = {"cves": {}, "usns": {}}

    def to_dict(self):
        return self.__dict__

    def toJson(self):
        sorted_dict = dict(sorted(self.packages.items()))
        self.packages = sorted_dict
        sorted_dict = dict(sorted(self.security_issues["cves"].items()))
        self.security_issues["cves"] = sorted_dict
        sorted_dict = dict(sorted(self.security_issues["usns"].items()))
        self.security_issues["usns"] = sorted_dict
        return json.dumps(self, default=lambda o: o.to_dict(), indent=2)

    def update_security_issues_sn(self, sn_id, sn, cves, pkgs):
        self.security_issues["usns"][sn_id] = sn

        for cve in cves:
            pkg_json_cve = self.security_issues["cves"].get(
                cve.id,
                CVE(
                    cve.description,
                    cve.get_public_date(),
                    cve.notes,
                    cve.cvss,
                    cve.priority,
                    cve.mitigation,
                ),
            )
            pkg_json_cve.add_related_sn(sn_id)
            self.security_issues["cves"][cve.id] = pkg_json_cve

        for entry, version in pkgs:
            pkg = self.packages.get(entry.name, Package())
            pkg.add_security_notice(sn_id, sn, version)
            self.packages[entry.name] = pkg

    def update_security_issues_usn(self, usn, release):
        usn_id = usn.id
        cves = usn.get_cves_affecting_release(release)
        pkgs = usn.get_package_info_affecting_release(release)
        sn = USN(
            usn.id, usn.title, usn.description, usn.timestamp, cves, list(usn.lp_bugs)
        )
        self.update_security_issues_sn(f"USN-{usn_id}", sn, cves, pkgs)

    def update_security_issues_lsn(self, lsn, release):
        lsn_id = lsn.id
        cves = list()
        pkgs = list()
        info = lsn.get_fixed_info_affecting_release(release)
        for source_pkg in info.keys():
            fixed_release, fixed_version, module_name_regex, module_version = info[source_pkg]
            version = None
            if fixed_version is None:
                rel = fixed_release
                while version is None:
                    version = source_pkg.get_latest_version(rel)
                    rel = rel.parent
            else:
                version = fixed_version

            for cve in lsn.cves:
                entry = cve.get_pkg_entry_affecting_release(source_pkg.name, release)
                if entry is not None:
                    cves.append(cve)
                    pkgs.append((entry.pkg, version))

        sn = LSN(lsn.id, lsn.title, lsn.description, lsn.timestamp, lsn.cves, list())
        self.update_security_issues_sn(lsn_id, sn, cves, pkgs)

    def update_security_issues_cve(self, cve, release):
        pkg_json_cve = self.security_issues["cves"].get(
            cve.id,
            CVE(
                cve.description,
                cve.get_public_date(),
                cve.notes,
                cve.cvss,
                cve.priority,
                cve.mitigation,
            ),
        )

        applicable = False
        for entry in cve.get_entries_affecting_release(release):
            pkg_json_cve.add_related_package(entry.pkg.name)

            status, fix_version = parse_package_status(entry.status, entry.note)
            if status == "not-applicable":
                continue
            applicable = True

            pkg = self.packages.get(entry.pkg.name, Package())
            pkg.add_cves(cve.id, status, fix_version)
            self.packages[entry.pkg.name] = pkg

        if applicable:
            self.security_issues["cves"][cve.id] = pkg_json_cve

    def update_security_issues_pkg(self, pkg, release):
        if pkg.name not in self.packages:
            return

        pkg_json_pkg = self.packages[pkg.name]
        pkg_json_pkg.add_source_versions(
            pkg.name, pkg.source_info.get(release), pkg.binaries.get(release), release
        )
        self.packages[pkg.name] = pkg_json_pkg


def generate_release_batches(supported_releases):
    release_batches = {}
    for release in sorted(supported_releases):
        parent = release.get_oldest_parent()
        if parent is None:
            release_batches.setdefault(release, set([release]))
        elif release.is_fips:
            release_batches.setdefault(
                release, release_batches[parent].union(set([release]))
            )
        else:
            release_batches[parent].add(release)

    return release_batches


def generate_pkg_json(
    usn_info, lsn_info, cve_info, pkg_info, supported_releases, output_dir
):
    release_batches = generate_release_batches(supported_releases["pkg-json"])

    for source_release, batch in release_batches.items():

        sorted_batch = sorted(batch)
        pkg_json = PkgJson(source_release)
        for batch_release in sorted_batch:
            usns = usn_info.get_all_rel_usns(batch_release)
            for usn in usns:
                pkg_json.update_security_issues_usn(usn, batch_release)

            lsns = lsn_info.get_all_rel_lsns(batch_release)
            for lsn in lsns:
                pkg_json.update_security_issues_lsn(lsn, batch_release)

            cves = cve_info.get_all_rel_cves(batch_release)
            for cve in cves:
                pkg_json.update_security_issues_cve(cve, batch_release)

        for batch_release in sorted_batch:
            pkgs = pkg_info.get_all_rel_packages(batch_release, False)
            for pkg in pkgs:
                pkg_json.update_security_issues_pkg(pkg, batch_release)

        write_pkg_json_for_release(pkg_json.toJson(), source_release, output_dir)
