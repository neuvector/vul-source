#!/usr/bin/env python3
# Author: Eduardo Barretto <eduardo.barretto@canonical.com>
# Copyright (C) 2023 Canonical, Ltd.
#
# This script is distributed under the terms and conditions of the GNU General
# Public License, Version 3 or later. See http://www.gnu.org/copyleft/gpl.html
# for details.
#

from datetime import datetime
from datalib import Version

import logging
import json
import os
import sys

SCHEMA_VERSION = "1.6.3"
CVE_URL = "https://ubuntu.com/security"
USN_URL = "https://ubuntu.com/security/notices"

logger = logging.getLogger(__name__)

class Package:
    """Ubuntu specific info"""
    ecosystem: str
    name: str
    purl: str

    def __init__(self, release, src_pkg, fixed_version):
        # some releases, like ESM, do not have a version set, then
        # we need to use the parent's version
        self.ecosystem = release.name.replace(" ", ":")
        if release.is_esm:
            self.ecosystem = self.ecosystem.replace(":", ":Pro:", 1)

        self.name = src_pkg.name
        self.purl = "pkg:deb/ubuntu/" + self.name + "?arch=src?distro=" + str(release)

    def to_dict(self):
        return self.__dict__


class Event:
    introduced: str
    fixed: str
    last_affected: str
    limit: str

    def __init__(self, fixed_version):
        self.introduced = "0"
        if fixed_version:
            self.fixed = fixed_version.version

    def to_dict(self):
        result = [{"introduced": self.introduced}]
        if hasattr(self, "fixed"):
            result.append({"fixed": self.fixed})
        return result

class Range:
    type: str
    repo: str
    events: list

    def __init__(self, fixed_version):
        self.type = "ECOSYSTEM"
        self.events = Event(fixed_version)

    def to_dict(self):
        return self.__dict__


class Ecosystem:
    binaries: list
    availability: str
    ubuntu_priority: str
    priority_reason: str

    def __init__(self, binaries, product, ubuntu_priority=None, priority_reason=None):
        if binaries:
            self.binaries = []

            for binary in binaries:
                bins = {}
                if type(binary) is str:
                    bins['binary_name'] = binary
                    bins['binary_version'] = binaries[binary]['version']
                else:
                    bins['binary_name'] = binary.name
                    bins['binary_version'] = binary.version.version
                self.binaries.append(bins)
            self._update_availability(product)
        if ubuntu_priority:
            self.ubuntu_priority = ubuntu_priority
        if priority_reason:
            self.priority_reason = priority_reason

    def _update_availability(self, product):
        if 'Long Term' in product or 'Interim' in product:
            self.availability = "No subscription required"
        else:
            self.availability = product

    def to_dict(self):
        return self.__dict__


class Severity:
    """OSV severity field"""
    type: str
    score: str

    def __init__(self, cvss):
        self.type, self.score = self._parse_cvss(cvss.vector)

    def _parse_cvss(self, cvss_vector):
        cvss_type = cvss_vector.split('/', 1)[0]
        if cvss_type.startswith('AV'):
            cvss_type = 'CVSS_V2'
        elif cvss_type.startswith('CVSS:3'):
            cvss_type = 'CVSS_V3'
        elif cvss_type.startswith('CVSS:4'):
            cvss_type = 'CVSS_V4'
        else:
            logger.critical("Uknown CVSS")

        return cvss_type, cvss_vector

    def to_dict(self):
        return self.__dict__


class Affected:
    """OSV affected field"""

    package: Package
    severity: list
    ranges: list
    versions: list
    ecosystem_specific: Ecosystem

    def __init__(self, release, source, fixed_version, binaries, ubuntu_priority=None, priority_reason=None):
        self.package = Package(release, source, fixed_version)
        self.ranges = []
        self.ranges.append(Range(fixed_version))
        self.versions= []
        affected_versions = source.get_release_source_versions(release)
        if release.is_esm:
            affected_versions.update(source.get_release_source_versions(release.get_oldest_parent()))
        for version in sorted(affected_versions):
            if fixed_version and fixed_version <= version:
                continue
            self.versions.append(version.version)
        self.ecosystem_specific = Ecosystem(binaries, release.description, ubuntu_priority, priority_reason)

    def to_dict(self):
        return self.__dict__


class Reference:
    """OSV reference field"""

    type: str
    url: str

    def __init__(self, url_type, url):
        self.type = url_type
        self.url = url

    def to_dict(self):
        return self.__dict__


class OSV:
    """OSV structure"""

    schema_version: str
    id: str
    summary: str
    details: str
    severity: list
    published: str
    modified: str
    withdrawn: str
    affected: list
    aliases: list
    related: list
    references: list

    def __init__(self, id, description, published, modified, cves, references, related=[], aliases=[], summary=None, severity=None):
        self.schema_version = SCHEMA_VERSION
        self.id = id
        if summary:
            self.summary = summary
        self.details = description
        self.aliases = aliases
        self.related = related
        if severity:
            self.severity = []
            for entry in severity:
                self.severity.append(Severity(entry))
        self.published = published
        self.modified = self.published
        if modified:
            self.modified = modified
        self.affected = []
        self.references = []

        if 'USN-' in id:
            self.references.append(Reference("ADVISORY", f"{USN_URL}/{id}"))
        for cve in cves:
            self.references.append(Reference("REPORT", f"{CVE_URL}/{cve.id}"))
        for ref in references:
            if 'USN-' in ref and 'USN-' not in id:
                self.related.append(ref.split('/')[-1])
            # avoid any further comments after the URL
            self.references.append(Reference("REPORT", ref.split(' ')[0]))


    def to_dict(self):
        return self.__dict__

    def toJson(self):
        return json.dumps(self, default=lambda o: o.to_dict(), indent=2)


def write_osv(path, osv):
    with open(os.path.join(path, f"{osv.id}.json"), "w") as f:
        f.write(osv.toJson())


def parse_release_entries(cve, release, entries, affected):
    for entry in entries:
        logger.debug(f"{cve.id} {release} {entry.pkg} {entry.status}")
        source_pkg = entry.pkg
        fixed_version = None
        binaries = None

        if entry.note and entry.note[0].isdigit():
            fixed_version = Version(entry.note)
            logger.debug(f"fixed_version: {fixed_version}")

        if entry.status == "DNE":
            continue
        elif entry.status == "ignored":
            if release.is_esm and release.get_oldest_parent().is_active:
                logger.debug(f"{release} status is ignored but parent is active, SKIPPING")
                continue
            elif not release.is_active:
                logger.debug(f"{release} status is ignored, SKIPPING")
                continue
            fixed_version = None
            binaries = None
        elif entry.status in ["not-affected", "released"]:
            if not fixed_version:
                logger.debug("No fixed version for {release}, SKIPPING")
                continue
            elif fixed_version not in source_pkg.get_release_source_versions(release):
                logger.debug("Fixed version from previous release or parent, SKIPPING")
                continue
            else:
                binaries = source_pkg.binaries[release][fixed_version]
        elif entry.status in ["deferred", "needed", "needs-triage", "pending"]:
            if release.is_esm and release.get_oldest_parent().is_active:
                logger.debug("Avoid adding {release} because parent is active, SKIPPING")
                continue
            fixed_version = None
            binaries = None
        else:
            logger.critical("Unknown status {entry.status}")
            sys.exit(1)

        affected.append(Affected(release, source_pkg, fixed_version, binaries, cve.priority, cve.priority_reason))


def usn2osv(output_path, usn):
    affected = []
    osv = None
    for release in usn.get_releases():
        logger.debug(f"{usn.id} {release}")
        published = datetime.utcfromtimestamp(usn.timestamp).isoformat() + "Z"
        modified = None
        if os.path.isfile(os.path.join(output_path, f"USN-{usn.id}.json")):
            # if osv file already exists
            with open(os.path.join(output_path, f"USN-{usn.id}.json"), "r") as f:
                current_osv = json.load(f)
                # usns have only one timestamp field which gets updated
                # in case of a change
                if current_osv["modified"] != published:
                    modified = published
                    published = current_osv["published"]
                else:
                    logger.debug(f"unmodified USN-{usn.id}")
                    continue
        else:
            modified = published

        binaries = None
        for source_pkg, fixed_version in usn.get_package_info_affecting_release(release):
            if release not in source_pkg.binaries or fixed_version not in source_pkg.binaries[release]:
                logger.debug(f"retrieving raw binaries {usn.id} {release} {source_pkg} {fixed_version}")
                binaries = usn.get_raw_binaries(release, source_pkg.name)
            else:
                binaries = source_pkg.binaries[release][fixed_version]

            affected.append(Affected(release, source_pkg, fixed_version, binaries))

        if not osv:
            related = []
            aliases = []
            for cve in sorted(usn.cves):
                related.append(cve.id)
                related.append('UBUNTU-' + cve.id)
            osv = OSV(
                'USN-' + usn.id,
                usn.description,
                published,
                modified,
                sorted(usn.cves),
                sorted(usn.lp_bugs),
                summary=usn.summary,
                related=related,
                aliases=aliases,
            )
        osv.affected = affected

    if osv:
        write_osv(output_path, osv)

    return 0


def cve2osv(output_path, cve):
    affected = []
    osv = None
    packages = cve.pkg_entries
    if not packages:
        return

    published = cve.get_public_date() + "Z"
    modified = None
    if os.path.isfile(os.path.join(output_path, f"{cve.id}.json")):
        modified = datetime.utcnow().isoformat(timespec="seconds") + "Z"
    else:
        modified = published

    for release in cve.get_releases():
        if release.product not in ["ubuntu", "esm", "esm-infra", "esm-apps"]:
            # TODO: TEMPORARILY SKIPPING LEGACY
            logger.info(f"skipping {release}")
            continue

        parse_release_entries(cve, release, cve.get_entries_affecting_release(release), affected)

    if not osv and affected:
        related = [cve.id]
        aliases = []
        osv = OSV(
            'UBUNTU-' + cve.id,
            cve.description,
            published,
            modified,
            [cve],
            cve.references,
            severity=cve.cvss,
            related=related,
            aliases=aliases,
        )
        osv.affected = affected

    if osv:
        write_osv(output_path, osv)

    return 0
