#!/usr/bin/env python3
# Author: Eduardo Barretto <eduardo.barretto@canonical.com>
# Copyright (C) 2023 Canonical, Ltd.
#
# This script is distributed under the terms and conditions of the GNU General
# Public License, Version 3 or later. See http://www.gnu.org/copyleft/gpl.html
# for details.
#

from datetime import datetime
from datalib import Version
from data_generation.utils import generate_purl, prepare_output_dir

import logging
import json
import os
import sys

SCHEMA_VERSION = "1.6.3"
CVE_URL = "https://ubuntu.com/security"
USN_URL = "https://ubuntu.com/security/notices"

logger = logging.getLogger(__name__)


class Package:
    """Ubuntu specific info"""
    ecosystem: str
    name: str
    purl: str

    def __init__(self, release, src_pkg, fixed_version, is_lsn=False):
        # some releases, like ESM, do not have a version set, then
        # we need to use the parent's version
        self.ecosystem = release.name.replace(" ", ":")
        if release.is_esm or (is_lsn and not release.is_fips):
            self.ecosystem = self.ecosystem.replace(":", ":Pro:", 1)

        self.name = src_pkg.name
        version = fixed_version
        if version is None:
            rel = release
            while version is None:
                version = src_pkg.get_latest_version(rel)
                rel = rel.parent

        self.purl = generate_purl(self.name, version.version, release=str(release))

    def to_dict(self):
        return self.__dict__


class Event:
    introduced: str
    fixed: str
    last_affected: str
    limit: str

    def __init__(self, fixed_version):
        self.introduced = "0"
        if fixed_version:
            self.fixed = fixed_version.version

    def to_dict(self):
        result = [{"introduced": self.introduced}]
        if hasattr(self, "fixed"):
            result.append({"fixed": self.fixed})
        return result

class Range:
    type: str
    repo: str
    events: list

    def __init__(self, fixed_version):
        self.type = "ECOSYSTEM"
        self.events = Event(fixed_version)

    def to_dict(self):
        return self.__dict__


class Ecosystem:
    binaries: list
    availability: str
    ubuntu_priority: str
    priority_reason: str
    module_name_regex: str

    def __init__(self, binaries, product, ubuntu_priority=None, priority_reason=None, module_name_regex=None):
        if binaries:
            self.binaries = []

            for binary in binaries:
                bins = {}
                if type(binary) is str:
                    bins['binary_name'] = binary
                    bins['binary_version'] = binaries[binary]['version']
                else:
                    bins['binary_name'] = binary.name
                    bins['binary_version'] = binary.version.version
                self.binaries.append(bins)
            self._update_availability(product)
        if ubuntu_priority:
            self.ubuntu_priority = ubuntu_priority
        if priority_reason:
            self.priority_reason = priority_reason
        if module_name_regex:
            self.availability = "Livepatch subscription required"
            self.module_name_regex = module_name_regex

    def _update_availability(self, product):
        if 'Long Term' in product or 'Interim' in product:
            self.availability = "No subscription required"
        else:
            self.availability = product

    def to_dict(self):
        return self.__dict__


class Severity:
    """OSV severity field"""
    type: str
    score: str

    def __init__(self, cvss):
        self.type, self.score = self._parse_cvss(cvss.vector)

    def _parse_cvss(self, cvss_vector):
        cvss_type = cvss_vector.split('/', 1)[0]
        if cvss_type.startswith('AV'):
            cvss_type = 'CVSS_V2'
        elif cvss_type.startswith('CVSS:3'):
            cvss_type = 'CVSS_V3'
        elif cvss_type.startswith('CVSS:4'):
            cvss_type = 'CVSS_V4'
        else:
            logger.critical("Uknown CVSS")

        return cvss_type, cvss_vector

    def to_dict(self):
        return self.__dict__


class Affected:
    """OSV affected field"""

    package: Package
    severity: list
    ranges: list
    versions: list
    ecosystem_specific: Ecosystem

    def __init__(self, release, source, fixed_version, binaries, ubuntu_priority=None, priority_reason=None, module_name_regex=None):
        is_lsn = True if module_name_regex else False
        self.package = Package(release, source, fixed_version, is_lsn)
        self.ranges = []
        self.ranges.append(Range(fixed_version))
        self.versions= []
        affected_versions = source.get_release_source_versions(release)
        if release.is_esm:
            parent = release.parent
            while parent:
                affected_versions.update(source.get_release_source_versions(parent))
                parent = parent.parent
        for version in sorted(affected_versions):
            if fixed_version and fixed_version <= version:
                continue
            self.versions.append(version.version)
        self.ecosystem_specific = Ecosystem(binaries, release.description, ubuntu_priority, priority_reason, module_name_regex)

    def to_dict(self):
        return self.__dict__


class Reference:
    """OSV reference field"""

    type: str
    url: str

    def __init__(self, url_type, url):
        self.type = url_type
        self.url = url

    def to_dict(self):
        return self.__dict__


class OSV:
    """OSV structure"""

    schema_version: str
    id: str
    summary: str
    details: str
    severity: list
    published: str
    modified: str
    withdrawn: str
    affected: list
    aliases: list
    related: list
    references: list

    def __init__(self, id, description, published, modified, cves, references, related=[], aliases=[], summary=None, severity=None):
        self.schema_version = SCHEMA_VERSION
        self.id = id
        if summary:
            self.summary = summary
        self.details = description
        self.aliases = aliases
        self.related = related
        if severity:
            self.severity = []
            for entry in severity:
                self.severity.append(Severity(entry))
        self.published = published
        self.modified = self.published
        if modified:
            self.modified = modified
        self.affected = []
        self.references = []

        if 'USN-' in id or 'LSN-' in id:
            self.references.append(Reference("ADVISORY", f"{USN_URL}/{id}"))
        for cve in cves:
            self.references.append(Reference("REPORT", f"{CVE_URL}/{cve.id}"))
        for ref in references:
            if 'USN-' in ref and 'USN-' not in id:
                self.related.append(ref.split('/')[-1])
            # avoid any further comments after the URL
            self.references.append(Reference("REPORT", ref.split(' ')[0]))


    def to_dict(self):
        return self.__dict__

    def toJson(self):
        return json.dumps(self, default=lambda o: o.to_dict(), indent=2)


def write_osv(path, osv):
    with open(os.path.join(path, f"{osv.id}.json"), "w") as f:
        f.write(osv.toJson())


def verify_data_modified(path, osv):
    if os.path.isfile(os.path.join(path, f"{osv.id}.json")):
        # if osv file already exists
        with open(os.path.join(path, f"{osv.id}.json"), "r") as f:
            current_osv = json.load(f)
            current_osv['modified'] = ''
            new_osv = json.loads(osv.toJson())
            new_osv['modified'] = ''
            if current_osv != new_osv:
                logger.debug(f"{path}/{osv.id} modified")
                return True
            else:
                logger.debug(f"unmodified {path}/{osv.id}")
                return False
    return True


def parse_release_entries(cve, release, entries, affected):
    for entry in entries:
        logger.debug(f"{cve.id} {release} {entry.pkg} {entry.status}")
        source_pkg = entry.pkg
        fixed_version = None
        binaries = None

        if entry.note and entry.note[0].isdigit():
            fixed_version = Version(entry.note)
            logger.debug(f"fixed_version: {fixed_version}")

        if entry.status == "DNE":
            continue
        elif entry.status == "ignored":
            if release.is_esm and release.get_oldest_parent().is_active:
                logger.debug(f"{release} status is ignored but parent is active, SKIPPING")
                continue
            elif not release.is_active:
                logger.debug(f"{release} status is ignored, SKIPPING")
                continue
            fixed_version = None
            binaries = None
        elif entry.status in ["not-affected", "released"]:
            if not fixed_version:
                logger.debug(f"No fixed version for {release}, SKIPPING")
                continue
            elif fixed_version not in source_pkg.get_release_source_versions(release):
                logger.debug("Fixed version from previous release or parent, SKIPPING")
                continue
            elif fixed_version in source_pkg.get_release_source_versions(release.parent):
                logger.debug("Fixed version from parent, SKIPPING")
                continue
            else:
                binaries = source_pkg.binaries[release][fixed_version]
        elif entry.status in ["deferred", "needed", "needs-triage", "pending"]:
            if not release.is_active:
                logger.error(f"{cve} has {release} with status {entry.status}, SKIPPING")
                continue
            if release.is_esm and release.get_oldest_parent().is_active:
                logger.debug("Avoid adding {release} because parent is active, SKIPPING")
                continue
            fixed_version = None
            binaries = None
        else:
            logger.critical("Unknown status {entry.status}")
            sys.exit(1)

        affected.append(Affected(release, source_pkg, fixed_version, binaries, cve.priority, cve.priority_reason))


def usn2osv(output_path, usn):
    affected = []
    osv = None
    for release in usn.get_releases():
        logger.debug(f"{usn.id} {release}")
        published = datetime.utcfromtimestamp(usn.timestamp).isoformat() + "Z"
        modified = None
        binaries = None
        for source_pkg, fixed_version in usn.get_package_info_affecting_release(release):
            if release not in source_pkg.binaries or fixed_version not in source_pkg.binaries[release]:
                logger.debug(f"retrieving raw binaries {usn.id} {release} {source_pkg} {fixed_version}")
                binaries = usn.get_raw_binaries(release, source_pkg.name)
            else:
                binaries = source_pkg.binaries[release][fixed_version]

            affected.append(Affected(release, source_pkg, fixed_version, binaries))

        if not osv:
            related = []
            aliases = []
            for cve in sorted(usn.cves):
                related.append(cve.id)
                related.append('UBUNTU-' + cve.id)
            osv = OSV(
                'USN-' + usn.id,
                usn.description,
                published,
                modified,
                sorted(usn.cves),
                sorted(usn.lp_bugs),
                summary=usn.summary,
                related=related,
                aliases=aliases,
            )
        osv.affected = affected

    if osv:
        path = prepare_output_dir(output_path, "ubuntu", "osv", "usn")
        if verify_data_modified(path, osv):
            write_osv(path, osv)

    return 0


def cve2osv(output_path, cve, supported_releases):
    osv = None
    subproject_affected = {}
    packages = cve.pkg_entries
    if not packages:
        return

    published = cve.get_public_date() + "Z"
    modified = datetime.utcnow().isoformat(timespec="seconds") + "Z"

    # create main OSV structure
    related = [cve.id]
    aliases = []
    osv = OSV(
        'UBUNTU-' + cve.id,
        cve.description,
        published,
        modified,
        [cve],
        cve.references,
        severity=cve.cvss,
        related=related,
        aliases=aliases,
    )

    for release in cve.get_releases():
        if release not in supported_releases['osv']:
            continue
        subproject = None
        # if release has a progenitor then group together
        if release.get_oldest_parent():
            subproject = release.get_oldest_parent().product
        else:
            subproject = release.product
        if subproject not in subproject_affected:
            subproject_affected[subproject] = []
        parse_release_entries(cve, release, cve.get_entries_affecting_release(release), subproject_affected[subproject])

    for subproject in subproject_affected:
        if not subproject_affected[subproject]:
            continue
        osv.affected = subproject_affected[subproject]
        path = prepare_output_dir(output_path, subproject, "osv", "cve", cve.id.split('-')[1])
        if verify_data_modified(path, osv):
            write_osv(path, osv)

    return 0

def lsn2osv(output_path, lsn):
    logger.debug(f'Processing {lsn.id}')

    osv = None
    affected = []
    published = datetime.utcfromtimestamp(lsn.timestamp).isoformat() + "Z"
    modified = None
    related = []
    for cve in sorted(lsn.cves):
        related.append(cve.id)
        related.append('UBUNTU-' + cve.id)
    references = []

    for release in lsn.releases:
        for fixed_release, source_pkg, fixed_version, module_name_regex in lsn.get_fixed_info_affecting_release(release):
            affected_obj = Affected(
                fixed_release, source_pkg, fixed_version, None,
                module_name_regex=module_name_regex
            )
            affected.append(affected_obj)

    osv = OSV(
        id=lsn.id,
        description=lsn.description,
        published=published,
        modified=modified,
        cves=sorted(lsn.cves),
        references=references,
        related=related,
        summary=lsn.title
    )
    osv.affected = affected

    if osv:
        path = prepare_output_dir(output_path, "ubuntu", "osv", "lsn")
        write_osv(path, osv)

    return 0
