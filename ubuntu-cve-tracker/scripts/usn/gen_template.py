#!/usr/bin/python3
# -*- coding: utf-8 -*-
# Module containing functions for generating the template yaml files
# of Ubuntu Security Notices (USNs)
#
# Author: Nick Galanis <nick.galanis@canonical.com>
# Copyright (C) 2025 Canonical Ltd.
#
# This script is distributed under the terms and conditions of the GNU General
# Public License, "Version" 3 or later. See http://www.gnu.org/copyleft/gpl.html
# for details.
#
#!/usr/bin/env python3
import argparse
import json
import os
import requests
import textwrap
import yaml
from collections import defaultdict

from utils import get_binaries_dict, UCT, usn_number, packages, new_usn_dir, print_info, print_error, print_success, clean_usn_description
from datalib import uct_storage

CACHE_PATH = os.path.join(UCT, 'scripts/usn/templates/usn_embeddings.pt')
USN_DB = os.path.expanduser('~/.cache/usn/database-all.json')
class LiteralStr(str): pass

def literal_str_representer(dumper, data):
    return dumper.represent_scalar('tag:yaml.org,2002:str', data, style='|')

yaml.add_representer(LiteralStr, literal_str_representer)

def suggest_usn_desc(cve_id, cve_description):
    import torch
    from sentence_transformers import SentenceTransformer, util

    # Load transformer
    model = SentenceTransformer("all-MiniLM-L6-v2")
    try:
        with open(USN_DB, "r") as f:
            usn_data = json.load(f)
    except:
        print_error("USN DB not available. Use: $UCT/scripts/fetch-db database-all.json.bz2")
        exit(1)

    usn_paragraphs = []

    for _, info in usn_data.items():
        full_desc = info["description"]
        cleaned_paragraphs = clean_usn_description(full_desc)
        usn_paragraphs.extend(cleaned_paragraphs)

    # Check for cached embeddings
    if os.path.exists(CACHE_PATH):
        print_info("Loading cached embeddings...")
        usn_embeddings = torch.load(CACHE_PATH, map_location='cpu')
    else:
        print_info("Computing embeddings (this might take a minute)...")
        usn_embeddings = model.encode(usn_paragraphs, convert_to_tensor=True)
        torch.save(usn_embeddings, CACHE_PATH)

    query_embedding = model.encode(cve_description, convert_to_tensor=True)
    usn_embeddings = usn_embeddings.to(query_embedding.device)
    cos_scores = util.pytorch_cos_sim(query_embedding, usn_embeddings)[0]
    top_idx = torch.argmax(cos_scores).item()
    return usn_paragraphs[top_idx] + f" ({cve_id})"  + "\n\n"  


def generate_desc_yaml(packages, cves, output=None, one_cve=False, suggest=False):
    """
    Generate a yaml containing all the USN metadata
    """
    print_info("Generating template.yaml...")
    if not usn_number:
        print_error("Please specify a USN number (export USN=XXXX-Y) before running this script")
        exit(1)

    if output == None:
        output = f"USN-{usn_number}-template.yaml"

    # Load the template USN file
    template_file = os.path.join(UCT, 'scripts/usn/templates/usn_template.yaml')
    with open(template_file) as f:
        desc_yaml = yaml.safe_load(f)

    # Load the package info overrides file
    overrides_file = os.path.join(UCT, 'meta_lists/package_info_overrides.json')
    with open(overrides_file, "r") as file:
        override_data = json.load(file)

    # Create a text with these descriptions to incorporate to current template text
    cves_desc_stream = "XXX-ISSUE-DESCRIPTION-HERE-XXX\n\n"
    suggested_desc = ""
    if suggest:
        suggested_desc = "XXX The following is just a suggestion. Please edit before you publish XXX\n\n"
        cve_storage = uct_storage.UCTCVEStorage()
        for cve_id in cves:
            cve_storage.load_cve(cve_id)
            cve = cve_storage.get_cve(cve_id, with_pkg_links=False)
            if cve:
                cve_desc = cve.description
                suggested_desc += suggest_usn_desc(cve_id, cve_desc)
    elif cves:
        cves_desc_stream = "XXX Original CVE descriptions given above. Please edit according to USN guidelines before you publish XXX\n\n"        
        cve_storage = uct_storage.UCTCVEStorage()
        for cve_id in cves:
            cve_storage.load_cve(cve_id)
            cve = cve_storage.get_cve(cve_id, with_pkg_links=False)
            if cve:
                cves_desc_stream += f"{yaml.safe_load(cve.description)} ({cve.id})\n\n"
        paragraphs = cves_desc_stream.split('\n\n')
        cves_desc_stream = '\n\n'.join(textwrap.fill(p, width=75) for p in paragraphs)

    source_packages = ""
    for package in packages:
        source_packages += package + ", "
    source_packages = source_packages[0:-2]

    # Try to load the package's upstream name from our metadata
    try:
        upstream_packages = ""
        for package in packages:
            upstream_packages += override_data[package]['title'] + ", "
        upstream_package = upstream_packages[0:-2]
    except:
        print_error(f"WARNING: No entry found in package_info for {source_packages}, please change the upstream name in the USN's title")
        upstream_package = source_packages


    # If it is an regression/addition USN, recover information about the original USN.
    regression_usn = False
    origin = ""
    original_desc = "XXX-ORIGINAL-USN-DETAILS-HERE-XXX\n"
    original_action = ""
    original_sum = ""
    if not usn_number.endswith('-1'):
        regression_usn = True
        origin = usn_number.split('-')[0] + "-1"
        url_previous_usn = (f'https://raw.githubusercontent.com/canonical/ubuntu-security-notices/refs/heads/main/usn/{origin}.json')
        r = requests.get(url_previous_usn)
        if r.status_code == 200:
            data = r.json()
            original_desc = textwrap.indent(data['description'], " ")
            original_action = data['action']
            original_sum = data['summary'] + "\n\n"

    # Generate the template output YAML file containing all the gathered information
    output_yaml = {}

    # For each type of USN, replace placeholder text with data recovered previously
    if regression_usn:
        # TODO: fix format of desc
        output_yaml['description'] = LiteralStr(desc_yaml['description']['regression'].replace("XXX-ORIGINAL-USN-DETAILS-HERE-XXX", original_desc))
        output_yaml['title'] = LiteralStr(f"{upstream_package} regression")
        output_yaml['isummary'] = LiteralStr(f"USN-{origin} introduced a regression in {upstream_package}")
        output_yaml['summary'] = LiteralStr(f"{source_packages} regression")
        output_yaml['action'] = LiteralStr(original_action)
    else:
        if len(cves_desc_stream) > 0 and (not suggest):
            output_yaml['description'] = LiteralStr(desc_yaml['description']['regular'].replace("XXX-ISSUE-DESCRIPTION-HERE-XXX\n\n", cves_desc_stream))
            output_yaml['description'].replace("XXX-APP-XXX", source_packages)
        elif suggest:
            output_yaml['description'] = LiteralStr(desc_yaml['description']['regular'].replace("XXX-ISSUE-DESCRIPTION-HERE-XXX\n\n", suggested_desc))

        vulns = "vulnerability" if (one_cve or (cves is not None and len(cves) == 1)) else "vulnerabilities"

        output_yaml['title'] = LiteralStr(f"{upstream_package} {vulns}")
        output_yaml['summary'] = LiteralStr(f"{source_packages} {vulns}")

        output_yaml['isummary'] = LiteralStr(original_sum + desc_yaml['isummary'].replace("XXX-APP-XXX", upstream_package))
        output_yaml['action'] = LiteralStr(desc_yaml['action'].replace("XXX-APP-XXX", source_packages))
    
    output_yaml['id'] = usn_number

    os.makedirs(new_usn_dir, exist_ok=True)
    with open(os.path.join(new_usn_dir, output), 'w') as o:
        yaml.dump(output_yaml, o, allow_unicode=True, sort_keys=False)

    print_success(f"Please edit the template file present in {os.path.join(new_usn_dir, output)} with the USN metadata (description, summary etc)")

def generate_binaries_yaml(packages, ppas, releases):
    """
    Generate a yaml file for the user to edit with the minimum binaries of the package that are affected by this USN
    """
    # get binaries metadata
    print_info("Loading USN binaries from Launchpad...")
    _, binaries_dict = get_binaries_dict(packages, releases, ppas)
    # keep only the name of the binaries for editing

    only_names = defaultdict(list)

    for package, releases in binaries_dict.items():
        for release, packages in releases.items():
            for package_name in packages.keys():
                only_names[release].append(package_name)

    only_names = dict(only_names) 
    output_yaml_path = f"minimum_binaries-{usn_number}.yaml"
    with open(os.path.join(new_usn_dir, output_yaml_path), 'w') as yaml_file:
        yaml.dump(only_names, yaml_file, default_flow_style=False)

    print_success(f"Please edit the file with the minimum binaries present in {os.path.join(new_usn_dir, output_yaml_path)}")

if __name__ == "__main__":

    parser = argparse.ArgumentParser(description="Generate a YAML file to be edited for inclusion of the details and metadata of a USN.")
    parser.add_argument('--output', type=str, help='a file path to output the data to.', default=None)
    parser.add_argument("--one-cve", action="store_true", help="Use if you are generating a USN for only one CVE (not needed if you are generating with --suggest)")
    parser.add_argument("--ppas", help="comma separated list of PPAs that will be present in the USN. (optional, only for specifying PPAs. By default, all staging PPAs are scanned)", default=None)
    parser.add_argument("--releases", help="comma separated list of supported Ubuntu releases that will be present in the USN. (optional, only for specifying releases. By default all the published releases are scanned)", default=None)
    parser.add_argument("--cves", help="comma separated list of CVEs present in the USN (optional, only if you want the tooling to suggest a description.)", default=None)
    parser.add_argument("-s", "--suggest", help="Suggest a USN description, by comparing the CVE with previous USNs published (experimental)", action="store_true")

    args = parser.parse_args()

    if args.ppas:
        ppas = args.ppas.split(',')
    else:
        ppas = None
    if args.releases:
        releases = args.releases.split(',')
    else:
        releases = None
    if args.cves:
        cves = args.cves.split(',')
    else:
        if args.suggest:
            print_error("You need to specify --cves if you want the tooling to suggest a description")
            exit(1)
        else:
            cves = None

    generate_desc_yaml(packages, cves, args.output, args.one_cve, args.suggest)
    generate_binaries_yaml(packages, ppas, releases)
