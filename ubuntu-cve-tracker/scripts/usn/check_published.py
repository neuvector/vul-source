# -*- coding: utf-8 -*-
# Module containing functions for checking if a package has landed in the
# Ubuntu Mirrors (ESM or archive)
#
# Author: Nick Galanis <nick.galanis@canonical.com>
# Copyright (C) 2025 Canonical Ltd.
#
# This script is distributed under the terms and conditions of the GNU General
# Public License, "Version" 3 or later. See http://www.gnu.org/copyleft/gpl.html
# for details.
#

import argparse
import hashlib
import json
import os
import requests

def check_esm_links(release, pkg, version, pocket, verbose=False):
    """
    In case of an ESM release, we are going to search the package details in the Packages file from esm.ubuntu.com
    We want to make sure that every binary package there has the correct version.
    """

    url = f"https://esm.ubuntu.com/{pocket}/ubuntu/dists/{release}-{pocket}-security/main/binary-amd64/Packages"
    # Download the file
    try:
        response = requests.get(url)
        response.raise_for_status()
        packages_data = response.text
    except requests.RequestException as e:
        print(f"❌ Error fetching Packages file: {e}")
        return False

    # Get access to the package entries
    entries = packages_data.split("\n\n")
    matching_versions = set()

    # Manually try to find the binary package requested
    for entry in entries:
        lines = entry.strip().splitlines()
        pkg_info = {}
        for line in lines:
            if ": " in line:
                key, value = line.split(": ", 1)
                pkg_info[key] = value
        if pkg_info.get("Package") == pkg:
            found_version = pkg_info.get("Version")
            if found_version:
                matching_versions.add(found_version)

    # there should be only one entry for that package, with one version, the new one
    if len(matching_versions) == 1 and (version in matching_versions):
        if verbose:
            print(f"✅ Package '{pkg}' with version '{version}' is valid in {release}-esm.")
        return True
    else:
        print(f"❌ Package '{pkg}' version '{version}' not yet valid in {release}-esm.")
        return False


def check_non_esm_urls(archs_data, verbose=False):
    """
    In case of a normal release, the links for each binary are present in the USN, along with the size and the MD5 hash this
    binary file should have. Thus, we want to process all of them and confirm that they have landed and that they are active.
    """

    all_valid = True
    # Parse all the binaries
    for arch, arch_data in archs_data.items():
        urls = arch_data.get("urls", {})
        for url, metadata in urls.items():
            # and get access to their expected data
            expected_md5 = metadata.get("md5")
            expected_size = metadata.get("size")

            # try to request the file from the mirrors
            try:
                response = requests.get(url, timeout=5)
                if response.status_code != 200:
                    print(f"❌ URL returned status code {response.status_code}")
                    all_valid = False
                    continue

                # Verify that the size and md5 matches
                actual_size = len(response.content)
                actual_md5 = hashlib.md5(response.content).hexdigest()

                if actual_size != expected_size:
                    print(f"❌ Size mismatch for {url}! Expected {expected_size}, got {actual_size}")
                    all_valid = False
                else:
                    if verbose:
                        print(f"✅ Size OK ({actual_size} bytes)")

                if actual_md5 != expected_md5:
                    print(f"❌ MD5 mismatch for {url}! Expected {expected_md5}, got {actual_md5}")
                    all_valid = False
                else:
                    if verbose:
                        print(f"✅ MD5 OK ({actual_md5})")

            except Exception as e:
                print(f"❌ Error downloading URL: {url} – {e}")
                all_valid = False

    return all_valid

def check_usn_links(filepath, verbose):
    """
    Check that every link mentioned in the USN has landed successfully to the Mirrors.
    """
    with open(filepath) as f:
        data = json.load(f)

    releases = data.get("releases", {})
    for release_name, release_info in releases.items():
        if verbose:
            print(f"Processing release: {release_name}")
        found = False
        # if we don't have an "archs" element, then we're processing an ESM release
        if "archs" not in release_info:
            allbinaries = release_info.get("allbinaries", {})
            for pkg_name, pkg_data in allbinaries.items():
                version = pkg_data.get("version")
                pocket = pkg_data.get("pocket")[4:]
                found = check_esm_links(
                    release=release_name,
                    pkg=pkg_name,
                    version=version,
                    pocket=pocket,
                    verbose=verbose
                )
        # otherwise, in case of a non-ESM release, read the links provided in the USN
        else:
            archs = release_info.get("archs", {})
            found = check_non_esm_urls(archs, verbose=verbose)

        # if at least one release fails, exit
        if found == False:
            if verbose:
                print(f"❌ Failed to find all the links for {release_name}")
            return False

    if verbose:
        print("✅ All links found!")
    return True

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Check if all the binaries in a USN have mirrored.")
    parser.add_argument("--verbose", action="store_true", help="Verbose execution")
    args = parser.parse_args()

    usn_number = os.environ.get("USN")
    if usn_number is None:
        print("ERROR: Please specify a USN number with export USN=XXX-Y")
        exit(1)

    usn_json_file = f"{usn_number}.json"

    result = check_usn_links(usn_json_file, args.verbose)
    print("\nResult:", "FOUND" if result else "NOT FOUND")