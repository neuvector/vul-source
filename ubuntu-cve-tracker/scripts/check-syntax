#!/usr/bin/env python3

# Author: Kees Cook <kees@ubuntu.com>
# Author: Jamie Strandboge <jamie@ubuntu.com>
# Author: Marc Deslauriers <marc.deslauriers@canonical.com>
# Copyright (C) 2005-2020 Canonical Ltd.
#
# This script is distributed under the terms and conditions of the GNU General
# Public License, Version 2 or later. See http://www.gnu.org/copyleft/gpl.html
# for details.

# Set CVE_ALLOW_NEWER_PKGS=1 to skip new package checks
from __future__ import print_function

import datetime
import glob
import optparse
import os
import pprint
import re
import sys
import subprocess
import signal
import concurrent.futures
import multiprocessing
import shutil

import cve_lib
import kernel_lib
import usn_lib

import source_map

# add to this list when adding tracking for kernels that have not been
# published to updates/security yet. Once published, can be removed
# (script should warn about that). If a kernel is published in one
# release, but not yet in another release, add the unpublished release
# after a '/' e.g. 'linux-aws/trusty'
unpublished_kernels = [
    "linux-bluefield/jammy",  # linux-bluefield/jammy is coming, apparently
    "linux-gkeop/oracular", # not in archive but repo exists, probably coming

    # used for building a snap, not intended for
    # the main archive, see the deletion record in
    # https://launchpad.net/ubuntu/+source/linux-intel/+publishinghistory
    "linux-intel/noble",
]

required_fields = [
    'Candidate',
    'Description',
    'Priority',
    'PublicDate',
    'Ubuntu-Description',
]

def CVEs_from_CNA():
    """Returns a dict of CVEs assigned from the README in the embargoed cna
    directory, using a space and text after CVE-NNNN-NNNN as indicator of
    which CVEs have been assigned. For each CVE in the dict, the value is a
    list containing the filename and line number where this was sourced
    from.
    """
    lines = []
    # Assumes embargoed symlink/ exists in parent directory and points to
    # ../embargoed/cves/
    cna_source = os.path.realpath(
        os.path.join(
            os.path.dirname(os.path.dirname(os.path.realpath(__file__))),
            "embargoed", "..", "cna", "README"))
    try:
        f = open(cna_source)
        lines = f.readlines()
        f.close()
    except IOError as e:
        print("Ignoring CNA sanity checks: %s\n" % e, file=sys.stderr)
        return {}

    # Assumes any text after CVE-NNNN-NNNN means "assigned"
    # Note the space is important, used for split(" ") later
    assigned_cves = re.compile(r"^(CVE-\d\d\d\d-\d{4,7}) .+")

    def find_assigned_cves(line):
        if "REJECTED" in line:
            return None
        if "IGNORED" in line:
            return None
        match = assigned_cves.match(line)
        if match:
            return match.group(1)
        return None

    cves = {}
    linenum = 1
    for line in lines:
        cve = find_assigned_cves(line)
        if cve:
            cves[cve] = [cna_source, linenum]
        linenum += 1
    return cves


def ever_existed(pkg):
    for rel in source:
        if pkg in source[rel]:
            return True
    return False


def is_active(cvepath):
    return cvepath.startswith(cve_lib.active_dir)


def is_embargoed(cvepath):
    return cvepath.startswith(cve_lib.embargoed_dir)


def is_retired(cvepath):
    return cvepath.startswith(cve_lib.retired_dir)


def is_boilerplate(cvepath):
    return cvepath.startswith(cve_lib.boilerplates_dir)

def is_unpublished_kernel(kernel, release=None, debug=False):
    for u in unpublished_kernels:
        unpub = u.split("/")
        if debug:
            print("Checking %s/%s against %s" % (kernel, release, unpub))
        if unpub[0] == kernel and (
            len(unpub) == 1 or (len(unpub) == 2 and unpub[1] == release)
        ):
            return True
    return False

def build_aliases_cache(sources):
    rev_aliases = {}

    for rel in sources:
        for pkg in sources[rel]:
            if 'aliases' in sources[rel][pkg]:
                for alias in sources[rel][pkg]['aliases']:
                    if rel not in rev_aliases:
                        rev_aliases[rel] = {}
                    if alias not in rev_aliases[rel]:
                        rev_aliases[rel][alias] = []
                    rev_aliases[rel][alias].append(pkg)

    return rev_aliases

def get_pkgs_from_aliases(aliases, pkg, rel):
    if rel in aliases:
        if pkg in aliases[rel]:
            return aliases[rel][pkg]
    return []

def subprocess_setup():
    # Python installs a SIGPIPE handler by default. This is usually not what
    # non-Python subprocesses expect.
    signal.signal(signal.SIGPIPE, signal.SIG_DFL)


def cmd(
    command,
    input=None,
    stderr=subprocess.STDOUT,
    stdout=subprocess.PIPE,
    stdin=None,
    timeout=None,
):
    """Try to execute given command (array) and return its stdout, or return
    a textual error if it failed."""

    try:
        sp = subprocess.Popen(
            command,
            stdin=stdin,
            stdout=stdout,
            stderr=stderr,
            close_fds=True,
            preexec_fn=subprocess_setup,
            universal_newlines=True,
        )
    except OSError as e:
        return [127, str(e)]

    out, outerr = sp.communicate(input)
    # Handle redirection of stdout
    if out is None:
        out = ""
    # Handle redirection of stderr
    if outerr is None:
        outerr = ""
    return [sp.returncode, out + outerr]


def get_bzr_filelist():
    rc, report = cmd(["bzr", "stat", "-S"])

    file_list = []
    for line in report.splitlines():
        if len(line.split()) == 2:
            if line.split()[0] != "D":
                file_list.append(line.split()[1])

    return file_list


def get_git_filelist():
    rc, report = cmd(["git", "diff", "--name-only", "--diff-filter=AM", "HEAD"])

    return report.splitlines()


def cve_lib_consistency_checks():
    # add additional consistency check calls here, if need be
    kernel_lib.meta_kernels.consistency_check()


parser = optparse.OptionParser(usage="%prog [options] [file ...]")
parser.add_option(
    "-v",
    "--verbose",
    help="Enable verbose reporting",
    action="store_true",
    default=False,
)
parser.add_option(
    "-d", "--debug", help="Enable debug reporting", action="store_true", default=False
)
parser.add_option(
    "-u", "--usn-db", dest="usndb", help="Enable USN database on DB", metavar="DB"
)
parser.add_option(
    "-n",
    "--newer",
    help="Allow versions newer than what is in the archive",
    action="store_true",
    default=False,
)
parser.add_option(
    "-s",
    "--strict",
    help="Be extra strict in syntax",
    action="store_true",
    default=False,
)
parser.add_option(
    "-f", "--filelist", help="Read the list of files to check from the specified input file", metavar="FILE"
)
parser.add_option(
    "-m",
    "--modified",
    help="Only check modified files",
    action="store_true",
    default=False,
)
parser.add_option(
    "-a",
    "--autofix",
    help="Attempt to fix problems automatically",
    action="store_true",
    default=False,
)
parser.add_option(
    "--dry-run",
    help="Dry run for autofix parameter",
    action="store_true",
    default=False,
)
parser.add_option(
    "-j",
    "--jobs",
    type=int,
    help="Number of jobs to run simultaneously (default: %d)" % multiprocessing.cpu_count(),
    default=multiprocessing.cpu_count(),
)
parser.add_option(
    "--stdin",
    help="Check the contents of stdin instead of a filelist or modified files etc",
    action="store_true",
    default=False,
)

# parser.add_option("-c", "--cna", help="Ensure every CVE assigned by Canonical's CNA has an entry", action='store_true')
(opt, args) = parser.parse_args()

source = source_map.load(detailed=opt.strict)
if cve_lib.devel_release:
    dev_proposed = source_map.load(pockets=["-proposed"], releases=[cve_lib.devel_release], detailed=opt.strict)

if opt.debug:
    pp = pprint.PrettyPrinter(indent=4)

def debug(args):
    if opt.debug:
        pp.pprint(args)


warned_kernels = []
esm_warned = False
kev = {}
all_okay = True

cve_lib_consistency_checks()

cves = dict()
if opt.usndb:
    usn_db = usn_lib.load_database(opt.usndb)
    reverted = usn_lib.get_reverted()

    # create a dictionary of key=CVE value=USNs
    for usn in usn_db:
        if "cves" not in usn_db[usn]:
            continue
        for cve in usn_db[usn]["cves"]:
            if not cve.startswith("CVE-"):
                continue
            if usn in reverted and cve in reverted[usn]:
                continue
            if cve not in cves:
                cves[cve] = []
                cves[cve].append(usn)
            else:
                cves[cve].append(usn)

check_dirs = [cve_lib.active_dir, cve_lib.retired_dir, cve_lib.ignored_dir]
if os.path.islink(cve_lib.embargoed_dir):
    check_dirs.append(cve_lib.embargoed_dir)

debug("check_dirs %s" % check_dirs)

all_files = True
if opt.stdin:
    debug("Using /dev/stdin as input")
    args = ["/dev/stdin"]
    all_files = False
elif len(args) == 0:
    if opt.filelist:
        debug("Using filelist %s" % opt.filelist)

        all_files = False
        with open(opt.filelist) as fh:
            cves = []
            for line in fh.readlines():
                for dir in check_dirs:
                    for d in [dir, os.path.relpath(dir)]:
                        if line.startswith("%s/CVE-" % d):
                            cves += [line.rstrip()]
                            break
            if len(cves) == 0:
                print("WARNING: No CVEs found in specified filelist %s" % opt.filelist, file=sys.stderr)
            else:
                args += cves
    elif opt.modified:
        debug("Checking modified files only")

        all_files = False

        if os.path.exists(".git"):
            file_list = get_git_filelist()
        else:
            file_list = get_bzr_filelist()

        for filename in file_list:
            filename = os.path.join(os.getcwd(), filename)
            for dir in check_dirs:
                if filename.startswith("%s/CVE-" % dir):
                    args += [filename]
                    continue
            if is_boilerplate(filename):
                args += [filename]

    else:
        bps = glob.glob("%s/*" % cve_lib.boilerplates_dir)
        rc, report = cmd(["git", "check-ignore"] + bps)
        if rc == 0:
            bps = set(bps) - set(report.splitlines())
        for bp in sorted(bps):
            args += [bp]

        for dir in check_dirs:
            cves = glob.glob("%s/CVE-*" % dir)
            rc, report = cmd(["git", "check-ignore"] + cves)
            if rc == 0:
                cves = set(cves) - set(report.splitlines())
            for cve in sorted(cves):
                args += [cve]

else:
    all_files = False

debug("args %s" % args)

ignored = cve_lib.parse_CVEs_from_uri("%s/not-for-us.txt" % cve_lib.ignored_dir)

debug("ignored %s" % ignored)

# Build up the cache of subproject CVEs
cve_lib.build_subproject_dir_cache()

cna_cves_set = CVEs_from_CNA()
# Just run this if we're not specifying specific CVEs
if len(cna_cves_set) > 0 and all_files:
    cve_name_re = re.compile(r"(CVE-\d\d\d\d-\d{4,7})$")

    def filter_cves(fname):
        return re.search(cve_name_re, fname)

    def find_cves(fname):
        m = re.search(cve_name_re, fname)
        if m:
            return m.group(1)
        else:
            print("unmatched %s\n" % fname, file=sys.stderr)

    ignored_set = set(ignored)
    args = {find_cves(name) for name in filter(filter_cves, args)}

    debug("cna_cves_set: %s\n" % cna_cves_set)
    debug("ignored_set: %s\n" % ignored_set)
    debug("args: %s" % args)

    # if we ever assign a CVE then ignore it (vbulletin comes to mind...)
    # we can use the "IGNORED" tag to skip these checks
    martians = cna_cves_set.keys() & ignored_set
    for cve in martians:
        print("%s: %d: %s that we assigned is now IGNORED.\n"
              % (cna_cves_set[cve][0], cna_cves_set[cve][1], cve))

    too_private = cna_cves_set.keys() - args
    for cve in too_private:
        print("%s: %d: %s that we assigned needs an UCT entry.\n"
              % (cna_cves_set[cve][0], cna_cves_set[cve][1], cve))

aliases_cache = build_aliases_cache(source)

def fixup_entry(filename, pkg, rel):
    # If release is devel or EOL, we should add the proper status instead of removing
    if rel == cve_lib.devel_release:
        rel = "devel"
        if opt.dry_run:
            print("Dry-Run: updating %s, %s, devel to DNE" % (filename, pkg))
            return
        cve_lib.update_state(filename, pkg, "devel", "DNE")
    elif not cve_lib.is_active_release(rel):
        if cve_lib.is_active_esm_release(rel):
            status = cve_lib.EOL_ESM_STATUS.format(state='unknown')
        else:
            status = cve_lib.EOL_STATUS.format(state='unknown')

        if opt.dry_run:
            print("Dry-Run: updating %s, %s, %s to %s" % (filename, pkg, rel, status))
            return
        cve_lib.update_state(filename, pkg, rel, status)

    else:
        if opt.dry_run:
            print("Dry-Run: dropping %s, %s, %s" % (filename, pkg, rel))
            return
        cve_lib.drop_pkg_release(filename, pkg, rel)

def fixup_entry_state(filename, pkg, rel, state):
    if opt.dry_run:
        print("Dry-Run: updating %s, %s, %s to %s" % (filename, pkg, rel, state))
        return

    cve_lib.update_state(filename, pkg, rel, state)

def fixup_entry_get_status(filename, pkg, rel):
    # get status from the parent release if there is one
    status = "needs-triage"
    try:
        _, _, _, details = cve_lib.get_subproject_details(rel)
        parent = details["parent"]
        # this may be either an alias or a full name but cve_lib only
        # uses aliases
        parent = cve_lib.release_alias(parent)
        data = cve_lib.load_cve(filename)
        status = data["pkgs"][pkg][parent][0]
        note = data["pkgs"][pkg][parent][1]
        if len(note) > 0:
            status = status + " (" + note + ")"
        # if parent reached EOL then we are likely the new alive
        # release so ignore their status in that case
        if "end of life" in status or "end of standard support" in status:
            status = 'needs-triage'
    except (KeyError, ValueError, TypeError):
        pass

    return status

def fixup_entry_missing(filename, pkg, rel):
    status = fixup_entry_get_status(filename, pkg, rel)

    if rel == cve_lib.devel_release:
        rel = "devel"

    if opt.dry_run:
        print("Dry-Run: Adding %s, %s, %s to %s" % (filename, pkg, rel, status))
        return

    cve_lib.add_state(filename, pkg, rel, status)

def fixup_entry_wrong(filename, pkg, rel):
    status = fixup_entry_get_status(filename, pkg, rel)

    if rel == cve_lib.devel_release:
        rel = "devel"

    if opt.dry_run:
        print("Dry-Run: updating %s, %s, %s to %s" % (filename, pkg, rel, status))
        return

    cve_lib.update_state(filename, pkg, rel, status, None)

def fixup_entry_missing_break_fix(filename, pkg, ref):
    urls = cve_lib.fetch_kernel_fixes(ref)
    urls = cve_lib.validate_kernel_fixes(urls)

    for url in urls:
        # convert to the break-fix format as a string
        url = " ".join(url)
        if opt.dry_run:
            print("Dry-Run: adding break-fix %s, %s, to %s" % (filename, pkg, url))
            return

        cve_lib.add_patch(filename, pkg, url, "break-fix")
    cve_lib.add_tag(filename, pkg, "review-break-fix")

def fixup_priority(filename, priority):
    if opt.dry_run:
        print("Dry-Run: setting priority %s to %s" % (filename, priority))
        return

    cve_lib.update_field(filename, "Priority", priority)

def fixup_assignedto(filename):
    if opt.dry_run:
        print("Dry-Run: clearing assigned-to in %s" % filename)
        return

    cve_lib.update_field(filename, "Assigned-to", "")

def fixup_entry_missing_tag(filename, pkg, tag):
    if opt.dry_run:
        print("Dry-Run: adding tag %s %s %s" % (filename, pkg, tag))
        return

    cve_lib.add_tag(filename, pkg, tag)

def fixup_rejected(filename):
    if opt.dry_run:
        print("Dry-Run: move %s to ignored/" % (filename))
        return

    shutil.move(filename, cve_lib.ignored_dir)

def get_cve_path(cve, rel):

    cve = os.path.basename(cve)
    if rel in cve_lib.external_releases:
        # FIXME: Should we also be using get_external_subproject_dir here?
        cvepath = os.path.join(
            cve_lib.get_external_subproject_cve_dir(rel), cve
        )
    else:
        # Try and find where this CVE is located
        for d in cve_lib.cve_dirs:
            cvepath = os.path.join(d, cve)
            if os.path.exists(cvepath):
                return cvepath
        # Fall back to the active directory if that didn't work?
        cvepath = os.path.join(cve_lib.active_dir, cve)
    return cvepath

def check_cve(cve):
    cve_okay = True
    srcmap = dict()
    # get the absolute path of the cve so that functions like is_boilerplate()
    # work as expected
    cve = os.path.abspath(cve)
    try:
        if opt.stdin:
            # fixup cve below once we have loaded it
            cvepath = cve
        else:
            # Try to locate the base CVE and load that, but not if this is a
            # boilerplate path
            if is_boilerplate(cve):
                cvepath = cve
                cve = os.path.basename(cve)
            else:
                cve = os.path.basename(cve)
                cvepath = cve_lib.find_cve(cve)
        data = cve_lib.load_cve(cvepath, opt.strict, srcmap=srcmap)
    except ValueError as e:
        print(e, file=sys.stderr)
        return False
    # get the real CVE if we are using stdin
    if opt.stdin:
        cve = data["Candidate"]
        cvepath = cve_lib.find_cve(cve)
    if cve in ignored:
        print(
            "%s: %d: duplicate CVE found in not-for-us.txt" % (cvepath, 1),
            file=sys.stderr,
        )
        cve_okay = False
    matches = set()
    for dir in [
        cve_lib.active_dir,
        cve_lib.retired_dir,
        cve_lib.ignored_dir,
        cve_lib.embargoed_dir,
    ]:
        if os.path.exists(os.path.join(dir, cve)):
            matches.add(dir)
    if len(matches) > 1:
        print(
            "%s: %d: found in multiple classes: %s"
            % (cvepath, 1, ", ".join(sorted(matches))),
            file=sys.stderr,
        )
        cve_okay = False

    # verify required fields are present
    for field in required_fields:
        if field not in data:
            print("%s: missing required field '%s'" % (cvepath, field), file=sys.stderr)
            cve_okay = False

    # verify candidate field matches the CVE file name but ignore if we don't have one
    if "stdin" not in cve and not is_boilerplate(cvepath) and not data["Candidate"] == cve:
        filename = srcmap["Candidate"][0]
        linenum = srcmap["Candidate"][1]
        print(
            "%s: %d: Candidate field '%s' mismatch with cve pathname '%s'"
            % (filename, linenum, data["Candidate"], cve),
            file=sys.stderr,
        )
        cve_okay = False

    # if a CVE has the cisa-kev tag then it should be prioritised at at least high
    # cisa-kev is a global / CVE-wide tag so key off of *
    pkg = cve_lib.GLOBAL_TAGS_KEY
    if pkg in data["tags"] and "cisa-kev" in data["tags"][pkg] \
       and is_active(cvepath) \
       and data["Priority"][0] != "high" and data["Priority"][0] != "critical":
            filename = srcmap["Priority"][0]
            linenum = srcmap["Priority"][1]
            print("%s: %d: priority should be 'high' or 'critical' not '%s' for an active CVE in the CISA KEV" % (filename, linenum, data["Priority"][0]), file=sys.stderr)
            if opt.autofix:
                fixup_priority(filename, "high")
            cve_okay = False

    supported = []
    for pkg in sorted(data["pkgs"].keys()):
        pkg_ever_existed = ever_existed(pkg)
        # Verify have required releases for each package
        listed_releases = set(sorted(data["pkgs"][pkg].keys()))
        all_required_releases = (set(cve_lib.all_releases + ["devel"]) - set([cve_lib.devel_release])) - set(cve_lib.eol_releases)
        aliases_releases = set()

        listed_series = set()
        for rel in listed_releases:
            if rel not in cve_lib.subprojects and rel != 'upstream':
                listed_series.add(rel)

        # Check aliases
        for rel in all_required_releases:
            if rel in cve_lib.external_releases:
                # for external releases skip boilerplates and embargoed CVEs
                if is_boilerplate(cvepath) or is_embargoed(cvepath):
                    continue

            if rel in source:
                skip_aliases = False
                if not 'soss' in rel:
                    _, series = cve_lib.product_series(rel)
                    # If the series is not listed in the original CVE,
                    # we won't create the CVE in the subproject.
                    if not is_active(cvepath) and series not in listed_series:
                        skip_aliases = True

                    # We are not adding CVEs in ignored.
                    if "ignored/" in cvepath:
                        skip_aliases = True

                if not skip_aliases:
                    aliases = False
                    pkgs_from_aliases = get_pkgs_from_aliases(aliases_cache, pkg, rel)
                    if pkgs_from_aliases:
                        aliases = True
                        aliases_releases.add(rel)

                        for pkg_alias in pkgs_from_aliases:
                            if pkg_alias not in data["pkgs"].keys():
                                filename = get_cve_path(cve, rel)
                                print(
                                    "%s: %s missing release '%s'"
                                    % (filename, pkg_alias, rel),
                                    file=sys.stderr,
                                )
                                if opt.autofix:
                                    fixup_entry_missing(filename, pkg_alias, rel)
                                cve_okay = False

                    # This package-release uses aliases,
                    # it shouldn't be listed
                    if aliases:
                        if rel in listed_releases and pkg \
                            not in pkgs_from_aliases:
                            filename = get_cve_path(cve, rel)
                            print(
                                "%s: package '%s' not in '%s'"
                                % (filename, pkg, rel),
                                file=sys.stderr,
                            )
        missing_releases = all_required_releases - listed_releases
        for rel in missing_releases:
            # only warn on active CVEs
            if is_active(cvepath) and \
               rel in source and pkg in source[rel]:

                # If the subproject doesn't require cve triage,
                # we shouldn't add any entries to the CVE
                if not cve_lib.is_cve_triage_required(rel): continue

                filename = get_cve_path(cve, rel)
                print(
                    "%s: %s missing release '%s'"
                    % (filename, pkg, rel),
                    file=sys.stderr,
                )
                if opt.autofix:
                    fixup_entry_missing(filename, pkg, rel)
                cve_okay = False
        unknown_releases = listed_releases - set(cve_lib.all_releases + ["devel", "upstream"])
        for rel in unknown_releases:
            filename = srcmap["pkgs"][pkg][rel][0]
            linenum = srcmap["pkgs"][pkg][rel][1]
            print(
                "%s: %d: %s unknown release '%s'"
                % (filename, linenum, pkg, rel),
                file=sys.stderr,
            )
            if opt.autofix:
                fixup_entry(filename, pkg, rel)
            cve_okay = False
        for release in sorted(data["pkgs"][pkg].keys()):
            rel = release
            filename = srcmap["pkgs"][pkg][release][0]
            linenum = srcmap["pkgs"][pkg][release][1]
            # warn if the cve file contains external subproject releases
            # and it is not located in the subprojects folder
            if rel in cve_lib.external_releases and filename == cvepath:
                print(
                    "%s: %d: external release '%s' listed in internal CVE file"
                    % (filename, linenum, rel),
                    file=sys.stderr,
                )
                cve_okay = False

            # Handle just after release, but before devel has opened
            if rel == "devel" and cve_lib.devel_release == "":
                continue

            # Adjust devel release name
            if rel == "devel":
                rel = cve_lib.devel_release

            # Don't syntax check upstream
            if rel == "upstream":
                continue

            details = data["pkgs"][pkg][release]
            state = details[0]

            if not cve_lib.is_active_release(release):
                if 'superseded by' not in details[1] and \
                 'replaced by' not in details[1] and \
                 'end of kernel support' not in details[1] and \
                 'end of standard support' not in details[1] and \
                 'end of ESM support' not in details[1] and \
                 'end of life' not in details[1]:
                    if ', was ' in details[1]:
                        old_state = details[1].split(', was ')[-1]
                    elif not cve_lib.EOL_ESM_STATUS[9:-14] in details[1] and \
                        not cve_lib.EOL_STATUS[9:-14] in details[1] and details[1]:
                        old_state = f'{details[0]} [{details[1]}]'
                    else:
                        old_state = ''

                    fixed_state = ''
                    product, series = cve_lib.product_series(release)
                    if release in cve_lib.interim_releases:
                        fixed_state = cve_lib.EOL_STATUS.format(state=old_state)
                    elif product == cve_lib.PRODUCT_UBUNTU:
                        fixed_state = cve_lib.EOL_LTS_STATUS.format(state=old_state)
                    elif product in cve_lib.PRODUCT_ESM:
                        fixed_state = cve_lib.EOL_ESM_STATUS.format(state=old_state)

                    if old_state == '':
                        fixed_state = fixed_state[:-7] + ')'

                    if state not in ['released', 'not-affected', 'DNE', 'ignored']:
                        print(
                            "%s: %d: %s incorrect status '%s' in '%s', try '%s'"
                            % (filename, linenum, pkg, state, rel, fixed_state),
                            file=sys.stderr,
                        )
                        if opt.autofix:
                            fixup_entry_state(filename, pkg, rel, fixed_state)
                        cve_okay = False
                    elif state == 'ignored':
                        if not details[1]:
                            continue
                        elif (f'ignored ({details[1]})' != fixed_state):
                            print(
                                "%s: %d: %s incorrect ignored detail '%s' for '%s', try '%s'"
                                % (filename, linenum, pkg, details[1], rel, fixed_state),
                                file=sys.stderr,
                            )
                            if opt.autofix:
                                fixup_entry_state(filename, pkg, rel, fixed_state)
                            cve_okay = False
                continue

            # Skip devel checks on retired CVEs
            if release == "devel":
                if "retired/" in cvepath:
                    # but first check to ensure that state is not open
                    if state in ["needed", "needs-triage", "pending"]:
                        print(
                            "%s: %d: retired but %s is listed as unfixed (%s) for '%s'"
                            % (filename, linenum, pkg, state, rel),
                            file=sys.stderr,
                        )
                        cve_okay = False
                    continue

            # Skip DNE's
            if state == "DNE":
                if pkg in source[rel]:
                    print(
                        "%s: %d: package '%s' DOES exist in '%s'"
                        % (filename, linenum, pkg, rel),
                        file=sys.stderr,
                    )
                    if opt.autofix:
                        fixup_entry_wrong(filename, pkg, rel)
                    cve_okay = False
                continue

            # Check for released-esm as it is not a valid state in UCT anymore
            if state == "released-esm":
                print(
                    "%s: %d: %s_%s has invalid state: '%s'"
                    % (filename, linenum, rel, pkg, state)
                )
                cve_okay = False

            if "esm" in release:
                if state == "released":
                    for r in set([cve_lib.release_parent(release), cve_lib.release_progenitor(release)]):
                        if data.get("pkgs", {}).get(pkg, {}).get(release) == data.get("pkgs", {}).get(pkg, {}).get(r):
                            cve_okay = False
                            print("%s: '%s': released (%s) for both '%s' and '%s'"% (cvepath, pkg,data.get("pkgs", {}).get(pkg, {}).get(release)[1], release, r ), file=sys.stderr)

            # check any notes have balanced parentheses
            if len(details) > 1:
                note = details[1]
                if note.count("(") != note.count(")"):
                    print(
                        "%s: %d: %s_%s has unbalanced parentheses in state annotation: '%s %s'"
                        % (filename, linenum, rel, pkg, state, note)
                    )
                    cve_okay = False

            # Check that package exists in a given release
            if not pkg_ever_existed:
                if is_active(cvepath) and not cve_lib.is_active_esm_release(release):
                    # forcibly skip linux-lts-backport packages and #
                    # other derived kernels since want to track them
                    # before they end up fully in the archive;
                    # additional kernels can be added to
                    # unpublished_kernels as needed
                    if pkg.startswith("linux-lts-") or is_unpublished_kernel(pkg, rel):
                        if opt.debug:
                            print(
                                "%s: %d: skipping unpublished kernel '%s'"
                                % (filename, linenum, pkg),
                                file=sys.stderr,
                            )
                        continue
                    print(
                        "%s: %d: unknown package '%s' in %s"
                        % (filename, linenum, pkg, rel),
                        file=sys.stderr,
                    )
                    if opt.autofix:
                        fixup_entry(filename, pkg, rel)
                    cve_okay = False
            else:
                if rel in source:
                    if pkg not in source[rel]:
                        if is_active(cvepath):
                            if is_unpublished_kernel(pkg, rel):
                                if opt.debug:
                                    print(
                                        "%s: %d: skipping unpublished kernel '%s'"
                                        % (filename, linenum, pkg),
                                        file=sys.stderr,
                                    )
                                continue
                            # is this package released for ESM, even though is not in
                            # supported list? ignore it
                            if "esm" in rel and cve_lib.is_active_esm_release(rel.split("/esm")[0]):
                                    if state == "released" and not cve_lib.is_supported(
                                        source, pkg, rel, data
                                    ):
                                        continue
                            # Just a warning if this is the devel release, package may be
                            # in -proposed.
                            # TODO: actually check -proposed.
                            if release == "devel" and pkg in dev_proposed[rel]:
                                if opt.debug:
                                    print(
                                        "%s: %d: WARNING: package '%s' not in '%s' (found in -proposed)"
                                        % (filename, linenum, pkg, rel),
                                        file=sys.stderr,
                                    )
                            else:
                                print(
                                    "%s: %d: package '%s' not in '%s'"
                                    % (filename, linenum, pkg, rel),
                                    file=sys.stderr,
                                )
                                if opt.autofix:
                                    fixup_entry(filename, pkg, rel)
                                cve_okay = False
                elif opt.strict and not opt.newer:
                    # Validate the version is <= version in release
                    # Unfortuanely, had to move this to --strict, as
                    # some older nvidia updates trigger this check.
                    if state == "released":
                        released = details[1]
                        # XXX 'version' existence check should not be needed
                        if "version" not in source[rel][pkg]:
                            global esm_warned
                            if not esm_warned:
                                print(
                                    "%s: %d: unable to lookup source version for %s in %s"
                                    % (filename, linenum, pkg, rel),
                                    file=sys.stderr,
                                )
                                print(
                                    "-- This is likely due to missing version info in source_map.py for the ESM release",
                                    file=sys.stderr,
                                )
                                esm_warned = True
                        elif (
                            source_map.version_compare(
                                released, source[rel][pkg]["version"]
                            )
                            > 0
                        ):
                            print(
                                "%s: %d: %s has %s > %s (in %s)"
                                % (
                                    filename,
                                    linenum,
                                    pkg,
                                    released,
                                    source[rel][pkg]["version"],
                                    rel,
                                ),
                                file=sys.stderr,
                            )
                            cve_okay = False
                # this is a check-syntax self-sanity check; we're
                # looking for kernels that were in the
                # unpublished_kernels list that have subsequently been
                # published and should be checked for existence.
                if is_active(cvepath) and is_unpublished_kernel(pkg, rel):
                    # we'll only issue a warning the first time we come
                    # across a kernel that's been published
                    if pkg not in warned_kernels:
                        print(
                            "kernel '%s/%s' is now published; please remove from unpublished_kernels list in check-syntax. (%s)"
                            % (pkg, rel, cve),
                            file=sys.stderr,
                        )
                        warned_kernels.append(pkg)

            # Is this package unfixed and considered supported?
            if state not in ["released", "not-affected"] and (cve_lib.is_active_esm_release(rel) or cve_lib.is_supported(
                source, pkg, rel, data
            )):
                supported.append("%s/%s" % (pkg, rel))

            if (
                len(details) > 1
                and state != "deferred"
                and "end of standard support" not in details[1]
                and "end of ESM support" not in details[1]
                and "deferred" in details[1]
            ):
                print(
                    "%s: %d: %s uses 'deferred' with '%s'. Use: 'deferred [(YYYY-MM-DD)]'"
                    % (filename, linenum, pkg, state),
                    file=sys.stderr,
                )
                cve_okay = False

    # Verify priority for any CVE with a supported package
    if (
        len(supported)
        and (is_active(cvepath) or is_embargoed(cvepath))
        and ("Priority" not in data or data["Priority"][0] not in cve_lib.priorities)
    ):
        filename = srcmap["Priority"][0] if "Priority" in srcmap else cvepath
        linenum = srcmap["Priority"][1] if "Priority" in srcmap else 1
        print(
            "%s: %d: Priority missing with supported packages (%s)"
            % (
                filename,
                linenum,
                ", ".join(supported),
            ),
            file=sys.stderr,
        )
        cve_okay = False

    # Check the priority reason is not the placeholder of XXX-Reason-XXX
    if "Priority" in data and "XXX-Reason-XXX" in data["Priority"][1]:
        filename = srcmap["Priority"][0] if "Priority" in srcmap else cvepath
        linenum = srcmap["Priority"][1] if "Priority" in srcmap else 1
        print(
            "%s: %d: Priority reason is XXX-Reason-XXX"
            % (
                filename,
                linenum,
            ),
            file=sys.stderr,
        )
        cve_okay = False

    # Verify per-package and per-package-release priorities
    for pkg_priority in [x for x in data if "Priority_" in x]:
        filename = srcmap[pkg_priority][0]
        linenum = srcmap[pkg_priority][1]
        fields = pkg_priority.split("_", 2)
        if len(fields) == 2:
            pkg = fields[1]
            if pkg not in data["pkgs"]:
                print(
                    "%s: %d: per package priority (%s) does not match any package in cve"
                    % (filename, linenum, pkg),
                    file=sys.stderr,
                )
                cve_okay = False
        elif len(fields) == 3:
            pkg, release = fields[1:3]
            if pkg not in data["pkgs"]:
                print(
                    "%s: %d: per package/release priority (%s/%s) does not match a package/release pair in cve"
                    % (filename, linenum, pkg, release),
                    file=sys.stderr,
                )
                cve_okay = False
            elif (
                release not in cve_lib.all_releases and not release == "devel"
            ) or release not in data["pkgs"][pkg]:
                print(
                    "%s: %d: invalid release in per package/release priority pair (%s/%s)"
                    % (filename, linenum, pkg, release),
                    file=sys.stderr,
                )
                cve_okay = False

        # print(pkg_priority, file=sys.stderr)

    # check to see if the description has been changed to rejected by
    # MITRE, we should move CVE to ignored state.
    if (
        is_active(cvepath)
        and "Description" in data
        and (data["Description"].lstrip().startswith("** REJECT **")
             or data["Description"].lstrip().startswith("Rejected reason"))
    ):
        filename = srcmap["Description"][0]
        linenum = srcmap["Description"][1]
        print(
            "%s: %d: Rejected by MITRE (possibly a duplicate of another CVE?)"
            % (filename, linenum),
            file=sys.stderr,
        )
        cve_okay = False
        if opt.autofix:
            fixup_rejected(filename)

    # check for CVE reference
    if re.match(r"^CVE-\d+-\d+$", cve):
        found = False
        cve_program_ref = "https://www.cve.org/CVERecord?id=" + cve
        if "References" in data:
            if cve_program_ref in data["References"]:
                found = True
        if not found:
            filename = srcmap["References"][0] if "References" in srcmap else cvepath
            linenum = srcmap["References"][1] if "References" in srcmap else 1
            print(
                "WARNING: %s: %d: does not contain reference to %s"
                % (
                    filename,
                    linenum,
                    cve_program_ref,
                ),
                file=sys.stderr,
            )
            cve_okay = False

    # check for URLs if using the USN database
    if opt.usndb and "ignored/" not in cvepath and cve in cves and len(cves[cve]) > 0:
        if "References" in data:
            for usn in cves[cve]:
                found = False
                usn_ref = "http://www.ubuntu.com/usn/usn-" + usn
                text = data["References"].strip()
                if len(text) != 0:
                    for line in text.split("\n"):
                        if line == usn_ref:
                            found = True
                if not found:
                    filename = srcmap["References"][0] if "References" in srcmap else cvepath
                    linenum = srcmap["References"][1] if "References" in srcmap else 1
                    print(
                        "%s: %d: does not contain reference to %s"
                        % (
                            filename,
                            linenum,
                            usn_ref,
                        ),
                        file=sys.stderr,
                    )
                    cve_okay = False

    # Either PublicDate or CRD must be set to something
    if (not is_boilerplate(cvepath) and
            ("PublicDate" not in data or data["PublicDate"] == "") and
            ("CRD" not in data or data["CRD"] == "")
    ):
        key = "PublicDate" if "PublicDate" in srcmap else "CRD"
        filename = srcmap[key][0]
        linenum = srcmap[key][1]
        print(
            "%s: %d: must specify at least one of PublicDate or CRD as a valid date or unknown"
            % (
                filename,
                linenum,
            ),
            file=sys.stderr,
        )

    for d in ["PublicDate", "PublicDateAtUSN", "CRD"]:
        if is_boilerplate(cvepath):
            continue
        passes = []
        # Embargoed CVEs can have an empty or unknown PublicDate
        if d == "PublicDate" and is_embargoed(cvepath):
            passes = ["", "unknown"]
        if d == "PublicDateAtUSN":
            # PublicDateAtUSN can be empty
            passes = [""]
        if d == "CRD":
            # CRD can empty or unknown
            passes = ["", "unknown"]
        if d in data and data[d] not in passes:
            split_date = data[d].split()
            date_format = "%Y-%m-%d"
            date_value = data[d]

            # UTC is the only valid timezone
            if len(split_date) == 3:
                date_format = "%Y-%m-%d %H:%M:%S UTC"

            valid = False

            try:
                datetime.datetime.strptime(date_value, date_format)
                valid = True
            except ValueError:
                pass

            if not valid:
                filename = srcmap[d][0]
                linenum = srcmap[d][1]
                print(
                    "%s: %d: does not contain a valid %s '%s' (need YYYY-MM-DD [HH:MM:SS UTC]%s)"
                    % (filename, linenum, d, data[d], ", or ".join(passes)),
                    file=sys.stderr,
                )
                cve_okay = False

    for pkg in data["patches"]:
        for index, value in enumerate(data["patches"][pkg]):
            patch_type, patch = data["patches"][pkg][index]
            # validate break-fix entries as 'I?hash|-|local-|URL' and
            # others should be a URL - but don't bother with retired
            # CVEs as these have a lot of old cruft
            filename = srcmap["patches"][pkg][index][0]
            linenum = srcmap["patches"][pkg][index][1]
            if patch_type == "break-fix":
                try:
                    bfre = "^(-|I?[a-f0-9]{1,40}|local-[A-Za-z0-9-]+|https?://.*)$"
                    breaks, fixes = patch.split(' ', 1)
                    # breaks and fixes can contain multiple entries separated by |
                    for brk in breaks.split('|'):
                        if re.match(bfre, brk) is None:
                            raise ValueError("invalid break entry '%s':" % brk)
                    # fixes can contain multiple entries separated by |
                    for fix in fixes.split('|'):
                        if re.match(bfre, fix) is None:
                            raise ValueError("invalid fix entry '%s':" % fix)
                except Exception as e:
                        print(
                            "%s: %d: invalid break-fix entry: '%s': %s"
                            % (filename, linenum, patch, e),
                            file=sys.stderr,
                        )
                        cve_okay = False
            elif opt.strict or not "retired/" in cvepath:
                if "://" not in patch:
                    print(
                        "%s: %d: invalid patch URL '%s'"
                        % (filename, linenum, patch),
                        file=sys.stderr,
                    )
                    cve_okay = False

    # if there is a reference URL to a kernel commit then check there is a
    # break-fix entry against the linux package
    if "References" in data:
        for ref in data["References"].split("\n"):
            if "git.kernel.org" in ref:
                # the CVE needs to already be triaged against linux and hence
                # have a patches entry for it
                if "linux" in data["patches"] and len(data["patches"]["linux"]) == 0:
                    filename = srcmap["References"][0] if "References" in srcmap else cvepath
                    linenum = srcmap["References"][1] if "References" in srcmap else 1
                    print(
                        "%s: %d: missing break-fix entry for kernel commit"
                        % (filename, linenum),
                        file=sys.stderr,
                    )
                    cve_okay = False
                    if opt.autofix:
                        fixup_entry_missing_break_fix(filename, "linux", ref)
                    break

    for entry in data["CVSS"]:
        srcname = entry['source']
        filename = srcmap["CVSS"][srcname][0]
        linenum = srcmap["CVSS"][srcname][1]
        # check for cvss entries with unknown origin
        if srcname == 'unknown':
            print("%s: %d: CVSS with unknown origin" %
                  (filename, linenum),
                  file=sys.stderr)
            cve_okay = False
        if "baseScore" not in entry.keys():
            print("%s: %d: CVSS missing baseScore" %
                  (filename, linenum),
                  file=sys.stderr)
            cve_okay = False
        if "baseSeverity" not in entry.keys():
            print("%s: %d: CVSS missing baseSeverity" %
                  (filename, linenum),
                  file=sys.stderr)
            cve_okay = False
        cvss = cve_lib.parse_cvss(entry['vector'])
        # check baseScore and baseSeverity match
        baseScore = cvss['baseMetricV3']['cvssV3']['baseScore']
        baseSeverity = cvss['baseMetricV3']['cvssV3']['baseSeverity']
        # check the entry's baseScore is actually a valid float
        try:
            entry['baseScore'] = float(entry['baseScore'])
        except ValueError:
            print("%s: %d: baseScore %s is not a valid float" %
                  (filename, linenum, entry['baseScore']),
                  file=sys.stderr)
            cve_okay = False
        if entry['baseScore'] != baseScore:
            print("%s: %d: baseScore %s is not correct, should be %02.1f" %
                  (filename, linenum, entry['baseScore'], baseScore),
                  file=sys.stderr)
            cve_okay = False
        if entry['baseSeverity'] != baseSeverity:
            print("%s: %d: baseSeverity %s is not correct, should be %s" %
                  (filename, linenum, entry['baseSeverity'], baseSeverity),
                  file=sys.stderr)
            cve_okay = False

    # if the CVE is retired check if Assigned-to field has been cleared
    if (
        is_retired(cvepath) and
        "Assigned-to" in data
    ):
        assigned = data["Assigned-to"]
        if assigned != "":
            filename = srcmap["Assigned-to"][0]
            linenum = srcmap["Assigned-to"][1]
            print(
                "%s: %d: CVE is retired, but has Assigned-to set to %s, should be blank" %
                (
                    filename,
                    linenum,
                    assigned
                ),
                file=sys.stderr
            )
            if opt.autofix:
                fixup_assignedto(filename)
            cve_okay = False


    if opt.debug:
        pp.pprint(data)
    debug(data)
    return cve_okay

if opt.jobs > 1:
    # use ProcessPoolExecutor for parallel processing since this is more efficient
    # than multiple threads via ThreadPoolExecutor as we can keep each at 100% CPU
    # utilisation
    with concurrent.futures.ProcessPoolExecutor(max_workers=opt.jobs) as p:
        results = p.map(check_cve, args)
else:
    results = map(check_cve, args)
# evaluate the results so that all() below doesn't bail out early in the case of errors
# and hence the other CVEs never get checked
results = list(results)
assert len(results) == len(args)
all_okay &= all(results)

if all_okay and opt.verbose:
    print("OK: %d CVEs" % (len(args)))
# Invert boolean for unix exit code
sys.exit(not all_okay)
