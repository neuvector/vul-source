#!/usr/bin/env python3

# Author: Kees Cook <kees@ubuntu.com>
# Author: Jamie Strandboge <jamie@ubuntu.com>
# Author: Marc Deslauriers <marc.deslauriers@canonical.com>
# Copyright (C) 2005-2020 Canonical Ltd.
#
# This script is distributed under the terms and conditions of the GNU General
# Public License, Version 2 or later. See http://www.gnu.org/copyleft/gpl.html
# for details.

# Set CVE_ALLOW_NEWER_PKGS=1 to skip new package checks
from __future__ import print_function

import datetime
import glob
import optparse
import os
import pprint
import re
import sys
import subprocess
import signal
import concurrent.futures
import multiprocessing
import shutil

import cve_lib
import kernel_lib
import usn_lib

import source_map

# add to this list when adding tracking for kernels that have not been
# published to updates/security yet. Once published, can be removed
# (script should warn about that). If a kernel is published in one
# release, but not yet in another release, add the unpublished release
# after a '/' e.g. 'linux-aws/trusty'
unpublished_kernels = [
    "linux-bluefield/jammy",  # linux-bluefield/jammy is coming, apparently
    "linux-gkeop/oracular", # not in archive but repo exists, probably coming

    # used for building a snap, not intended for
    # the main archive, see the deletion record in
    # https://launchpad.net/ubuntu/+source/linux-intel/+publishinghistory
    "linux-intel/noble",
]

required_fields = [
    'Candidate',
    'Description',
    'Priority',
    'PublicDate',
    'Ubuntu-Description',
]

def CVEs_from_CNA():
    """Returns a dict of CVEs assigned from the README in the embargoed cna
    directory, using a space and text after CVE-NNNN-NNNN as indicator of
    which CVEs have been assigned. For each CVE in the dict, the value is a
    list containing the filename and line number where this was sourced
    from.
    """
    lines = []
    # Assumes embargoed symlink/ exists in parent directory and points to
    # ../embargoed/cves/
    cna_source = os.path.realpath(
        os.path.join(
            os.path.dirname(os.path.dirname(os.path.realpath(__file__))),
            "embargoed", "..", "cna", "README"))
    try:
        f = open(cna_source)
        lines = f.readlines()
        f.close()
    except IOError as e:
        print("Ignoring CNA sanity checks: %s\n" % e, file=sys.stderr)
        return {}

    # Assumes any text after CVE-NNNN-NNNN means "assigned"
    # Note the space is important, used for split(" ") later
    assigned_cves = re.compile(r"^(CVE-\d\d\d\d-\d{4,7}) .+")

    def find_assigned_cves(line):
        if "REJECTED" in line:
            return None
        if "IGNORED" in line:
            return None
        match = assigned_cves.match(line)
        if match:
            return match.group(1)
        return None

    cves = {}
    linenum = 1
    for line in lines:
        cve = find_assigned_cves(line)
        if cve:
            cves[cve] = [cna_source, linenum]
        linenum += 1
    return cves


def is_active(cvepath):
    return cvepath.startswith(cve_lib.active_dir)


def is_embargoed(cvepath):
    return cvepath.startswith(cve_lib.embargoed_dir)


def is_ignored(cvepath):
    return cvepath.startswith(cve_lib.ignored_dir)


def is_retired(cvepath):
    return cvepath.startswith(cve_lib.retired_dir)


def is_boilerplate(cvepath):
    return cvepath.startswith(cve_lib.boilerplates_dir)


def is_unpublished_kernel(kernel, release=None, debug=False):
    for u in unpublished_kernels:
        unpub = u.split("/")
        if debug:
            print("Checking %s/%s against %s" % (kernel, release, unpub))
        if unpub[0] == kernel and (
            len(unpub) == 1 or (len(unpub) == 2 and unpub[1] == release)
        ):
            return True
    return False


def build_aliases_cache(sources):
    rev_aliases = {}

    for rel in sources:
        for pkg in sources[rel]:
            if 'aliases' in sources[rel][pkg]:
                for alias in sources[rel][pkg]['aliases']:
                    if rel not in rev_aliases:
                        rev_aliases[rel] = {}
                    if alias not in rev_aliases[rel]:
                        rev_aliases[rel][alias] = []
                    rev_aliases[rel][alias].append(pkg)

    return rev_aliases


def get_pkgs_from_aliases(aliases, pkg, rel):
    if rel in aliases:
        if pkg in aliases[rel]:
            return aliases[rel][pkg]
    return []


def subprocess_setup():
    # Python installs a SIGPIPE handler by default. This is usually not what
    # non-Python subprocesses expect.
    signal.signal(signal.SIGPIPE, signal.SIG_DFL)


def cmd(
    command,
    input=None,
    stderr=subprocess.STDOUT,
    stdout=subprocess.PIPE,
    stdin=None,
    timeout=None,
):
    """Try to execute given command (array) and return its stdout, or return
    a textual error if it failed."""

    try:
        sp = subprocess.Popen(
            command,
            stdin=stdin,
            stdout=stdout,
            stderr=stderr,
            close_fds=True,
            preexec_fn=subprocess_setup,
            universal_newlines=True,
        )
    except OSError as e:
        return [127, str(e)]

    out, outerr = sp.communicate(input)
    # Handle redirection of stdout
    if out is None:
        out = ""
    # Handle redirection of stderr
    if outerr is None:
        outerr = ""
    return [sp.returncode, out + outerr]


def get_bzr_filelist():
    rc, report = cmd(["bzr", "stat", "-S"])

    file_list = []
    for line in report.splitlines():
        if len(line.split()) == 2:
            if line.split()[0] != "D":
                file_list.append(line.split()[1])

    return file_list


def get_git_filelist():
    rc, report = cmd(["git", "diff", "--name-only", "--diff-filter=AM", "HEAD"])

    return report.splitlines()


def cve_lib_consistency_checks():
    # add additional consistency check calls here, if need be
    kernel_lib.meta_kernels.consistency_check()


parser = optparse.OptionParser(usage="%prog [options] [file ...]")
parser.add_option(
    "-v",
    "--verbose",
    help="Enable verbose reporting",
    action="store_true",
    default=False,
)
parser.add_option(
    "-d", "--debug", help="Enable debug reporting", action="store_true", default=False
)
parser.add_option(
    "-u", "--usn-db", dest="usndb", help="Enable USN database on DB", metavar="DB"
)
parser.add_option(
    "-n",
    "--newer",
    help="Allow versions newer than what is in the archive",
    action="store_true",
    default=False,
)
parser.add_option(
    "-s",
    "--strict",
    help="Be extra strict in syntax",
    action="store_true",
    default=False,
)
parser.add_option(
    "-f", "--filelist", help="Read the list of files to check from the specified input file", metavar="FILE"
)
parser.add_option(
    "-m",
    "--modified",
    help="Only check modified files",
    action="store_true",
    default=False,
)
parser.add_option(
    "-a",
    "--autofix",
    help="Attempt to fix problems automatically",
    action="store_true",
    default=False,
)
parser.add_option(
    "--dry-run",
    help="Dry run for autofix parameter",
    action="store_true",
    default=False,
)
parser.add_option(
    "-j",
    "--jobs",
    type=int,
    help="Number of jobs to run simultaneously (default: %d)" % multiprocessing.cpu_count(),
    default=multiprocessing.cpu_count(),
)
parser.add_option(
    "--stdin",
    help="Check the contents of stdin instead of a filelist or modified files etc",
    action="store_true",
    default=False,
)

# parser.add_option("-c", "--cna", help="Ensure every CVE assigned by Canonical's CNA has an entry", action='store_true')
(opt, args) = parser.parse_args()

srcmap = source_map.load(detailed=opt.strict)
if cve_lib.devel_release:
    dev_proposed = source_map.load(pockets=["-proposed"], releases=[cve_lib.devel_release], detailed=opt.strict)

if opt.debug:
    pp = pprint.PrettyPrinter(indent=4)

def debug(args):
    if opt.debug:
        pp.pprint(args)


warned_kernels = []
esm_warned = False
kev = {}
all_okay = True

cve_lib_consistency_checks()

cves = dict()
if opt.usndb:
    usn_db = usn_lib.load_database(opt.usndb)
    reverted = usn_lib.get_reverted()

    # create a dictionary of key=CVE value=USNs
    for usn in usn_db:
        if "cves" not in usn_db[usn]:
            continue
        for cve in usn_db[usn]["cves"]:
            if not cve.startswith("CVE-"):
                continue
            if usn in reverted and cve in reverted[usn]:
                continue
            if cve not in cves:
                cves[cve] = []
                cves[cve].append(usn)
            else:
                cves[cve].append(usn)

check_dirs = [cve_lib.active_dir, cve_lib.retired_dir, cve_lib.ignored_dir]
if os.path.islink(cve_lib.embargoed_dir):
    check_dirs.append(cve_lib.embargoed_dir)

debug("check_dirs %s" % check_dirs)

all_files = True
if opt.stdin:
    debug("Using /dev/stdin as input")
    args = ["/dev/stdin"]
    all_files = False
elif len(args) == 0:
    if opt.filelist:
        debug("Using filelist %s" % opt.filelist)

        all_files = False
        with open(opt.filelist) as fh:
            cvelist = []
            for line in fh.readlines():
                for dir in check_dirs:
                    for d in [dir, os.path.relpath(dir)]:
                        if line.startswith("%s/CVE-" % d):
                            cvelist += [line.rstrip()]
                            break
            if len(cvelist) == 0:
                print("WARNING: No CVEs found in specified filelist %s" % opt.filelist, file=sys.stderr)
            else:
                args += cvelist
    elif opt.modified:
        debug("Checking modified files only")

        all_files = False

        if os.path.exists(".git"):
            file_list = get_git_filelist()
        else:
            file_list = get_bzr_filelist()

        for filename in file_list:
            filename = os.path.join(os.getcwd(), filename)
            for dir in check_dirs:
                if filename.startswith("%s/CVE-" % dir):
                    args += [filename]
                    continue
            if is_boilerplate(filename):
                args += [filename]

    else:
        bps = glob.glob("%s/*" % cve_lib.boilerplates_dir)
        rc, report = cmd(["git", "check-ignore"] + bps)
        if rc == 0:
            bps = set(bps) - set(report.splitlines())
        for bp in sorted(bps):
            args += [bp]

        for dir in check_dirs:
            cvelist = glob.glob("%s/CVE-*" % dir)
            rc, report = cmd(["git", "check-ignore"] + cvelist)
            if rc == 0:
                cvelist = set(cvelist) - set(report.splitlines())
            for cve in sorted(cvelist):
                args += [cve]

else:
    all_files = False

debug("args %s" % args)

ignored = cve_lib.parse_CVEs_from_uri("%s/not-for-us.txt" % cve_lib.ignored_dir)

debug("ignored %s" % ignored)

uct_required_releases = sorted((set(cve_lib.all_releases + ["devel"]) - set([cve_lib.devel_release])) - set(cve_lib.eol_releases) - set(cve_lib.external_releases))

# Build up the cache of subproject CVEs
cve_lib.build_subproject_dir_cache()

cna_cves_set = CVEs_from_CNA()
# Just run this if we're not specifying specific CVEs
if len(cna_cves_set) > 0 and all_files:
    cve_name_re = re.compile(r"(CVE-\d\d\d\d-\d{4,7})$")

    def filter_cves(fname):
        return re.search(cve_name_re, fname)

    def find_cves(fname):
        m = re.search(cve_name_re, fname)
        if m:
            return m.group(1)
        else:
            print("unmatched %s\n" % fname, file=sys.stderr)

    ignored_set = set(ignored)
    args = {find_cves(name) for name in filter(filter_cves, args)}

    debug("cna_cves_set: %s\n" % cna_cves_set)
    debug("ignored_set: %s\n" % ignored_set)
    debug("args: %s" % args)

    # if we ever assign a CVE then ignore it (vbulletin comes to mind...)
    # we can use the "IGNORED" tag to skip these checks
    martians = cna_cves_set.keys() & ignored_set
    for cve in martians:
        print("%s: %d: %s that we assigned is now IGNORED.\n"
              % (cna_cves_set[cve][0], cna_cves_set[cve][1], cve))

    too_private = cna_cves_set.keys() - args
    for cve in too_private:
        print("%s: %d: %s that we assigned needs an UCT entry.\n"
              % (cna_cves_set[cve][0], cna_cves_set[cve][1], cve))

aliases_cache = build_aliases_cache(srcmap)


def fixup_entry(filename, pkg, rel):
    # If release is devel or EOL, we should add the proper status instead of removing
    if rel == cve_lib.devel_release:
        rel = "devel"
        if opt.dry_run:
            print("Dry-Run: updating %s, %s, devel to DNE" % (filename, pkg))
            return
        cve_lib.update_state(filename, pkg, "devel", "DNE")
    elif not cve_lib.is_active_release(rel):
        if cve_lib.is_active_esm_release(rel):
            status = cve_lib.EOL_ESM_STATUS.format(state='unknown')
        else:
            status = cve_lib.EOL_STATUS.format(state='unknown')

        if opt.dry_run:
            print("Dry-Run: updating %s, %s, %s to %s" % (filename, pkg, rel, status))
            return
        cve_lib.update_state(filename, pkg, rel, status)

    else:
        if opt.dry_run:
            print("Dry-Run: dropping %s, %s, %s" % (filename, pkg, rel))
            return
        cve_lib.drop_pkg_release(filename, pkg, rel)


def fixup_entry_state(filename, pkg, rel, state):
    if opt.dry_run:
        print("Dry-Run: updating %s, %s, %s to %s" % (filename, pkg, rel, state))
        return

    cve_lib.update_state(filename, pkg, rel, state)


def fixup_entry_get_status(filename, pkg, rel):
    # get status from the parent release if there is one
    status = "needs-triage"
    try:
        _, _, _, details = cve_lib.get_subproject_details(rel)
        parent = details["parent"]
        # this may be either an alias or a full name but cve_lib only
        # uses aliases
        parent = cve_lib.release_alias(parent)
        data = cve_lib.load_cve(filename)
        status = data["pkgs"][pkg][parent][0]
        note = data["pkgs"][pkg][parent][1]
        if len(note) > 0:
            status = status + " (" + note + ")"
        # if parent reached EOL then we are likely the new alive
        # release so ignore their status in that case
        if "end of life" in status or "end of standard support" in status:
            status = 'needs-triage'
    except (KeyError, ValueError, TypeError):
        pass

    return status


def fixup_entry_missing(filename, pkg, rel):
    status = fixup_entry_get_status(filename, pkg, rel)

    if rel == cve_lib.devel_release:
        rel = "devel"

    if opt.dry_run:
        print("Dry-Run: Adding %s, %s, %s to %s" % (filename, pkg, rel, status))
        return

    cve_lib.add_state(filename, pkg, rel, status)


def fixup_entry_wrong(filename, pkg, rel):
    status = fixup_entry_get_status(filename, pkg, rel)

    if rel == cve_lib.devel_release:
        rel = "devel"

    if opt.dry_run:
        print("Dry-Run: updating %s, %s, %s to %s" % (filename, pkg, rel, status))
        return

    cve_lib.update_state(filename, pkg, rel, status, None)


def fixup_entry_missing_break_fix(filename, pkg, ref):
    urls = cve_lib.fetch_kernel_fixes(ref)
    urls = cve_lib.validate_kernel_fixes(urls)

    for url in urls:
        # convert to the break-fix format as a string
        url = " ".join(url)
        if opt.dry_run:
            print("Dry-Run: adding break-fix %s, %s, to %s" % (filename, pkg, url))
            return

        cve_lib.add_patch(filename, pkg, url, "break-fix")
    cve_lib.add_tag(filename, pkg, "review-break-fix")


def fixup_priority(filename, priority):
    if opt.dry_run:
        print("Dry-Run: setting priority %s to %s" % (filename, priority))
        return

    cve_lib.update_field(filename, "Priority", priority)


def fixup_missing_usn_ref(filename, usn_ref):
    if opt.dry_run:
        print("Dry-Run: adding reference %s in %s" % (usn_ref, filename))
        return

    cve_lib.add_reference(filename, usn_ref)


def fixup_assignedto(filename):
    if opt.dry_run:
        print("Dry-Run: clearing assigned-to in %s" % filename)
        return

    cve_lib.update_field(filename, "Assigned-to", "")


def fixup_entry_missing_tag(filename, pkg, tag):
    if opt.dry_run:
        print("Dry-Run: adding tag %s %s %s" % (filename, pkg, tag))
        return

    cve_lib.add_tag(filename, pkg, tag)


def check_esm_release_status(cvepath, data, pkg, srcentries, cve_okay):
    """
    Validate esm release status
    """
    for rel in cve_lib.esm_apps_releases:
        esm_apps_rel = "esm-apps/" + rel
        if esm_apps_rel not in data["pkgs"][pkg]:
            # if package not in universe, skip
            continue

        if rel not in data["pkgs"][pkg]:
            # some cves might not have the base
            # release entry if it was already EOL
            continue
        base_state = data["pkgs"][pkg][rel][0]
        base_note = data["pkgs"][pkg][rel][1]
        esm_state = data["pkgs"][pkg][esm_apps_rel][0]

        if base_state == "ignored" and rel not in cve_lib.eol_releases:
            linenum = srcentries["pkgs"][pkg][rel][1]
            if "end of standard support" in base_note or \
                    "end of life" in base_note:
                print(
                    "%s: %d: active release '%s' is not EOL"
                    % (cvepath, linenum, rel),
                    file=sys.stderr,
                )
                cve_okay = False
        elif base_state == "not-affected" and esm_state not in ["DNE", "not-affected", "released"]:
            linenum = srcentries["pkgs"][pkg][esm_apps_rel][1]
            print(
                "%s: %d: %s state should be 'not-affected (%s)'"
                % (cvepath, linenum, esm_apps_rel, base_note),
                file=sys.stderr,
            )
            cve_okay = False
            if opt.autofix:
                if base_note:
                    fixed_state = f"not-affected ({base_note})"
                else:
                    fixed_state = "not-affected"
                fixup_entry_state(cvepath, pkg, esm_apps_rel, fixed_state)
        elif base_state == "released" and esm_state not in ["DNE", "released"]:
            linenum = srcentries["pkgs"][pkg][esm_apps_rel][1]
            print(
                "%s: %d: %s state should be 'released (%s)'"
                % (cvepath, linenum, esm_apps_rel, base_note),
                file=sys.stderr,
            )
            cve_okay = False
            if opt.autofix:
                fixed_state = f"released ({base_note})"
                fixup_entry_state(cvepath, pkg, esm_apps_rel, fixed_state)
        elif base_state == "DNE" and esm_state != "DNE" and\
            pkg not in srcmap[esm_apps_rel]:
            print(
                "%s: %d: %s state should be 'DNE'"
                % (cvepath, linenum, esm_apps_rel),
                file=sys.stderr,
            )
            cve_okay = False
            if opt.autofix:
                fixup_entry_state(cvepath, pkg, rel, "DNE")
        elif rel not in cve_lib.eol_releases and esm_state == "released" and \
            base_state not in ["released", "needed"] and\
            "disputed" not in base_note and\
            pkg in srcmap[rel]:
            linenum = srcentries["pkgs"][pkg][rel][1]
            print(
                "%s: %d: %s state should be 'needed'"
                % (cvepath, linenum, rel),
                file=sys.stderr,
            )
            cve_okay = False
            if opt.autofix:
                fixup_entry_state(cvepath, pkg, rel, "needed")

    return cve_okay


def check_eol_release_status(cvepath, data, pkg, srcentries, cve_okay):
    """
    Verify eol releases status is correct and if parentheses
    are balanced
    """
    for rel in sorted(data["pkgs"][pkg].keys()):
        filename = srcentries["pkgs"][pkg][rel][0]
        linenum = srcentries["pkgs"][pkg][rel][1]
        details = data["pkgs"][pkg][rel]
        if len(details) > 1:
            state = details[0]
            note = details[1]
            if note.count("(") != note.count(")"):
                print(
                    "%s: %d: %s_%s has unbalanced parentheses in state annotation: '%s %s'"
                    % (filename, linenum, rel, pkg, state, note)
                )
                cve_okay = False
        if rel in cve_lib.eol_releases:
            state = details[0]
            note = details[1]
            old_state = ''
            if ', was ' in note:
                old_state = note.split(', was ')[-1]
            elif note and cve_lib.EOL_ESM_STATUS[9:-14] not in note and \
                cve_lib.EOL_STATUS[9:-14] not in note:
                old_state = f'{state} [{note}]'
            else:
                old_state = state

            fixed_state = ''
            product, series = cve_lib.product_series(rel)
            if rel in cve_lib.interim_releases:
                fixed_state = cve_lib.EOL_STATUS.format(state=old_state)
            elif product == cve_lib.PRODUCT_UBUNTU:
                fixed_state = cve_lib.EOL_LTS_STATUS.format(state=old_state)
            elif product in cve_lib.PRODUCT_ESM:
                if series in cve_lib.esm_infra_legacy_releases or\
                        series in cve_lib.esm_apps_legacy_releases:
                    fixed_state = cve_lib.EOL_ESM_STATUS.format(state=old_state)
                else:
                    fixed_state = cve_lib.EOL_STATUS.format(state=old_state)
            else:
                fixed_state = cve_lib.EOL_STATUS.format(state=old_state)

            if state in ['released', 'not-affected', 'DNE']:
                continue
            elif state == 'ignored':
                if "superseded by" not in note and \
                        "replaced by" not in note and \
                        "end of kernel support" not in note and \
                        "end of standard support" not in note and \
                        "end of ESM support" not in note and \
                        "end of life" not in note:
                    if not note:
                        continue
                    elif (f"ignored ({note})" != fixed_state):
                        print(
                            "%s: %d: %s incorrect ignored detail '%s' for '%s', try '%s'"
                            % (filename, linenum, pkg, note, rel, fixed_state),
                            file=sys.stderr,
                        )
                        cve_okay = False
                        if opt.autofix:
                            fixup_entry_state(filename, pkg, rel, fixed_state)
            else:
                # state in needed, needs-triage, pending, deferred
                print(
                    "%s: %d: %s incorrect status '%s' in '%s', try '%s'"
                    % (filename, linenum, pkg, state, rel, fixed_state),
                    file=sys.stderr,
                )
                cve_okay = False
                if opt.autofix:
                    fixup_entry_state(filename, pkg, rel, fixed_state)
    return cve_okay


def check_no_external_release_in_file(cvepath, data, pkg, srcentries, cve_okay):
    """
    Verify no external release are in UCT
    """
    for rel in cve_lib.external_releases:
        if rel in sorted(data["pkgs"][pkg].keys()):
            filename = srcentries["pkgs"][pkg][rel][0]
            linenum = srcentries["pkgs"][pkg][rel][1]
            if filename == cvepath:
                print(
                    "%s: %d: external release '%s' listed in internal CVE file"
                    % (filename, linenum, rel),
                    file=sys.stderr,
                )
                cve_okay = False
    return cve_okay


def check_pkg_uct_required_releases(cvepath, data, pkg, srcentries, cve_okay):
    """
    Verify that given package entry has the required releases in it
    and if DNE state is still accurate
    """
    for rel in uct_required_releases:
        if (is_active(cvepath) or is_boilerplate(cvepath)):
            if rel in srcmap and pkg in srcmap[rel]:
                if rel not in data["pkgs"][pkg]:
                    print(
                        "%s: %s missing release '%s'"
                        % (cvepath, pkg, rel),
                        file=sys.stderr,
                    )
                    cve_okay = False
                    if opt.autofix:
                        fixup_entry_missing(cvepath, pkg, rel)
        if rel in data["pkgs"][pkg]:
            linenum = srcentries["pkgs"][pkg][rel][1]
            if pkg not in srcmap[rel] and\
                    data["pkgs"][pkg][rel][0] != "DNE":
                if rel == "devel":
                    if is_retired(cvepath) and\
                            data["pkgs"][pkg][rel][0] in\
                            ["needed", "needs-triage", "pending"]:
                        print(
                            "%s: %d: retired but %s is listed as unfixed (%s) for '%s'"
                            % (cvepath, linenum, pkg, data["pkgs"][pkg][rel][0], rel),
                            file=sys.stderr,
                        )
                        cve_okay = False
                        continue
                    if is_active(cvepath) and pkg in dev_proposed[rel]:
                        if opt.debug:
                            print(
                                "%s: %d: WARNING: package '%s' not in '%s' (found in -proposed)"
                                % (cvepath, linenum, pkg, rel),
                                file=sys.stderr,
                            )
                else:
                    # forcibly skip linux-lts-backport packages and
                    # other derived kernels since want to track them
                    # before they end up fully in the archive;
                    # additional kernels can be added to
                    # unpublished_kernels as needed
                    if pkg.startswith("linux-lts-") or is_unpublished_kernel(pkg, rel):
                        if opt.debug:
                            print(
                                "%s: %d: skipping unpublished kernel '%s'"
                                % (cvepath, linenum, pkg),
                                file=sys.stderr,
                            )
                        continue

                    print(
                        "%s: %d: package '%s' not in '%s'"
                        % (cvepath, linenum, pkg, rel),
                        file=sys.stderr,
                    )
                    cve_okay = False
                    if opt.autofix:
                        fixup_entry_state(cvepath, pkg, rel, "DNE")
            elif pkg in srcmap[rel] and\
                data["pkgs"][pkg][rel][0] == "DNE":
                if rel == "devel" and is_retired(cvepath):
                    continue
                print(
                    "%s: %d: package '%s' DOES exist in '%s'"
                    % (cvepath, linenum, pkg, rel),
                    file=sys.stderr,
                )
                cve_okay = False
                if opt.autofix:
                    fixup_entry_wrong(cvepath, pkg, rel)
    return cve_okay


def check_missing_release(pkg, rel, srcmap, data, srcentries, cve_okay):
    if rel in srcmap and pkg in srcmap[rel] and \
            rel not in srcentries["pkgs"][pkg]:
        filename = get_cve_path(data["Candidate"], rel)
        print(
            "%s: %s missing release '%s'"
            % (filename, pkg, rel),
            file=sys.stderr,
        )
        if opt.autofix:
            fixup_entry_missing(filename, pkg, rel)
            cve_okay = False
    return cve_okay


def check_cve_pkg_required_releases(cvepath, data, pkg, srcentries, cve_okay):
    """
    Verify have required releases for each package
    """
    listed_releases = set(sorted(data["pkgs"][pkg].keys()))

    # check uct releases
    check_pkg_uct_required_releases(cvepath, data, pkg, srcentries, cve_okay)

    # check external releases
    for rel in cve_lib.external_releases:
        # for external releases skip embargoed or ignored CVEs
        if is_embargoed(cvepath):
            continue
        # If the release doesn't require cve triage,
        # we shouldn't add any entries to the CVE
        if not cve_lib.is_cve_triage_required(rel):
            continue

        # check for alias for package
        pkg_alias = get_pkgs_from_aliases(aliases_cache, pkg, rel)

        if pkg_alias:
            for pk in pkg_alias:
                # for now we only care about active CVEs
                # this could be removed in case we want to cover
                # ignored and retired CVEs
                if is_active(cvepath):
                    check_missing_release(pk, rel, srcmap, data, srcentries, cve_okay)
        else:
            # for now we only care about active CVEs
            # this could be removed in case we want to cover
            # ignored and retired CVEs
            if is_active(cvepath):
                check_missing_release(pkg, rel, srcmap, data, srcentries, cve_okay)

    unknown_releases = listed_releases - set(cve_lib.all_releases + ["devel", "upstream"])
    for rel in unknown_releases:
        filename = srcentries["pkgs"][pkg][rel][0]
        linenum = srcentries["pkgs"][pkg][rel][1]
        print(
            "%s: %d: %s unknown release '%s'"
            % (filename, linenum, pkg, rel),
            file=sys.stderr,
        )
        if opt.autofix:
            fixup_entry(filename, pkg, rel)
            cve_okay = False
    return cve_okay


def check_patches(cvepath, data, srcentries, cve_okay):
    """
    Validate break-fix/patches entries
    """
    for pkg in data["patches"]:
        for index, value in enumerate(data["patches"][pkg]):
            patch_type, patch = data["patches"][pkg][index]
            # validate break-fix entries as 'I?hash|-|local-|URL' and
            # others should be a URL - but don't bother with retired
            # CVEs as these have a lot of old cruft
            linenum = srcentries["patches"][pkg][index][1]
            if patch_type == "break-fix":
                try:
                    bfre = "^(-|I?[a-f0-9]{1,40}|local-[A-Za-z0-9-]+|https?://.*)$"
                    breaks, fixes = patch.split(' ', 1)
                    # breaks and fixes can contain multiple entries separated by |
                    for brk in breaks.split('|'):
                        if re.match(bfre, brk) is None:
                            raise ValueError("invalid break entry '%s':" % brk)
                    # fixes can contain multiple entries separated by |
                    for fix in fixes.split('|'):
                        if re.match(bfre, fix) is None:
                            raise ValueError("invalid fix entry '%s':" % fix)
                except Exception as e:
                    print(
                        "%s: %d: invalid break-fix entry: '%s': %s"
                        % (cvepath, linenum, patch, e),
                        file=sys.stderr,
                    )
                    cve_okay = False
            elif opt.strict or not "retired/" in cvepath:
                if "://" not in patch:
                    print(
                        "%s: %d: invalid patch URL '%s'"
                        % (cvepath, linenum, patch),
                        file=sys.stderr,
                    )
                    cve_okay = False
    return cve_okay


def check_cvss(cvepath, data, srcentries, cve_okay):
    """
    Check for CVSS entries with unknown origin or
    invalid CVSS score
    """
    for entry in data["CVSS"]:
        srcname = entry['source']
        linenum = srcentries["CVSS"][srcname][1]
        # TODO: remove this when cvss4.0 support is added
        # Skip validation for CVSS4.0 vectors
        if 'CVSS:4.0' in entry['vector']:
            continue

        # check for cvss entries with unknown origin
        if srcname == 'unknown':
            print("%s: %d: CVSS with unknown origin" %
                  (cvepath, linenum),
                  file=sys.stderr)
            cve_okay = False
        if "baseScore" not in entry.keys():
            print("%s: %d: CVSS missing baseScore" %
                  (cvepath, linenum),
                  file=sys.stderr)
            cve_okay = False
        if "baseSeverity" not in entry.keys():
            print("%s: %d: CVSS missing baseSeverity" %
                  (cvepath, linenum),
                  file=sys.stderr)
            cve_okay = False

        cvss = cve_lib.parse_cvss(entry['vector'])
        # TODO: remove this when cvss4.0 support is added
        if cvss is None:
            continue  # This handles the CVSS4.0 case where parse_cvss returns None
        # check baseScore and baseSeverity match
        baseScore = cvss['baseMetricV3']['cvssV3']['baseScore']
        baseSeverity = cvss['baseMetricV3']['cvssV3']['baseSeverity']
        # check the entry's baseScore is actually a valid float
        try:
            entry['baseScore'] = float(entry['baseScore'])
        except ValueError:
            print("%s: %d: baseScore %s is not a valid float" %
                  (cvepath, linenum, entry['baseScore']),
                  file=sys.stderr)
            cve_okay = False
        if entry['baseScore'] != baseScore:
            print("%s: %d: baseScore %s is not correct, should be %02.1f" %
                  (cvepath, linenum, entry['baseScore'], baseScore),
                  file=sys.stderr)
            cve_okay = False
        if entry['baseSeverity'] != baseSeverity:
            print("%s: %d: baseSeverity %s is not correct, should be %s" %
                  (cvepath, linenum, entry['baseSeverity'], baseSeverity),
                  file=sys.stderr)
            cve_okay = False
    return cve_okay


def check_assigned_to(cvepath, data, srcentries, cve_okay):
    """
    Verify if a retired CVE still has the field Assigned-to filled.
    """
    assigned = data["Assigned-to"]
    if assigned != "":
        linenum = srcentries["Assigned-to"][1]
        print(
            "%s: %d: CVE is retired, but has Assigned-to set to %s, should be blank" %
            (cvepath, linenum, assigned),
            file=sys.stderr
        )
        if opt.autofix:
            fixup_assignedto(cvepath)
        return False
    return cve_okay


def check_needed_needs_triage(cvepath, data, pkg, srcentries, cve_okay):
    """
    Check if a retired UCT CVE has any package release statuses as
    `needs-triage` or `needed`.
    """
    for release_name, details in data["pkgs"][pkg].items():
        if release_name == "upstream":
            # Ignore the upstream field since we don't do a good job at updating those
            continue

        # Only check CVEs in UCT
        if release_name in uct_required_releases:
            line_num = srcentries["pkgs"][pkg][release_name][1]
            status = details[0]

            if status in ["needs-triage", "needed"]:
                print(
                    "%s: %d: CVE is retired, but package '%s' in release '%s' has status '%s'." %
                    (cvepath, line_num, pkg, release_name, status),
                    file=sys.stderr
                )
                cve_okay = False

    return cve_okay


def check_package_priority(cvepath, data, srcentries, cve_okay):
    """
    Verify per-package and per-package-release priorities
    """
    for pkg_priority in [x for x in data if "Priority_" in x]:
        linenum = srcentries[pkg_priority][1]
        fields = pkg_priority.split("_", 2)
        if len(fields) == 2:
            pkg = fields[1]
            if pkg not in data["pkgs"]:
                print(
                    "%s: %d: per package priority (%s) does not match any package in cve"
                    % (cvepath, linenum, pkg),
                    file=sys.stderr,
                )
                cve_okay = False
        elif len(fields) == 3:
            pkg, release = fields[1:3]
            if pkg not in data["pkgs"]:
                print(
                    "%s: %d: per package/release priority (%s/%s) does not match a package/release pair in cve"
                    % (cvepath, linenum, pkg, release),
                    file=sys.stderr,
                )
                cve_okay = False
            elif (
                release not in cve_lib.all_releases and not release == "devel"
            ) or release not in data["pkgs"][pkg]:
                print(
                    "%s: %d: invalid release in per package/release priority pair (%s/%s)"
                    % (cvepath, linenum, pkg, release),
                    file=sys.stderr,
                )
                cve_okay = False
    return cve_okay


def check_cve_priority(cvepath, data, srcentries, cve_okay):
    """
    Verify if a proper CVE priority is set and in the case of low, high or
    critical, a reason is given, as well as check if any applied tags should
    raise the priority given.
    """
    priority = data["Priority"][0]
    priority_reason = data["Priority"][1]
    tags = cve_lib.GLOBAL_TAGS_KEY
    linenum = srcentries["Priority"][1]
    if priority not in cve_lib.priorities and\
            (is_active(cvepath) or is_embargoed(cvepath)):
        print(
            "%s: %d: priority unknown" % (cvepath, linenum),
            file=sys.stderr
        )
        cve_okay = False
    elif (
        priority in cve_lib.PRIORITY_REASON_REQUIRED
        and ("XXX-Reason-XXX" in priority_reason)
    ):
        print(
            "%s: %d: needs a reason for being '%s'\n" % (cvepath, linenum, priority),
            file=sys.stderr
        )
        cve_okay = False
    elif tags in data["tags"] and "cisa-kev" in data["tags"][tags] and\
        is_active(cvepath) and priority not in ["high", "critical"]:
        print(
            """
            %s: %d: priority should be 'high' or 'critical' not '%s' for an
            active CVE in the CISA KEV
            """ % (cvepath, linenum, priority),
            file=sys.stderr
        )
        if opt.autofix:
            fixup_priority(cvepath, "high")
        cve_okay = False
    return cve_okay


def check_cve_description(cvepath, data, srcentries, cve_okay):
    """             
    Verify if the CVE description has been changed to rejected
    by MITRE, we should move CVE to ignore state.
    """
    if (
        is_active(cvepath)
        and "Description" in data
        and (data["Description"].lstrip().startswith("** REJECT **")
             or data["Description"].lstrip().startswith("Rejected reason"))
        # FIXME: Skip this one for now until all our kernel updates have
        # been published. This is an ugly hack, but we don't want to risk
        # having check-syntax autofix this.
        and "CVE-2025-0927" not in cvepath
    ):          
        linenum = srcentries["Description"][1]
        print(
            "%s: %d: Rejected by MITRE (possibly a duplicate of another CVE?)"
            % (cvepath, linenum),
            file=sys.stderr,
        )   
        cve_okay = False
        if opt.autofix:
            fixup_rejected(cvepath)
    return cve_okay


def print_warning_reference(filename, linenum, ref):
    """
    Helper function to print warning about issue in references
    """
    print(
        "WARNING: %s: %d: does not contain reference to %s"
        % (
            filename,
            linenum,
            ref,
        ),
        file=sys.stderr,
    )


def check_references(cvepath, cve_id, data, srcentries, cve_okay):
    """
    Check for CVE.org reference, USN URLs and kernel references
    """
    linenum = srcentries["References"][1] if "References" in srcentries else 1
    if "References" in data:
        if opt.usndb and not is_ignored(cvepath):
            if cve_id in cves:
                for usn in cves[cve_id]:
                    found = False
                    usn_ref = "https://ubuntu.com/security/notices/USN-" + usn
                    if usn_ref in data["References"]:
                        found = True
                    if not found:
                        print_warning_reference(cvepath, linenum, usn_ref)
                        cve_okay = False
                        if opt.autofix:
                            fixup_missing_usn_ref(cvepath, usn_ref)
        if re.match(r"^CVE-\d+-\d+$", cve_id):
            cve_program_ref = "https://www.cve.org/CVERecord?id=" + cve_id
            if cve_program_ref not in data["References"]:
                print_warning_reference(cvepath, linenum, cve_program_ref)
                cve_okay = False
        # if there is a reference URL to a kernel commit then check there is a
        # break-fix entry against the linux package
        if "git.kernel.org" in data["References"]:
            # the CVE needs to already be triaged against linux and hence
            # have a patches entry for it
            if "linux" in data["patches"] and len(data["patches"]["linux"]) == 0:
                print(
                    "%s: %d: missing break-fix entry for kernel commit"
                    % (cvepath, linenum),
                    file=sys.stderr,
                )
                cve_okay = False
                if opt.autofix:
                    refs = re.findall(r".*git\.kernel\.org[\/|\w]*", data["References"])
                    for ref in refs:
                        fixup_entry_missing_break_fix(cvepath, "linux", ref)

    return cve_okay


def check_publicdate(cvepath, data, srcentries, cve_okay):
    """
    Verify that PublicDate or CRD are not empty
    """
    key = "PublicDate" if "PublicDate" in srcentries else "CRD"
    linenum = srcentries[key][1]
    if key not in data or data[key] == "":
        print(
            "%s: %d: must specify at least one of PublicDate or CRD as a valid date or unknown"
            % (
                cvepath,
                linenum,
            ),
            file=sys.stderr,
        )
    for d in ["PublicDate", "PublicDateAtUSN", "CRD"]:
        passes = []
        # Embargoed CVEs can have an empty or unknown PublicDate
        if d == "PublicDate" and is_embargoed(cvepath):
            passes = ["", "unknown"]
        if d == "PublicDateAtUSN":
            # PublicDateAtUSN can be empty
            passes = [""]
        if d == "CRD":
            # CRD can empty or unknown
            passes = ["", "unknown"]
        if d in data and data[d] not in passes:
            split_date = data[d].split()
            date_format = "%Y-%m-%d"
            date_value = data[d]

            # UTC is the only valid timezone
            if len(split_date) == 3:
                date_format = "%Y-%m-%d %H:%M:%S UTC"

            valid = False
            try:
                datetime.datetime.strptime(date_value, date_format)
                valid = True
            except ValueError:
                pass

            if not valid:
                linenum = srcentries[d][1]
                print(
                    "%s: %d: does not contain a valid %s '%s' (need YYYY-MM-DD [HH:MM:SS UTC]%s)"
                    % (cvepath, linenum, d, data[d], ", or ".join(passes)),
                    file=sys.stderr,
                )
                cve_okay = False
    return cve_okay


def check_cve_id(cvepath, cve_id, srcentries, cve_okay):
    """
    Verify if Candidate field has same value as the CVE ID
    """
    cve = os.path.basename(cvepath)
    if cve != cve_id:
        linenum = srcentries["Candidate"][1]
        print(
            "%s: %d: Candidate field '%s' mismatch with cve pathname '%s'"
            % (cvepath, linenum, cve_id, cve),
            file=sys.stderr,
        )
        return False
    return cve_okay


def check_required_fields(cvepath, data, cve_okay):
    """
    Verify if required fields are present
    """
    for field in required_fields:
        if field not in data:
            print("%s: missing required field '%s'" % (cvepath, field), file=sys.stderr)
            cve_okay = False
    return cve_okay


def check_duplicate_cve(cvepath, cve_id, cve_okay):
    if cve_id in ignored:
        print(
            "%s: %d: duplicate CVE found in not-for-us.txt" % (cvepath, 1),
            file=sys.stderr,
        )
        cve_okay = False

    matches = set()
    for dir in [
            cve_lib.active_dir,
            cve_lib.retired_dir,
            cve_lib.ignored_dir,
            cve_lib.embargoed_dir,
    ]:
        if os.path.exists(os.path.join(dir, cve_id)):
            matches.add(dir)
    if len(matches) > 1:
        print(
            "%s: %d: found in multiple classes: %s"
            % (cvepath, 1, ", ".join(sorted(matches))),
            file=sys.stderr,
        )
        cve_okay = False
    return cve_okay


def fixup_rejected(filename):
    if opt.dry_run:
        print("Dry-Run: move %s to ignored/" % (filename))
        return

    shutil.move(filename, cve_lib.ignored_dir)

def get_cve_path(cve, rel):
    cve = os.path.basename(cve)
    if rel in cve_lib.external_releases:
        # FIXME: Should we also be using get_external_subproject_dir here?
        cvepath = os.path.join(
            cve_lib.get_external_subproject_cve_dir(rel), cve
        )
    else:
        # Try and find where this CVE is located
        for d in cve_lib.cve_dirs:
            cvepath = os.path.join(d, cve)
            if os.path.exists(cvepath):
                return cvepath
        # Fall back to the active directory if that didn't work?
        cvepath = os.path.join(cve_lib.active_dir, cve)
    return cvepath

def check_cve(cve):
    cve_okay = True
    srcentries = dict()
    # get the absolute path of the cve so that functions like is_boilerplate()
    # work as expected
    cvepath = os.path.abspath(cve)
    if opt.stdin:
        cvepath = cve
    else:
        cve_id = os.path.basename(cve)
        if not is_boilerplate(cvepath):
            cvepath = cve_lib.find_cve(cve_id)
    data = cve_lib.load_cve(cvepath, opt.strict, srcentries=srcentries)
    cve_id = data["Candidate"]
    if opt.stdin: 
        cvepath = cve_lib.find_cve(cve_id)

    if is_boilerplate(cvepath):
        cve_okay = check_required_fields(cvepath, data, cve_okay)

        for pkg in sorted(data["pkgs"].keys()):
            cve_okay = check_pkg_uct_required_releases(cvepath, data, pkg, srcentries, cve_okay)
            
            cve_okay = check_eol_release_status(cvepath, data, pkg, srcentries, cve_okay)
    
            cve_okay = check_no_external_release_in_file(cvepath, data, pkg, srcentries, cve_okay)
    else:
 
        cve_okay = check_duplicate_cve(cvepath, cve_id, cve_okay)

        cve_okay = check_required_fields(cvepath, data, cve_okay)

        if not opt.stdin:
            cve_okay = check_cve_id(cvepath, cve_id, srcentries, cve_okay)

        cve_okay = check_publicdate(cvepath, data, srcentries, cve_okay)

        if not is_embargoed(cvepath):
            cve_okay = check_references(cvepath, cve_id, data, srcentries, cve_okay)

        cve_okay = check_cve_description(cvepath, data, srcentries, cve_okay)

        cve_okay = check_cve_priority(cvepath, data, srcentries, cve_okay)

        cve_okay = check_cvss(cvepath, data, srcentries, cve_okay)

        if is_retired(cvepath) or is_ignored(cvepath):
            cve_okay = check_assigned_to(cvepath, data, srcentries, cve_okay)

        cve_okay = check_package_priority(cvepath, data, srcentries, cve_okay)

        cve_okay = check_patches(cvepath, data, srcentries, cve_okay)

        for pkg in sorted(data["pkgs"].keys()):
            cve_okay = check_cve_pkg_required_releases(cvepath, data, pkg, srcentries, cve_okay)

            cve_okay = check_no_external_release_in_file(cvepath, data, pkg, srcentries, cve_okay)

            cve_okay = check_eol_release_status(cvepath, data, pkg, srcentries, cve_okay)

            if not is_ignored(cvepath):
                cve_okay = check_esm_release_status(cvepath, data, pkg, srcentries, cve_okay)

            if is_retired(cvepath):
                cve_okay = check_needed_needs_triage(cvepath, data, pkg, srcentries, cve_okay)

    return cve_okay


if opt.jobs > 1:
    # use ProcessPoolExecutor for parallel processing since this is more efficient
    # than multiple threads via ThreadPoolExecutor as we can keep each at 100% CPU
    # utilisation
    with concurrent.futures.ProcessPoolExecutor(max_workers=opt.jobs) as p:
        results = p.map(check_cve, args)
else:
    results = map(check_cve, args)
# evaluate the results so that all() below doesn't bail out early in the case of errors
# and hence the other CVEs never get checked
results = list(results)
assert len(results) == len(args)
all_okay &= all(results)

if all_okay and opt.verbose:
    print("OK: %d CVEs" % (len(args)))
# Invert boolean for unix exit code
sys.exit(not all_okay)
